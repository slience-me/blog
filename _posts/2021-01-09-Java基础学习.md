---
layout: post
title: Java｜Java基础学习
categories: [Java]
description: Java基础学习
keywords: 编程语言, Java 
mermaid: false
sequence: false
flow: false
mathjax: false
mindmap: false
mindmap2: false
---

![img](https://raw.githubusercontent.com/slience-me/picGo/master/images/logo_slienceme3.jpeg)

本文作者： [slience_me](https://slienceme.cn/)

---

# Java基础学习

# 第一章 认识 HelloWorld
javac 文件名.java  编译
java  文件名   运行

idea常用快捷键
![Alt Text](/images/posts/20210109064244117.png)


**注释方法与C语言相同**

```java
// 第一行的第三个单词必须和所在的文件名称完全一样，大小写也要一样
//public class 后面代表定义一个类的名称，类是Java当中所有源代码的基本组织单位。
public class HelloWorld {
	// 第二行是万年不变的固定写法，代表main方法
	// 这一行代表程序执行的起点
    public static void main(String[] args){
		// 第三行代表打印输出语句（其实就是屏幕显示）
        System.out.println("Hello,World!");
    }
}
```

##  1.命名
### 1. 命名规则
**1.1 硬性要求**

 - 标识符可以包含英文26个字母（区分大小写）、0-9数字、$（美元符号） 和 _（下划线）
 - 标识符不能以数字开头
 - 标识符不能是关键字


### 2. 命名规范
**2.1 软性建议**

 - 类名规范：首字母大写，后面每个单词首字母大写（大驼峰式）。HelloWorld
 - 变量名规范：首字母小写，后面每个单词首字母大写（小驼峰式）helloWorld
 - 方法名规范：同变量名

# 第二章 常量
**常量**：在程序运行期间，固定不变的量

**常量的分类**：
1. 字符串常量：凡是用双引号引起来的部分，叫做字符串常量，例如：“abc”、“Hello”、“123”
2. 整数常量：直接写上的数字，没有小数点，例如：100、200、0、-250
3. 浮点数常量：直接写上的数字，有小数点。例如：2.5、-3.14、0.0
4. 字符常量：凡是用单引号引起来的单个字符，就做字符常量。例如：‘A’、'b'、'9'、'中'
5. 布尔常量：只有量中取值。true、false.
6. 空常量：null.代表没有任何数据

```java
public class test {
	public static void main(String[] args) {
		// 字符串常量
		System.out.println("ABC");
		System.out.println("");
		System.out.println("XYZ");
		
		// 整数常量
		System.out.println(30);
		System.out.println(-500);
		
		// 浮点数常量（小数）
		System.out.println(1.14);
		System.out.println(-2.5);
		
		//字符常量
		System.out.println('A');
		System.out.println('6');
		//System.out.println('')//两个单引号中间必须仅有一个字符，没有不行。
		//System.out.println('AB');//两个单引号中间必须仅有一个字符，两个不行。
		
		//布尔常量
		System.out.println(true);
		System.out.println(false);
		
		//空常量，空常量不能直接用来打印输出。
		//System.out.println(null); 
	}
}
```
![Alt Text](/images/posts/20210108072903704.png)
# 第三章 变量和数据类型
## 3.1 变量概述

 - 变量：常量是固定不变的数据，那么在程序中可以变化的量称为变量。
		数学中，可以使用字母代替数字运算，例如x=1+5或者6=x+5。
		程序中，可以使用字母保存数字的方式进行运算，提高计算能力，可以解决更多的问题。别不x保存5，x也可以保存6，这样x保存的数据是可以改变的，也就是我们所讲解的变量。

Java中要求一个变量每次只能保存一个数据，必须要明确保存的数据类型。 

## 3.2 数据类型
## 3.3 变量的定义

```java
/*
变量：程序运行期间，内容可以发生改变的量。

创建一个变量并且使用的格式：

数据类型 变量名称; // 创建了一个变量
变量名称 = 数据值; // 赋值，将右边的数据值，赋值交给左边的变量

一步到位的格式：

数据类型 变量名称 = 数据值; // 在创建一个变量的同时，立刻放入指定的数据值
*/
public class Demo02Variable {
	public static void main(String[] args) {
		// 创建一个变量
		// 格式：数据类型 变量名称;
		int num1;
		// 向变量当中存入一个数据
		// 格式：变量名称 = 数据值;
		num1 = 10;
		// 当打印输出变量名称的时候，显示出来的是变量的内容
		System.out.println(num1); // 10
		
		// 改变变量当中本来的数字，变成新的数字
		num1 = 20;
		System.out.println(num1); // 20
		
		// 使用一步到位的格式来定义变量
		// 格式：数据类型 变量名称 = 数据值;
		int num2 = 25;
		System.out.println(num2); // 25
		
		num2 = 35;
		System.out.println(num2); // 35
		System.out.println("===============");
		
		byte num3 = 30; // 注意：右侧数值的范围不能超过左侧数据类型的取值范围
		System.out.println(num3); // 30
		
		// byte num4 = 400; // 右侧超出了byte数据范围，错误！
		
		short num5 = 50;
		System.out.println(num5); // 50
		
		long num6 = 3000000000L;
		System.out.println(num6); // 3000000000
		
		float num7 = 2.5F;
		System.out.println(num7); // 2.5
		
		double num8 = 1.2;
		System.out.println(num8); // 1.2
		
		char zifu1 = 'A';
		System.out.println(zifu1); // A
		
		zifu1 = '中';
		System.out.println(zifu1); // 中
		
		boolean var1 = true;
		System.out.println(var1); // true
		
		var1 = false;
		System.out.println(var1); // false
		
		// 将一个变量的数据内容，赋值交给另一个变量
		// 右侧的变量名称var1已经存在，里面装的是false布尔值
		// 将右侧变量里面的false值，向左交给var2变量进行存储
		boolean var2 = var1;
		System.out.println(var2); // false
	}
}
```
![Alt Text](/images/posts/20210108100316683.png)

```java
/*
使用变量的时候，有一些注意事项：

1. 如果创建多个变量，那么变量之间的名称不可以重复。
2. 对于float和long类型来说，字母后缀F和L不要丢掉。
3. 如果使用byte或者short类型的变量，那么右侧的数据值不能超过左侧类型的范围。
4. 没有进行赋值的变量，不能直接使用；一定要赋值之后，才能使用。
5. 变量使用不能超过作用域的范围。
【作用域】：从定义变量的一行开始，一直到直接所属的大括号结束为止。
6. 可以通过一个语句来创建多个变量，但是一般情况不推荐这么写。
*/
public class Demo03VariableNotice {
	public static void main(String[] args) {
		int num1 = 10; // 创建了一个新的变量，名叫num1
		// int num1 = 20; // 又创建了另一个新的变量，名字也叫num1，错误！
		
		int num2 = 20;
		
		int num3;
		num3 = 30;
		
		int num4; // 定义了一个变量，但是没有进行赋值
		// System.out.println(num4); // 直接使用打印输出就是错误的！
		
		// System.out.println(num5); // 在创建变量之前，不能使用这个变量
		
		int num5 = 500;
		System.out.println(num5); // 500
		
		{
			int num6 = 60;
			System.out.println(num6); // 60
		}
		// int num6;
		// System.out.println(num6); // 已经超出了大括号的范围，超出了作用域，变量不能再使用了
		
		// 同时创建了三个全都是int类型的变量
		int a, b, c;
		// 各自分别赋值
		a = 10;
		b = 20;
		c = 30;
		System.out.println(a); // 10
		System.out.println(b); // 20
		System.out.println(c); // 30
		
		// 同时创建三个int变量，并且同时各自赋值
		int x = 100, y = 200, z = 300;
		System.out.println(x); // 100
		System.out.println(y); // 200
		System.out.println(z); // 300
	}
}
```
## 3.4 注意事项
### 基本数据类型
	

 - 整数型	byte short int long 	
 - 浮点型	float double 	
 - 字符型	char 	
 - 布尔型	boolean

### 引用数据类型
	字符串、数组、类、接口、Lambda
	
注意事项：
1. 字符串不是基本类型，而是引用类型。
2. 浮点型可能只是一个近似值，并非精确的值。
3. 数据范围与字节数不一定相关，例如float数据范围比long更加广泛，但是float是4字节，long是8字节。
4. 浮点数当中默认类型是double。如果一定要使用float类型，需要加上一个后缀F。
   如果是整数，默认为int类型，如果一定要使用long类型，需要加上一个后缀L。推荐使用大写字母后缀。
![Alt Text](/images/posts/20210108102109119.png)
# 第四章 数据类型转换
## 4.1 自动转换

```java
/*
当数据类型不一样时，将会发生数据类型转换。

自动类型装换(隐式)
	1. 特点:代码不需要进行特殊处理，自动完成。
	2. 规则:数据范围从小到大。
强制类型转换(显式)
*/
public class Demo01DataType{
	public static void main(String[] srgs){
		System.out.println(1024);//这就是一个整数，默认就是int类型
		System.out.println(3.14);//这就是一个浮点数，默认是就是double类型
		
		// 左边是long类型，右边是默认的int类型，左右不一样
		// 一个等号代表赋值，将右侧的int常量，交给左侧的long变量进行存储
		// int --> long，符合了数据范围从小到大的要求
		// 这一行代码发生了自动类型转换。
		long num1 = 100;
		System.out.println(num1); //100
		
		// 左边是double类型，右边是float类型，左右不一样
		// float-->double,符合了数据范围从小到大的规则
		// 也发生了自动类型转换
		double num2 = 2.5F;
		System.out.println(num2);//2.5
		
		// 左边是float类型，右边是long类型，左右不一样
		// long-->float，范围是float更大一些，符合了数据范围从小到大的规则
		//也发生了自动类型转换
		float num3 = 30L;
	}
}
```
## 4.2 强制类型转换

```java
/*
强制类型转换
	1. 特点：代码需要进行特殊的格式处理，不能自动完成。
	2. 格式：范围小的类型 范围小的变量名 = (范围小的类型) 原本范围大的数据;

注意事项：
	1. 强制类型转换一般不推荐使用，因为有可能发生精度损失、数据溢出。
	2. byte/short/char这三种类型都可以发生数学运算，例如加法“+”.
	3. byte/short/char这三种类型在运算的时候，都会被首先提升成为int类型，然后再计算。
	4. boolean类型不能发生数据类型转换
*/
public class Demo02DataType {
	public static void main(String[] args) {
		// 左边是int类型，右边是long类型，不一样
		// long --> int，不是从小到大
		// 不能发生自动类型转换！
		// 格式：范围小的类型 范围小的变量名 = (范围小的类型) 原本范围大的数据;
		int num = (int) 100L;
		System.out.println(num);
		
		// long强制转换成为int类型 数据溢出
		int num2 = (int) 6000000000L;
		System.out.println(num2); // 1705032704
		
		// double --> int，强制类型转换
		int num3 = (int) 3.99;
		System.out.println(num3); // 3，这并不是四舍五入，所有的小数位都会被舍弃掉
		
		char zifu1 = 'A'; // 这是一个字符型变量，里面是大写字母A
		System.out.println(zifu1 + 1); // 66，也就是大写字母A被当做65进行处理
		// 计算机的底层会用一个数字（二进制）来代表字符A，就是65
		// 一旦char类型进行了数学运算，那么字符就会按照一定的规则翻译成为一个数字
		
		byte num4 = 40; // 注意！右侧的数值大小不能超过左侧的类型范围
		byte num5 = 50;
		// byte + byte --> int + int --> int
		int result1 = num4 + num5;
		System.out.println(result1); // 90
		
		short num6 = 60;
		// byte + short --> int + int --> int
		// int强制转换为short：注意必须保证逻辑上真实大小本来就没有超过short范围，否则会发生数据溢出
		short result2 = (short) (num4 + num6);
		System.out.println(result2); // 100
	}
}
```
## 4.3 Ascall编码表

```java
/*
数字和字符的对照关系表（编码表）：

ASCII码表：American Standard Code for Information Interchange，美国信息交换标准代码。
Unicode码表：万国码。也是数字和符号的对照关系，开头0-127部分和ASCII完全一样，但是从128开始包含有更多字符。

48 - '0'
65 - 'A'
97 - 'a'
*/
public class Demo03DataTypeChar {
	public static void main(String[] args) {
		char zifu1 = '1';
		System.out.println(zifu1 + 0); // 49
		
		char zifu2 = 'A'; // 其实底层保存的是65数字
		
		char zifu3 = 'c';
		// 左侧是int类型，右边是char类型，
		// char --> int，确实是从小到大
		// 发生了自动类型转换
		int num = zifu3;
		System.out.println(num); // 99
		
		char zifu4 = '中'; // 正确写法
		System.out.println(zifu4 + 0); // 20013
	}
}
```
# 第五章 运算符
## 5.1 算数运算符
![Alt Text](/images/posts/20210108165435380.png)

```java
/*
运算符：进行特定操作的符号。例如：+
表达式：用运算符连起来的式子叫做表达式。例如：20 + 5。又例如：a + b

四则运算：
加：+
减：-
乘：*
除：/

取模（取余数）：%

首先计算得到表达式的结果，然后再打印输出这个结果。
复习一下小学一年级的除法公式：
被除数 / 除数 = 商 ... 余数

对于一个整数的表达式来说，除法用的是整除，整数除以整数，结果仍然是整数。只看商，不看余数。
只有对于整数的除法来说，取模运算符才有余数的意义。

注意事项：
	1. 一旦运算当中有不同类型的数据，那么结果将会是数据类型范围大的那种。
*/
public class Demo04Operator {
	public static void main(String[] args) {
		// 两个常量之间可以进行数学运算
		System.out.println(20 + 30);
		
		// 两个变量之间也可以进行数学运算
		int a = 20;
		int b = 30;
		System.out.println(a - b); // -10
		
		// 变量和常量之间可以混合使用
		System.out.println(a * 10); // 200
		
		int x = 10;
		int y = 3;
		
		int result1 = x / y;
		System.out.println(result1); // 3
		
		int result2 = x % y;
		System.out.println(result2); // 余数，模，1
		
		// int + double --> double + double --> double
		double result3 = x + 2.5;
		System.out.println(result3); // 12.5
	}
}
```

```java
/*
四则运算当中的加号“+”有常见的三种用法：

1. 对于数值来说，那就是加法。
2. 对于字符char类型来说，在计算之前，char会被提升成为int，然后再计算。
char类型字符，和int类型数字，之间的对照关系表：ASCII、Unicode
3. 对于字符串String（首字母大写，并不是关键字）来说，加号代表字符串连接操作。
任何数据类型和字符串进行连接的时候，结果都会变成字符串
*/
public class Demo05Plus {
	public static void main(String[] args) {
		// 字符串类型的变量基本使用
		// 数据类型 变量名称 = 数据值;
		String str1 = "Hello";
		System.out.println(str1); // Hello
		
		System.out.println("Hello" + "World"); // HelloWorld
		
		String str2 = "Java";
		// String + int --> String
		System.out.println(str2 + 20); // Java20
		
		// 优先级问题
		// String + int + int
		// String		+ int
		// String
		System.out.println(str2 + 20 + 30); // Java2030
		
		System.out.println(str2 + (20 + 30)); // Java50
	}
}
```

```java
/*
自增运算符：++
自减运算符：--

基本含义：让一个变量涨一个数字1，或者让一个变量降一个数字1
使用格式：写在变量名称之前，或者写在变量名称之后。例如：++num，也可以num++
使用方式：
	1. 单独使用：不和其他任何操作混合，自己独立成为一个步骤。
	2. 混合使用：和其他操作混合，例如与赋值混合，或者与打印操作混合，等。
使用区别：
	1. 在单独使用的时候，前++和后++没有任何区别。也就是：++num;和num++;是完全一样的。
	2. 在混合的时候，有【重大区别】
		A. 如果是【前++】，那么变量【立刻马上+1】，然后拿着结果进行使用。	【先加后用】
		B. 如果是【后++】，那么首先使用变量本来的数值，【然后再让变量+1】。	【先用后加】
		
注意事项：
	只有变量才能使用自增、自减运算符。常量不可发生改变，所以不能用。
*/
public class Demo06Operator {
	public static void main(String[] args) {
		int num1 = 10;
		System.out.println(num1); // 10
		++num1; // 单独使用，前++
		System.out.println(num1); // 11
		num1++; // 单独使用，后++
		System.out.println(num1); // 12
		System.out.println("=================");
		
		// 与打印操作混合的时候
		int num2 = 20;
		// 混合使用，先++，变量立刻马上变成21，然后打印结果21
		System.out.println(++num2); // 21
		System.out.println(num2); // 21
		System.out.println("=================");
		
		int num3 = 30;
		// 混合使用，后++，首先使用变量本来的30，然后再让变量+1得到31
		System.out.println(num3++); // 30
		System.out.println(num3); // 31
		System.out.println("=================");
		
		int num4 = 40;
		// 和赋值操作混合
		int result1 = --num4; // 混合使用，前--，变量立刻马上-1变成39，然后将结果39交给result1变量
		System.out.println(result1); // 39
		System.out.println(num4); // 39
		System.out.println("=================");
		
		int num5 = 50;
		// 混合使用，后--，首先把本来的数字50交给result2，然后我自己再-1变成49
		int result2 = num5--;
		System.out.println(result2); // 50
		System.out.println(num5); // 49
		System.out.println("=================");
		
		int x = 10;
		int y = 20;
		// 11 + 20 = 31
		int result3 = ++x + y--;
		System.out.println(result3); // 31
		System.out.println(x); // 11
		System.out.println(y); // 19
		
		// 30++; // 错误写法！常量不可以使用++或者--
	}
}
```

## 5.2 赋值运算符

```java
/*
赋值运算符分为：

基本赋值运算符：就是一个等号“=”，代表将右侧的数据交给左侧的变量。
	int a = 30;

复合赋值运算符：
	+=		a += 3		相当于		a = a + 3
	-=		b -= 4		相当于		b = b - 4
	*=		c *= 5		相当于		c = c * 5
	/=		d /= 6		相当于		d = d / 6
	%=		e %= 7		相当于		e = e % 7

注意事项：
	1. 只有变量才能使用赋值运算符，常量不能进行赋值。
	2. 复合赋值运算符其中隐含了一个强制类型转换。
*/
public class Demo07Operator {
	public static void main(String[] args) {
		int a = 10;
		// 按照公式进行翻译：a = a + 5
		// a = 10 + 5;
		// a = 15;
		// a本来是10，现在重新赋值得到15
		a += 5; 
		System.out.println(a); // 15
		
		int x = 10;
		// x = x % 3;
		// x = 10 % 3;
		// x = 1;
		// x本来是10，现在重新赋值得到1
		x %= 3;
		System.out.println(x); // 1
		
		// 50 = 30; // 常量不能进行赋值，不能写在赋值运算符的左边。错误写法！
		
		byte num = 30;
		// num = num + 5;
		// num = byte + int
		// num = int + int
		// num = int
		// num = (byte) int
		num += 5;
		System.out.println(num); // 35
	}
}
```

## 5.3 比较运算符

```java
/*
比较运算符：
大于：		>
小于：		<
大于等于：	>=
小于等于：	<=
相等：		==	【两个等号连写才是相等，一个等号代表的是赋值】
不相等：	!=

注意事项：
1. 比较运算符的结果一定是一个boolean值，成立就是true，不成立就是false
2. 如果进行多次判断，不能连着写。
数学当中的写法，例如：1 < x < 3
程序当中【不允许】这种写法。
*/
public class Demo08Operator {
	public static void main(String[] args) {
		System.out.println(10 > 5); // true
		int num1 = 10;
		int num2 = 12;
		System.out.println(num1 < num2); // true
		System.out.println(num2 >= 100); // false
		System.out.println(num2 <= 100); // true
		System.out.println(num2 <= 12); // true
		System.out.println("===============");
		
		System.out.println(10 == 10); // true
		System.out.println(20 != 25); // true
		System.out.println(20 != 20); // false
		
		int x = 2;
		// System.out.println(1 < x < 3); // 错误写法！编译报错！不能连着写。
	}
}
```

## 5.4 逻辑运算符

```java
/*
与（并且）	&&	全都是true，才是true；否则就是false
或（或者）	||	至少一个是true，就是true；全都是false，才是false
非（取反）	!	本来是true，变成false；本来是false，变成true

与“&&”，或“||”，具有短路效果：如果根据左边已经可以判断得到最终结果，那么右边的代码将不再执行，从而节省一定的性能。

注意事项：
1. 逻辑运算符只能用于boolean值。
2. 与、或需要左右各自有一个boolean值，但是取反只要有唯一的一个boolean值即可。
3. 与、或两种运算符，如果有多个条件，可以连续写。
两个条件：条件A && 条件B
多个条件：条件A && 条件B && 条件C

TIPS：
对于1 < x < 3的情况，应该拆成两个部分，然后使用与运算符连接起来：
int x = 2;
1 < x && x < 3
*/
public class Demo09Logic {
	public static void main(String[] args) {
		System.out.println(true && false); // false
		// true && true --> true
		System.out.println(3 < 4 && 10 > 5); // true
		System.out.println("============");
		
		System.out.println(true || false); // true
		System.out.println(true || true); // true
		System.out.println(false || false); // false
		System.out.println("============");
		
		System.out.println(true); // true
		System.out.println(!true); // false	
		System.out.println("============");
		
		int a = 10;
		// false && ...
		System.out.println(3 > 4 && ++a < 100); // false
		System.out.println(a); // 10
		System.out.println("============");
		
		int b = 20;
		// true || ...
		System.out.println(3 < 4 || ++b < 100); // true
		System.out.println(b); // 20
	}
}
```

## 5.5 三元运算符

```java
/*
一元运算符：只需要一个数据就可以进行操作的运算符。例如：取反!、自增++、自减--
二元运算符：需要两个数据才可以进行操作的运算符。例如：加法+、赋值=
三元运算符：需要三个数据才可以进行操作的运算符。

格式：
数据类型 变量名称 = 条件判断 ? 表达式A : 表达式B;

流程：
首先判断条件是否成立：
	如果成立为true，那么将表达式A的值赋值给左侧的变量；
	如果不成立为false，那么将表达式B的值赋值给左侧的变量；
二者选其一。

注意事项：
1. 必须同时保证表达式A和表达式B都符合左侧数据类型的要求。
2. 三元运算符的结果必须被使用。
*/
public class Demo10Operator {
	public static void main(String[] args) {
		int a = 10;
		int b = 20;
		
		// 数据类型 变量名称 = 条件判断 ? 表达式A : 表达式B;
		// 判断a > b是否成立，如果成立将a的值赋值给max；如果不成立将b的值赋值给max。二者选其一
		int max = a > b ? a : b; // 最大值的变量
		System.out.println("最大值：" + max); // 20
		
		// int result = 3 > 4 ? 2.5 : 10; // 错误写法！
		
		System.out.println(a > b ? a : b); // 正确写法！
		
		// a > b ? a : b; // 错误写法！
	}
}
```
# 第六章 方法入门

```java
/*
定义一个方法的格式：
public static void 方法名称() {
	方法体
}

方法名称的命名规则和变量一样，使用小驼峰。
方法体：也就是大括号当中可以包含任意条语句。

注意事项：
1. 方法定义的先后顺序无所谓。
2. 方法的定义不能产生嵌套包含关系。
3. 方法定义好了之后，不会执行的。如果要想执行，一定要进行方法的【调用】。

如何调用方法，格式：

方法名称();
*/
public class Demo11Method {
	
	public static void main(String[] args) {
		farmer(); // 调用农民的方法
		seller(); // 调用小商贩的方法
		cook(); // 调用厨子的方法
		me(); // 调用我自己的方法
	}
	
	// 厨子
	public static void cook() {
		System.out.println("洗菜");
		System.out.println("切菜");
		System.out.println("炒菜");
		System.out.println("装盘");
	}
	
	// 我
	public static void me() {
		System.out.println("吃");
	}
	
	// 小商贩
	public static void seller() {
		System.out.println("运输到农贸市场");
		System.out.println("抬高价格");
		System.out.println("吆喝");
		System.out.println("卖给厨子");
	}
	
	// 农民伯伯
	public static void farmer() {
		System.out.println("播种");
		System.out.println("浇水");
		System.out.println("施肥");
		System.out.println("除虫");
		System.out.println("收割");
		System.out.println("卖给小商贩");
	}
}
```
## 6.1 矩形打印
```java
/*
复习一下此前学习的方法基础入门知识。

定义格式：
public static void 方法名称() {
    方法体
}

调用格式：
方法名称();

注意事项：
1. 方法定义的先后顺序无所谓。
2. 方法定义必须是挨着的，不能在一个方法的内部定义另外一个方法。
3. 方法定义之后，自己不会执行的；如果希望执行，一定要进行方法的调用。
 */
public class Demo01Method {

    public static void main(String[] args) {
        printMethod();
    }
    public static void printMethod() {
        for (int j = 0; j < 5; j++) {
            for (int i = 0; i < 20; i++) {
                System.out.print("*");
            }
            System.out.println();
        }
    }

}
```
![Alt Text](/images/posts/20210109070001877.png)
## 6.2 方法的定义格式与三种调用格式
```java

/*
方法其实就是若干语句的功能集合。

方法好比是一个工厂。
蒙牛工厂     原料：奶牛、饲料、水
            产出物：奶制品
钢铁工厂     原料：铁矿石、煤炭
            产出物：钢铁建材

参数（原料）：就是进入方法的数据。
返回值（产出物）：就是从方法中出来的数据。

定义方法的完整格式：
修饰符 返回值类型 方法名称(参数类型 参数名称, ...) {
    方法体
    return 返回值;
}

修饰符：现阶段的固定写法，public static
返回值类型：也就是方法最终产生的数据结果是什么类型
方法名称：方法的名字，规则和变量一样，小驼峰
参数类型：进入方法的数据是什么类型
参数名称：进入方法的数据对应的变量名称
PS：参数如果有多个，使用逗号进行分隔
方法体：方法需要做的事情，若干行代码
return：两个作用，第一停止当前方法，第二将后面的返回值还给调用处
返回值：也就是方法执行后最终产生的数据结果

注意：return后面的“返回值”，必须和方法名称前面的“返回值类型”，保持对应。

定义一个两个int数字相加的方法。三要素：
返回值类型：int
方法名称：sum
参数列表：int a, int b

方法的三种调用格式。
1. 单独调用：方法名称(参数);
2. 打印调用：System.out.println(方法名称(参数));
3. 赋值调用：数据类型 变量名称 = 方法名称(参数);

注意：此前学习的方法，返回值类型固定写为void，这种方法只能够单独调用，不能进行打印调用或者赋值调用。
*/
public class Demo02MethodDefine {

    public static void main(String[] args) {
        // 单独调用
        sum(10, 20);
        System.out.println("===========");

        // 打印调用
        System.out.println(sum(10, 20)); // 30
        System.out.println("===========");

        // 赋值调用
        int number = sum(15, 25);
        number += 100;
        System.out.println("变量的值：" + number); // 140
    }

    public static int sum(int a, int b) {
        System.out.println("方法执行啦！");
        int result = a + b;
        return result;
    }
```
## 6.3  方法有参调用，与无参调用

```java

/*
有参数：小括号当中有内容，当一个方法需要一些数据条件，才能完成任务的时候，就是有参数。
例如两个数字相加，必须知道两个数字是各自多少，才能相加。

无参数：小括号当中留空。一个方法不需要任何数据条件，自己就能独立完成任务，就是无参数。
例如定义一个方法，打印固定10次HelloWorld。
 */
public class Demo03MethodParam {

    public static void main(String[] args) {
        method1(10, 20);
        System.out.println("==============");
        method2();
    }

    // 两个数字相乘，做乘法，必须知道两个数字各自是多少，否则无法进行计算
    // 有参数
    public static void method1(int a, int b) {
        int result = a * b;
        System.out.println("结果是：" + result);
    }

    // 例如打印输出固定10次文本字符串
    public static void method2() {
        for (int i = 0; i < 10; i++) {
            System.out.println("Hello, World!" + i);
        }
    }

}
```
## 6.4 有返回值与无返回值

```java

/*
题目要求：定义一个方法，用来【求出】两个数字之和。（你帮我算，算完之后把结果告诉我。）
题目变形：定义一个方法，用来【打印】两个数字之和。（你来计算，算完之后你自己负责显示结果，不用告诉我。）

注意事项：
对于有返回值的方法，可以使用单独调用、打印调用或者赋值调用。
但是对于无返回值的方法，只能使用单独调用，不能使用打印调用或者赋值调用。
 */
public class Demo04MethodReturn {

    public static void main(String[] args) {
        // 我是main方法，我来调用你。
        // 我调用你，你来帮我计算一下，算完了之后，把结果告诉我的num变量
        int num = getSum(10, 20);
        System.out.println("返回值是：" + num);
        System.out.println("==============");

        printSum(100, 200);
        System.out.println("==============");

        System.out.println(getSum(2, 3)); // 正确写法
        getSum(3, 5); // 正确写法，但是返回值没有用到
        System.out.println("==============");

        // 对于void没有返回值的方法，只能单独，不能打印或者赋值
//        System.out.println(printSum(2, 3)); // 错误写法！
//        System.out.println(void);

//        int num2 = printSum(10, 20); // 错误写法！
//        int num3 = void;
//        void num4 = void;
    }

    // 我是一个方法，我负责两个数字相加。
    // 我有返回值int，谁调用我，我就把计算结果告诉谁
    public static int getSum(int a, int b) {
        int result = a + b;
        return result;
    }

    // 我是一个方法，我负责两个数字相加。
    // 我没有返回值，不会把结果告诉任何人，而是我自己进行打印输出。
    public static void printSum(int a, int b) {
        int result = a + b;
        System.out.println("结果是：" + result);
    }

}
```

### 1.  比较两个数字

```java
/*
题目要求：
定义一个方法，用来判断两个数字是否相同。
 */
public class Demo01MethodSame {

    public static void main(String[] args) {
        System.out.println(isSame(10, 20)); // false
        System.out.println(isSame(20, 20)); // true
    }

    /*
    三要素：
    返回值类型：boolean
    方法名称：isSame
    参数列表：int a, int b
     */
    public static boolean isSame(int a, int b) {
        /*boolean same;
        if (a == b) {
            same = true;
        } else {
            same = false;
        }*/

        // boolean same = a == b ? true : false;

        // boolean same = a == b;

        return a == b;
    }

}
```
### 2. 前100项和

```java

/*
题目要求：
定义一个方法，用来求出1-100之间所有数字的和值。
 */
public class Demo02MethodSum {

    public static void main(String[] args) {
        System.out.println("结果是：" + getSum());
    }

    /*
    三要素
    返回值：有返回值，计算结果是一个int数字
    方法名称：getSum
    参数列表：数据范围已经确定，是固定的，所以不需要告诉我任何条件，不需要参数
     */
    public static int getSum() {
        int sum = 0;
        for (int i = 1; i <= 100; i++) {
            sum += i;
        }
        return sum;
    }

}
```
### 3. 打印指定次数的内容

```java

/*
题目要求：
定义一个方法，用来打印指定次数的HelloWorld。
 */
public class Demo03MethodPrint {

    public static void main(String[] args) {
        printCount(10);
    }

    /*
    三要素
    返回值类型：只是进行一大堆打印操作而已，没有计算，也没有结果要告诉调用处
    方法名称：printCount
    参数列表：到底要打印多少次？必须告诉我，否则我不知道多少次，没法打印。次数：int
     */
    public static void printCount(int num) {
        for (int i = 0; i < num; i++) {
            System.out.println("Hello, World!" + (i + 1));
        }
    }

}
```
### 4.注意事项

```java

/*
使用方法的时候，注意事项：

1. 方法应该定义在类当中，但是不能在方法当中再定义方法。不能嵌套。
2. 方法定义的前后顺序无所谓。
3. 方法定义之后不会执行，如果希望执行，一定要调用：单独调用、打印调用、赋值调用。
4. 如果方法有返回值，那么必须写上“return 返回值;”，不能没有。
5. return后面的返回值数据，必须和方法的返回值类型，对应起来。
6. 对于一个void没有返回值的方法，不能写return后面的返回值，只能写return自己。
7. 对于void方法当中最后一行的return可以省略不写。
8. 一个方法当中可以有多个return语句，但是必须保证同时只有一个会被执行到，两个return不能连写。
 */
public class Demo04MethodNotice {

    public static int method1() {
        return 10;
    }

    public static void method2() {
//        return 10; // 错误的写法！方法没有返回值，return后面就不能写返回值。
        return; // 没有返回值，只是结束方法的执行而已。
    }

    public static void method3() {
        System.out.println("AAA");
        System.out.println("BBB");
//        return; // 最后一行的return可以省略不写。
    }

    public static int getMax(int a, int b) {
        /*int max;
        if (a > b) {
            max = a;
        } else {
            max = b;
        }
        return max;*/

        if (a > b) {
            return a;
        } else {
            return b;
        }
    }

}
```


# 第七章  Jshell脚本工具

```java

C:\Users\22509>jshell
|  欢迎使用 JShell -- 版本 15.0.1
|  要大致了解该版本, 请键入: /help intro

jshell> /help intro
|
|                                   intro
|                                   =====
|
|  使用 jshell 工具可以执行 Java 代码，从而立即获取结果。
|  您可以输入 Java 定义（变量、方法、类等等），例如：int x = 8
|  或 Java 表达式，例如：x + x
|  或 Java 语句或导入。
|  这些小块的 Java 代码称为“片段”。
|
|  这些 jshell 工具命令还可以让您了解和
|  控制您正在执行的操作，例如：/list
|
|  有关命令的列表，请执行：/help

jshell> System.out.p
print(     printf(    println(
jshell> System.out.println("hello,world");
hello,world

jshell> int a = 10;
a ==> 10

jshell> int b = 20;
b ==> 20

jshell> int result = a*b;
result ==> 200

jshell> /exit
|  再见
```

```java
/*
对于byte/short/char三种类型来说，如果右侧赋值的数值没有超过范围，
那么javac编译器将会自动隐含地为我们补上一个(byte)(short)(char)。

1. 如果没有超过左侧的范围，编译器补上强转。
2. 如果右侧超过了左侧范围，那么直接编译器报错。
*/
public class Demo12Notice {
	public static void main(String[] args) {
		// 右侧确实是一个int数字，但是没有超过左侧的范围，就是正确的。
		// int --> byte，不是自动类型转换
		byte num1 = /*(byte)*/ 30; // 右侧没有超过左侧的范围
		System.out.println(num1); // 30
		
		// byte num2 = 128; // 右侧超过了左侧的范围
		
		// int --> char，没有超过范围
		// 编译器将会自动补上一个隐含的(char)
		char zifu = /*(char)*/ 65;
		System.out.println(zifu); // A
	}
}
```

```java
/*
在给变量进行赋值的时候，如果右侧的表达式当中全都是常量，没有任何变量，
那么编译器javac将会直接将若干个常量表达式计算得到结果。
short result = 5 + 8; // 等号右边全都是常量，没有任何变量参与运算
编译之后，得到的.class字节码文件当中相当于【直接就是】：
short result = 13;
右侧的常量结果数值，没有超过左侧范围，所以正确。

这称为“编译器的常量优化”。

但是注意：一旦表达式当中有变量参与，那么就不能进行这种优化了。
*/
public class Demo13Notice {
	public static void main(String[] args) {
		short num1 = 10; // 正确写法，右侧没有超过左侧的范围，
		
		short a = 5;
		short b = 8;
		// short + short --> int + int --> int
		// short result = a + b; // 错误写法！左侧需要是int类型
		
		// 右侧不用变量，而是采用常量，而且只有两个常量，没有别人
		short result = 5 + 8;
		System.out.println(result);
		
		short result2 = 5 + a + 8; // 18 报错 不再常量优化
	}
}
```
# 第八章 流程控制
## 8.1 顺序结构
```java
// 顺序结构
public class Demo01Sequence {
	public static void main(String[] args) {
		System.out.println("今天天气不错");
		System.out.println("挺风和日丽的");
		System.out.println("我们下午没课");
		System.out.println("这的确挺爽的");
	}
}
```
## 8.2 单if语句
```java
// 单if语句
public class Demo02If {
	public static void main(String[] args) {
		System.out.println("今天天气不错，正在压马路……突然发现一个快乐的地方：网吧");
		int age = 19;
		if (age >= 18) {
			System.out.println("进入网吧，开始high！");
			System.out.println("遇到了一群猪队友，开始骂街。");
			System.out.println("感觉不爽，结账走人。");
		}
		System.out.println("回家吃饭");
	}
}
```
## 8.3 标准的if-else语句
```java
// 标准的if-else语句
public class Demo03IfElse {
	public static void main(String[] args) {
		int num = 666;
		
		if (num % 2 == 0) { // 如果除以2能够余数为0，说明是偶数
			System.out.println("偶数");
		} else {
			System.out.println("奇数");
		}
	}
}
```
## 8.4 多分支语句
```java
public class Demo05IfElsePractise {
	public static void main(String[] args) {
		int score = 120;
		if (score >= 90 && score <= 100) {
			System.out.println("优秀");
		} else if (score >= 80 && score < 90) {
			System.out.println("好");
		} else if (score >= 70 && score < 80) {
			System.out.println("良");
		} else if (score >= 60 && score < 70) {
			System.out.println("及格");
		} else if (score >= 0 && score < 60) {
			System.out.println("不及格");
		} else { // 单独处理边界之外的不合理情况
			System.out.println("数据错误");
		}
	}
}
```
### 题目：使用三元运算符和标准的if-else语句分别实现：取两个数字当中的最大值
```java
// 题目：使用三元运算符和标准的if-else语句分别实现：取两个数字当中的最大值
public class Demo06Max {
	public static void main(String[] args) {
		int a = 105;
		int b = 20;
		// 首先使用三元运算符
		// int max = a > b ? a : b;
		// 使用今天的if语句
		int max;
		if (a > b) {
			max = a;
		} else {
			max = b;
		}
		System.out.println("最大值：" + max);
	}
}
```
## 8.5 开关语句
```java
public class Demo07Switch {
	public static void main(String[] args) {
		int num = 10;
		
		switch (num) {
			case 1:
				System.out.println("星期一");
				break;
			case 2:
				System.out.println("星期二");
				break;
			case 3:
				System.out.println("星期三");
				break;
			case 4:
				System.out.println("星期四");
				break;
			case 5:
				System.out.println("星期五");
				break;
			case 6:
				System.out.println("星期六");
				break;
			case 7:
				System.out.println("星期日");
				break;
			default:
				System.out.println("数据不合理");
				break; // 最后一个break语句可以省略，但是强烈推荐不要省略
		}
	}
}
```

```java
/*
switch语句使用的注意事项：

1. 多个case后面的数值不可以重复。

2. switch后面小括号当中只能是下列数据类型：
基本数据类型：byte/short/char/int
引用数据类型：String字符串、enum枚举

3. switch语句格式可以很灵活：前后顺序可以颠倒，而且break语句还可以省略。
“匹配哪一个case就从哪一个位置向下执行，直到遇到了break或者整体结束为止。”
*/
public class Demo08SwitchNotice {
	public static void main(String[] args) {
		int num = 2;
		switch (num) {
			case 1:
				System.out.println("你好");
				break;
			case 2:
				System.out.println("我好");
				// break;
			case 3:
				System.out.println("大家好");
				break;
			default:
				System.out.println("他好，我也好。");
				break;
		} // switch
	}
}
```
## 8.6 for循环
```java
/*
循环结构的基本组成部分，一般可以分成四部分：

1. 初始化语句：在循环开始最初执行，而且只做唯一一次。
2. 条件判断：如果成立，则循环继续；如果不成立，则循环退出。
3. 循环体：重复要做的事情内容，若干行语句。
4. 步进语句：每次循环之后都要进行的扫尾工作，每次循环结束之后都要执行一次。
*/
public class Demo09For {
	public static void main(String[] args) {
		for (int i = 1; i <= 100; i++) {
			System.out.println("我错啦！原谅我吧！" + i);
		}
		System.out.println("程序停止");
	}
}
```
## 8.7 while循环
```java
/*
while循环有一个标准格式，还有一个扩展格式。

标准格式：
while (条件判断) {
	循环体
}

扩展格式：

初始化语句;
while (条件判断) {
	循环体;
	步进语句;
}
*/
public class Demo10While {
	public static void main(String[] args) {
		for (int i = 1; i <= 10; i++) {
			System.out.println("我错啦！" + i);
		}
		System.out.println("=================");
		
		int i = 1; // 1. 初始化语句
		while (i <= 10) { // 2. 条件判断
			System.out.println("我错啦！" + i); // 3. 循环体
			i++; // 4. 步进语句
		}
	}
}
```
## 8.8 do-while循环
```java
/*
do-while循环的标准格式：

do {
	循环体
} while (条件判断);

扩展格式：

初始化语句
do {
	循环体
	步进语句
} while (条件判断);
*/
public class Demo11DoWhile {
	public static void main(String[] args) {
		for (int i = 1; i <= 10; i++) {
			System.out.println("原谅你啦！起来吧！地上怪凉！" + i);
		}
		System.out.println("===============");
		
		int i = 1; // 1. 初始化语句
		do {
			System.out.println("原谅你啦！起来吧！地上怪凉！" + i); // 3. 循环体
			i++; // 4. 步进语句
		} while (i <= 10); // 2. 条件判断
	}
}
```
### 题目：求出1-100之间的偶数和。
```java
/*
题目：求出1-100之间的偶数和。

思路：
1. 既然范围已经确定了是1到100之间，那么我就从1、2、3……一直到100这么多数字一个一个进行检查。
2. 总共有100个数字，并非所有数字都能用。必须要是偶数才能用，判断（if语句）偶数：num % 2 == 0
3. 需要一个变量，用来进行累加操作。也就好比是一个存钱罐。
*/
public class Demo12HundredSum {
	public static void main(String[] args) {
		int sum = 0; // 用来累加的存钱罐
		
		for (int i = 1; i <= 100; i++) {
			if (i % 2 == 0) { // 如果是偶数
				sum += i;
			}
		}
		System.out.println("结果是：" + sum);
	}
}
```
## 8.9 三种循环的区别
```java
/*
三种循环的区别。

1. 如果条件判断从来没有满足过，那么for循环和while循环将会执行0次，但是do-while循环会执行至少一次。
2. for循环的变量在小括号当中定义，只有循环内部才可以使用。while循环和do-while循环初始化语句本来就在外面，所以出来循环之后还可以继续使用。
*/
public class Demo13LoopDifference {
	public static void main(String[] args) {
		for (int i = 1; i < 0; i++) {
			System.out.println("Hello");
		}
		// System.out.println(i); // 这一行是错误写法！因为变量i定义在for循环小括号内，只有for循环自己才能用。
		System.out.println("================");
		
		int i = 1;
		do {
			System.out.println("World");
			i++;
		} while (i < 0);
		// 现在已经超出了do-while循环的范围，我们仍然可以使用变量i
		System.out.println(i); // 2
	}
}
```
## 8.10 break关键字的用法
```java
/*
break关键字的用法有常见的两种：

1. 可以用在switch语句当中，一旦执行，整个switch语句立刻结束。
2. 还可以用在循环语句当中，一旦执行，整个循环语句立刻结束。打断循环。

关于循环的选择，有一个小建议：
凡是次数确定的场景多用for循环；否则多用while循环。
*/
public class Demo14Break {
	public static void main(String[] args) {
		for (int i = 1; i <= 10; i++) {
			// 如果希望从第4次开始，后续全都不要了，就要打断循环
			if (i == 4) { // 如果当前是第4次
				break; // 那么就打断整个循环
			}
			System.out.println("Hello" + i);
		}
	}
}
```
## 8.11 continue关键字
```java
/*
另一种循环控制语句是continue关键字。
一旦执行，立刻跳过当前次循环剩余内容，马上开始下一次循环。
*/
public class Demo15Continue {
	public static void main(String[] args) {
		for (int i = 1; i <= 10; i++) {
			if (i == 4) { // 如果当前是第4层
				continue; // 那么跳过当前次循环，马上开始下一次（第5层）
			}
			System.out.println(i + "层到了。");
		}
	}
}
```
## 8.12 死循环
```java
/*
永远停不下来的循环，叫做死循环。

死循环的标准格式：
while (true) {
	循环体
}
*/
public class Demo16DeadLoop {
	public static void main(String[] args) {
		while (true) {
			System.out.println("I Love Java!");
		}
		
		// System.out.println("Hello");
	}
}
```
## 8.13 嵌套循环体

```java
public class Demo17LoopHourAndMinute {
	public static void main(String[] args) {
		for (int hour = 0; hour < 24; hour++) { // 外层控制小时

			for (int minute = 0; minute < 60; minute++) { // 内层控制小时之内的分钟
				System.out.println(hour + "点" + minute + "分");
			}

		}
	}
}
```
# 第九章 方法重载
## 9.1知识点
```java

/*
对于功能类似的方法来说，因为参数列表不一样，却需要记住那么多不同的方法名称，太麻烦。

方法的重载（Overload）：多个方法的名称一样，但是参数列表不一样。
好处：只需要记住唯一一个方法名称，就可以实现类似的多个功能。

方法重载与下列因素相关：
1. 参数个数不同
2. 参数类型不同
3. 参数的多类型顺序不同

方法重载与下列因素无关：
1. 与参数的名称无关
2. 与方法的返回值类型无关
 */
public class Demo01MethodOverload {

    public static void main(String[] args) {
        /*System.out.println(sumTwo(10, 20)); // 30
        System.out.println(sumThree(10, 20, 30)); // 60
        System.out.println(sumFour(10, 20, 30, 40)); // 100*/

        System.out.println(sum(10, 20)); // 两个参数的方法
        System.out.println(sum(10, 20, 30)); // 三个参数的方法
        System.out.println(sum(10, 20, 30, 40)); // 四个参数的方法
//        System.out.println(sum(10, 20, 30, 40, 50)); // 找不到任何方法来匹配，所以错误！

        sum(10, 20);
    }

    public static int sum(int a, double b) {
        return (int) (a + b);
    }

    public static int sum(double a, int b) {
        return (int) (a + b);
    }

    public static int sum(int a, int b) {
        System.out.println("有2个参数的方法执行！");
        return a + b;
    }

    // 错误写法！与方法的返回值类型无关
//    public static double sum(int a, int b) {
//        return a + b + 0.0;
//    }

    // 错误写法！与参数的名称无关
//    public static int sum(int x, int y) {
//        return x + y;
//    }

    public static int sum(double a, double b) {
        return (int) (a + b);
    }

    public static int sum(int a, int b, int c) {
        System.out.println("有3个参数的方法执行！");
        return a + b + c;
    }

    public static int sum(int a, int b, int c, int d) {
        System.out.println("有4个参数的方法执行！");
        return a + b + c + d;
    }

}

```
### 1.比较两个数据是否相等。

```java

/*
题目要求：
比较两个数据是否相等。
参数类型分别为两个byte类型，两个short类型，两个int类型，两个long类型，
并在main方法中进行测试。
 */
public class Demo02MethodOverloadSame {

    public static void main(String[] args) {
        byte a = 10;
        byte b = 20;
        System.out.println(isSame(a, b));

        System.out.println(isSame((short) 20, (short) 20));

        System.out.println(isSame(11, 12));

        System.out.println(isSame(10L, 10L));
    }

    public static boolean isSame(byte a, byte b) {
        System.out.println("两个byte参数的方法执行！");
        boolean same;
        if (a == b) {
            same = true;
        } else {
            same = false;
        }
        return same;
    }

    public static boolean isSame(short a, short b) {
        System.out.println("两个short参数的方法执行！");
        boolean same = a == b ? true : false;
        return same;
    }

    public static boolean isSame(int a, int b) {
        System.out.println("两个int参数的方法执行！");
        return a == b;
    }

    public static boolean isSame(long a, long b) {
        System.out.println("两个long参数的方法执行！");
        if (a == b) {
            return true;
        } else {
            return false;
        }
    }

}

```
### 2. 判断哪些是正确的重载

```java
    public static void open(){} // 正确重载
    public static void open(int a){} // 正确重载
    static void open(int a,int b){} // 代码错误：和第8行冲突
    public static void open(double a,int b){} // 正确重载
    public static void open(int a,double b){} // 代码错误：和第6行冲突
    public void open(int i,double d){} // 代码错误：和第5行冲突
    public static void OPEN(){} // 代码正确不会报错，但是并不是有效重载
    public static void open(int i,int j){} // 代码错误：和第3行冲突
```
### 3. 实现重载的pri
```java
// byte short int long float double char boolean
// String
// 在调用输出语句的时候，println方法其实就是进行了多种数据类型的重载形式。
public class Demo04OverloadPrint {

    public static void main(String[] args) {
        myPrint(100); // int
        myPrint("Hello"); // String
    }

    public static void myPrint(byte num) {
        System.out.println(num);
    }

    public static void myPrint(short num) {
        System.out.println(num);
    }

    public static void myPrint(int num) {
        System.out.println(num);
    }

    public static void myPrint(long num) {
        System.out.println(num);
    }

    public static void myPrint(float num) {
        System.out.println(num);
    }

    public static void myPrint(double num) {
        System.out.println(num);
    }

    public static void myPrint(char zifu) {
        System.out.println(zifu);
    }

    public static void myPrint(boolean is) {
        System.out.println(is);
    }

    public static void myPrint(String str) {
        System.out.println(str);
    }

}
```
# 第十章 数组
## 10.1 定义与动态初始化
```java
/*
数组的概念：是一种容器，可以同时存放多个数据值。

数组的特点：
1. 数组是一种引用数据类型
2. 数组当中的多个数据，类型必须统一
3. 数组的长度在程序运行期间不可改变

数组的初始化：在内存当中创建一个数组，并且向其中赋予一些默认值。

两种常见的初始化方式：
1. 动态初始化（指定长度）
2. 静态初始化（指定内容）

动态初始化数组的格式：
数据类型[] 数组名称 = new 数据类型[数组长度];

解析含义：
左侧数据类型：也就是数组当中保存的数据，全都是统一的什么类型
左侧的中括号：代表我是一个数组
左侧数组名称：给数组取一个名字
右侧的new：代表创建数组的动作
右侧数据类型：必须和左边的数据类型保持一致
右侧中括号的长度：也就是数组当中，到底可以保存多少个数据，是一个int数字
 */
public class Demo01Array {

    public static void main(String[] args) {
        // 创建一个数组，里面可以存放300个int数据
        // 格式：数据类型[] 数组名称 = new 数据类型[数组长度];
        int[] arrayA = new int[300];

        // 创建一个数组，能存放10个double类型的数据
        double[] arrayB = new double[10];

        // 创建一个数组，能存放5个字符串
        String[] arrayC = new String[5];
    }

}

```
## 10.2 静态初始化

```java

/*
动态初始化（指定长度）：在创建数组的时候，直接指定数组当中的数据元素个数。
静态初始化（指定内容）：在创建数组的时候，不直接指定数据个数多少，而是直接将具体的数据内容进行指定。

静态初始化基本格式：
数据类型[] 数组名称 = new 数据类型[] { 元素1, 元素2, ... };

注意事项：
虽然静态初始化没有直接告诉长度，但是根据大括号里面的元素具体内容，也可以自动推算出来长度。
 */
public class Demo02Array {

    public static void main(String[] args) {
        // 直接创建一个数组，里面装的全都是int数字，具体为：5、15、25
        int[] arrayA = new int[] { 5, 15, 25, 40 };

        // 创建一个数组，用来装字符串："Hello"、"World"、"Java"
        String[] arrayB = new String[] { "Hello", "World", "Java" };
    }

}
```
## 10.3 静态动态省略格式

```java

/*
使用静态初始化数组的时候，格式还可以省略一下。

标准格式：
数据类型[] 数组名称 = new 数据类型[] { 元素1, 元素2, ... };

省略格式：
数据类型[] 数组名称 = { 元素1, 元素2, ... };

注意事项：
1. 静态初始化没有直接指定长度，但是仍然会自动推算得到长度。
2. 静态初始化标准格式可以拆分成为两个步骤。
3. 动态初始化也可以拆分成为两个步骤。
4. 静态初始化一旦使用省略格式，就不能拆分成为两个步骤了。

使用建议：
如果不确定数组当中的具体内容，用动态初始化；否则，已经确定了具体的内容，用静态初始化。
 */
public class Demo03Array {

    public static void main(String[] args) {
        // 省略格式的静态初始化
        int[] arrayA = { 10, 20, 30 };

        // 静态初始化的标准格式，可以拆分成为两个步骤
        int[] arrayB;
        arrayB = new int[] { 11, 21, 31 };

        // 动态初始化也可以拆分成为两个步骤
        int[] arrayC;
        arrayC = new int[5];

        // 静态初始化的省略格式，不能拆分成为两个步骤。
//        int[] arrayD;
//        arrayD = { 10, 20, 30 };
    }

}
```
## 10.4 静态动态初始化取值
### 静态初始化取值
```java
/*
直接打印数组名称，得到的是数组对应的：内存地址哈希值。
二进制：01
十进制：0123456789
16进制：0123456789abcdef

访问数组元素的格式：数组名称[索引值]
索引值：就是一个int数字，代表数组当中元素的编号。
【注意】索引值从0开始，一直到“数组的长度-1”为止。
 */
public class Demo04ArrayUse {

    public static void main(String[] args) {
        // 静态初始化的省略格式
        int[] array = { 10, 20, 30 };

        System.out.println(array); // [I@75412c2f

        // 直接打印数组当中的元素
        System.out.println(array[0]); // 10
        System.out.println(array[1]); // 20
        System.out.println(array[2]); // 30
        System.out.println("=============");

        // 也可以将数组当中的某一个单个元素，赋值交给变量
        int num = array[1];
        System.out.println(num); // 20
    }

}
```
### 动态初始化取值

```java
/*
使用动态初始化数组的时候，其中的元素将会自动拥有一个默认值。规则如下：
如果是整数类型，那么默认为0；
如果是浮点类型，那么默认为0.0；
如果是字符类型，那么默认为'\u0000'；
如果是布尔类型，那么默认为false；
如果是引用类型，那么默认为null。

注意事项：
静态初始化其实也有默认值的过程，只不过系统自动马上将默认值替换成为了大括号当中的具体数值。
 */
public class Demo05ArrayUse {

    public static void main(String[] args) {
        // 动态初始化一个数组
        int[] array = new int[3];

        System.out.println(array); // 内存地址值
        System.out.println(array[0]); // 0
        System.out.println(array[1]); // 0
        System.out.println(array[2]); // 0
        System.out.println("=================");

        // 将数据123赋值交给数组array当中的1号元素
        array[1] = 123;
        System.out.println(array[0]); // 0
        System.out.println(array[1]); // 123
        System.out.println(array[2]); // 0
    }

}

```
## 10.5 内存划分
### 内存主要划分5个部分
![Alt Text](/images/posts/20210109120547863.png)
### 只有一个数组的内存图
![Alt Text](/images/posts/20210109120857456.png)

```java
public class Demo01ArrayOne {

    public static void main(String[] args) {
        int[] array = new int[3]; // 动态初始化
        System.out.println(array); // 地址值
        System.out.println(array[0]); // 0
        System.out.println(array[1]); // 0
        System.out.println(array[2]); // 0
        System.out.println("==============");

        // 改变数组当中元素的内容
        array[1] = 10;
        array[2] = 20;
        System.out.println(array); // 地址值
        System.out.println(array[0]); // 0
        System.out.println(array[1]); // 10
        System.out.println(array[2]); // 20
    }
}

```

### 有两个数组的内存图
![Alt Text](/images/posts/2021010912143062.png)

```java

public class Demo02ArrayTwo {

    public static void main(String[] args) {
        int[] arrayA = new int[3];
        System.out.println(arrayA); // 地址值
        System.out.println(arrayA[0]); // 0
        System.out.println(arrayA[1]); // 0
        System.out.println(arrayA[2]); // 0
        System.out.println("==============");

        arrayA[1] = 10;
        arrayA[2] = 20;
        System.out.println(arrayA); // 地址值
        System.out.println(arrayA[0]); // 0
        System.out.println(arrayA[1]); // 10
        System.out.println(arrayA[2]); // 20
        System.out.println("==============");

        int[] arrayB = new int[3];
        System.out.println(arrayB); // 地址值
        System.out.println(arrayB[0]); // 0
        System.out.println(arrayB[1]); // 0
        System.out.println(arrayB[2]); // 0
        System.out.println("==============");

        arrayB[1] = 100;
        arrayB[2] = 200;
        System.out.println(arrayB); // 地址值
        System.out.println(arrayB[0]); // 0
        System.out.println(arrayB[1]); // 100
        System.out.println(arrayB[2]); // 200
    }

}

```
### 两个引用指向同一个数组的内存图
![Alt Text](/images/posts/20210109121818413.png)

```java

public class Demo03ArraySame {

    public static void main(String[] args) {
        int[] arrayA = new int[3];
        System.out.println(arrayA); // 地址值
        System.out.println(arrayA[0]); // 0
        System.out.println(arrayA[1]); // 0
        System.out.println(arrayA[2]); // 0
        System.out.println("==============");

        arrayA[1] = 10;
        arrayA[2] = 20;
        System.out.println(arrayA); // 地址值
        System.out.println(arrayA[0]); // 0
        System.out.println(arrayA[1]); // 10
        System.out.println(arrayA[2]); // 20
        System.out.println("==============");

        // 将arrayA数组的地址值，赋值给arrayB数组
        int[] arrayB = arrayA;
        System.out.println(arrayB); // 地址值
        System.out.println(arrayB[0]); // 0
        System.out.println(arrayB[1]); // 10
        System.out.println(arrayB[2]); // 20
        System.out.println("==============");

        arrayB[1] = 100;
        arrayB[2] = 200;
        System.out.println(arrayB); // 地址值
        System.out.println(arrayB[0]); // 0
        System.out.println(arrayB[1]); // 100
        System.out.println(arrayB[2]); // 200
    }

}
```
## 10.6 数组索引越界异常

```java

/*
数组的索引编号从0开始，一直到“数组的长度-1”为止。

如果访问数组元素的时候，索引编号并不存在，那么将会发生
数组索引越界异常
ArrayIndexOutOfBoundsException

原因：索引编号写错了。
解决：修改成为存在的正确索引编号。
 */
        public class Demo01ArrayIndex {

            public static void main(String[] args) {
                int[] array = { 15, 25, 35 };

                System.out.println(array[0]); //15
        System.out.println(array[1]); // 25
        System.out.println(array[2]); // 35

        // 错误写法
        // 并不存在3号元素，所以发生异常
        System.out.println(array[3]);
    }

}

```
## 10.7 空指针异常

```java

/*
所有的引用类型变量，都可以赋值为一个null值。但是代表其中什么都没有。

数组必须进行new初始化才能使用其中的元素。
如果只是赋值了一个null，没有进行new创建，
那么将会发生：
空指针异常 NullPointerException

原因：忘了new
解决：补上new
 */
public class Demo02ArrayNull {

    public static void main(String[] args) {
        int[] array = null;
//        array = new int[3];
        System.out.println(array[0]);
    }

}
```
## 10.8 获取数组的长度

```java

/*
如何获取数组的长度，格式：
数组名称.length

这将会得到一个int数字，代表数组的长度。

数组一旦创建，程序运行期间，长度不可改变。
 */
public class Demo03ArrayLength {

    public static void main(String[] args) {
        int[] arrayA = new int[3];

        int[] arrayB = {10, 20, 30, 3, 5, 4, 6, 7, 8, 8, 65, 4, 44, 6, 10, 3, 5, 4, 6, 7, 8, 8, 65, 4};
        int len = arrayB.length;
        System.out.println("arrayB数组的长度是：" + len);
        System.out.println("=============");

        int[] arrayC = new int[3];
        System.out.println(arrayC.length); // 3
        arrayC = new int[5];
        System.out.println(arrayC.length); // 5
    }

}

```
![Alt Text](/images/posts/20210109123040728.png)

## 10.9 数组的遍历输出

```java

/*
遍历数组，说的就是对数组当中的每一个元素进行逐一、挨个儿处理。默认的处理方式就是打印输出。
 */
public class Demo04Array {

    public static void main(String[] args) {
        int[] array = { 15, 25, 30, 40, 50, 60, 75 };

        // 首先使用原始方式
        System.out.println(array[0]); // 15
        System.out.println(array[1]); // 25
        System.out.println(array[2]); // 30
        System.out.println(array[3]); // 40
        System.out.println(array[4]); // 50
        System.out.println(array[5]); // 50
        System.out.println("=================");

        // 使用循环，次数其实就是数组的长度。
        for (int i = 0; i < 6; i++) {
            System.out.println(array[i]);
        }
        System.out.println("=================");

//        int len = array.length; // 长度
        for (int i = 0; i < array.length; i++) {
            System.out.println(array[i]);
        }
    }

}

```
### 求数组中的最大值

```java

public class Demo05ArrayMax {

    public static void main(String[] args) {
        int[] array = { 5, 15, 30, 20, 10000, 30, 35 };

        int max = array[0]; // 比武擂台
        for (int i = 1; i < array.length; i++) {
            // 如果当前元素，比max更大，则换人
            if (array[i] > max) {
                max = array[i];
            }
        }
        // 谁最后最厉害，就能在max当中留下谁的战斗力
        System.out.println("最大值：" + max);
    }
}





public class Demo06ArrayMin {

    public static void main(String[] args) {
        int[] array = { 5, 15, 30, 20, 10000, -20, 30, 35 };

        int min = array[0]; // 比武擂台
        for (int i = 1; i < array.length; i++) {
            // 如果当前元素，比min更小，则换人
            if (array[i] < min) {
                min = array[i];
            }
        }
        System.out.println("最小值：" + min);
    }

}

```
![Alt Text](/images/posts/20210109123554157.png)

### 数组元素的反转

```java

/*
数组元素的反转：
本来的样子：[1, 2, 3, 4]
之后的样子：[4, 3, 2, 1]

要求不能使用新数组，就用原来的唯一一个数组。
 */
public class Demo07ArrayReverse {

    public static void main(String[] args) {
        int[] array = { 10, 20, 30, 40, 50 };

        // 遍历打印数组本来的样子
        for (int i = 0; i < array.length; i++) {
            System.out.println(array[i]);
        }
        System.out.println("============");
        /*
        初始化语句：int min = 0, max = array.length - 1
        条件判断：min < max
        步进表达式：min++, max--
        循环体：用第三个变量倒手
         */
        for (int min = 0, max = array.length - 1; min < max; min++, max--) {
            int temp = array[min];
            array[min] = array[max];
            array[max] = temp;
        }

        // 再次打印遍历输出数组后来的样子
        for (int i = 0; i < array.length; i++) {
            System.out.println(array[i]);
        }
    }

}
```
![Alt Text](/images/posts/20210109124234397.png)

## 10.10 数组作为方法参数

```java

/*
数组可以作为方法的参数。
当调用方法的时候，向方法的小括号进行传参，传递进去的其实是数组的地址值。
 */
public class Demo01ArrayParam {

    public static void main(String[] args) {
        int[] array = { 10, 20, 30, 40, 50 };

        System.out.println(array); // 地址值

        printArray(array); // 传递进去的就是array当中保存的地址值
        System.out.println("==========AAA==========");
        printArray(array);
        System.out.println("==========BBB==========");
        printArray(array);
    }

    /*
    三要素
    返回值类型：只是进行打印而已，不需要进行计算，也没有结果，用void
    方法名称：printArray
    参数列表：必须给我数组，我才能打印其中的元素。int[] array
     */
    public static void printArray(int[] array) {
        System.out.println("printArray方法收到的参数是：");
        System.out.println(array); // 地址值
        for (int i = 0; i < array.length; i++) {
            System.out.println(array[i]);
        }
    }

}
```
## 10.11 数组作为方法返回值

```java

/*
一个方法可以有0、1、多个参数；但是只能有0或者1个返回值，不能有多个返回值。
如果希望一个方法当中产生了多个结果数据进行返回，怎么办？
解决方案：使用一个数组作为返回值类型即可。

任何数据类型都能作为方法的参数类型，或者返回值类型。

数组作为方法的参数，传递进去的其实是数组的地址值。
数组作为方法的返回值，返回的其实也是数组的地址值。
 */
public class Demo02ArrayReturn {

    public static void main(String[] args) {
        int[] result = calculate(10, 20, 30);

        System.out.println("main方法接收到的返回值数组是：");
        System.out.println(result); // 地址值

        System.out.println("总和：" + result[0]);
        System.out.println("平均数：" + result[1]);
    }

    public static int[] calculate(int a, int b, int c) {
        int sum = a + b + c; // 总和
        int avg = sum / 3; // 平均数
        // 两个结果都希望进行返回

        // 需要一个数组，也就是一个塑料兜，数组可以保存多个结果
        /*
        int[] array = new int[2];
        array[0] = sum; // 总和
        array[1] = avg; // 平均数
        */

        int[] array = { sum, avg };
        System.out.println("calculate方法内部数组是：");
        System.out.println(array); // 地址值
        return array;
    }

}

```

