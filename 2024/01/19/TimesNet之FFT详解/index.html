<!DOCTYPE html> <html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"> <head> <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /> <title>论文笔记｜【论文笔记合集】TimesNet之FFT详解 &mdash; Slience_me的博客</title> <link rel="stylesheet" href="https://blog.slienceme.cn/assets/vendor/primer-css/css/primer.css"> <link rel="stylesheet" href="https://blog.slienceme.cn/assets/css/components/collection.css"> <link rel="stylesheet" href="https://blog.slienceme.cn/assets/css/components/repo-card.css"> <link rel="stylesheet" href="https://blog.slienceme.cn/assets/css/sections/repo-list.css"> <link rel="stylesheet" href="https://blog.slienceme.cn/assets/css/components/boxed-group.css"> <link rel="stylesheet" href="https://blog.slienceme.cn/assets/css/globals/common.css"> <link rel="stylesheet" href="https://blog.slienceme.cn/assets/css/globals/responsive.css"> <link rel="stylesheet" href="https://blog.slienceme.cn/assets/css/posts/index.css"> <link rel="stylesheet" href="https://blog.slienceme.cn/assets/vendor/octicons/octicons/octicons.css"> <link rel="stylesheet" href=" https://cdn.jsdelivr.net/npm/@docsearch/css@3 "/> <link rel="stylesheet" href="https://mazhuang.org/rouge-themes/dist/github.css"> <link rel="stylesheet" href="https://blog.slienceme.cn/assets/vendor/share.js/dist/css/share.min.css"> <link rel="canonical" href="https://blog.slienceme.cn/2024/01/19/TimesNet%E4%B9%8BFFT%E8%AF%A6%E8%A7%A3/"> <link rel="alternate" type="application/atom+xml" title="Slience_me的博客" href="https://blog.slienceme.cn/feed.xml"> <link rel="shortcut icon" href="https://blog.slienceme.cn/favicon.ico"> <meta property="og:title" content="论文笔记｜【论文笔记合集】TimesNet之FFT详解"> <meta name="keywords" content="机器学习, 论文笔记"> <meta name="og:keywords" content="机器学习, 论文笔记"> <meta name="description" content=""> <meta name="og:description" content=""> <meta property="og:url" content="https://blog.slienceme.cn/2024/01/19/TimesNet%E4%B9%8BFFT%E8%AF%A6%E8%A7%A3/"> <meta property="og:site_name" content="Slience_me的博客"> <meta property="og:type" content="article"> <meta property="og:locale" content="zh_CN" /> <meta property="article:published_time" content="2024-01-19"> <meta name="google-site-verification" content="2feHjT1GNs1Yi2JQfOtdYx7d048naG_-cMwZaDAopIA" /> <script src="https://blog.slienceme.cn/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="https://blog.slienceme.cn/assets/js/main.js"></script> </head> <body class="" data-mz=""> <header class="site-header"> <div class="container"> <h1><a href="https://blog.slienceme.cn/" title="Slience_me的博客"><span class="octicon octicon-mark-github"></span> Slience_me的博客</a></h1> <button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button> <nav class="site-header-nav" role="navigation"> <a href="https://blog.slienceme.cn/" class="site-header-nav-item" target="" title="首页">首页</a> <a href="https://blog.slienceme.cn/categories/" class="site-header-nav-item" target="" title="分类">分类</a> <a href="https://blog.slienceme.cn/archives/" class="mobile-hidden site-header-nav-item" target="" title="归档">归档</a> <a href="https://blog.slienceme.cn/open-source/" class="mobile-hidden site-header-nav-item" target="" title="开源">开源</a> <a href="https://blog.slienceme.cn/fragments/" class="site-header-nav-item" target="" title="片段">片段</a> <a href="https://blog.slienceme.cn/wiki/" class="site-header-nav-item" target="" title="维基">维基</a> <a href="https://blog.slienceme.cn/links/" class="mobile-hidden site-header-nav-item" target="" title="链接">链接</a> <a href="https://blog.slienceme.cn/about/" class="site-header-nav-item" target="" title="关于">关于</a> <a class="mobile-hidden" href="https://blog.slienceme.cn/feed.xml"><span class="octicon octicon-rss" style="color:orange;"></span></a> </nav> </div> </header> <section class="collection-head small geopattern" data-pattern-id="论文笔记｜【论文笔记合集】Ti"> <div class="container"> <div class="columns"> <div class="column three-fourths"> <div class="collection-title"> <h1 class="collection-header">论文笔记｜【论文笔记合集】TimesNet之FFT详解</h1> <div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2024/01/19 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="https://blog.slienceme.cn/categories/#论文笔记" title="论文笔记">论文笔记</a> </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 6399 字，约 19 分钟 </span> </div> </div> </div> <div class="column one-fourth mobile-hidden"> <div class="collection-title"> </div> </div> </div> </div> </section> <section class="container content"> <div class="columns"> <div class="column three-fourths" > <article class="article-content markdown-body"> <p><img src="https://blog.slienceme.cn/images/posts/logo_slienceme3.png" alt="img" /></p> <p>本文作者： <a href="https://slienceme.cn/">slience_me</a></p> <hr /> <h1 id="timesnet之fft详解">TimesNet之FFT详解</h1> <p><img src="https://raw.githubusercontent.com/slience-me/picGo/master/images/image-20240119162800528.png" alt="image-20240119162800528" /></p> <h2 id="1-源代码">1. 源代码</h2> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">FFT_for_Period</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="n">xf</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="n">fft</span><span class="p">.</span><span class="n">rfft</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">frequency_list</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">xf</span><span class="p">).</span><span class="n">mean</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="n">mean</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">frequency_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">top_list</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="n">topk</span><span class="p">(</span><span class="n">frequency_list</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
    <span class="n">top_list</span> <span class="o">=</span> <span class="n">top_list</span><span class="p">.</span><span class="n">detach</span><span class="p">().</span><span class="n">cpu</span><span class="p">().</span><span class="n">numpy</span><span class="p">()</span>
    <span class="n">period</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">//</span> <span class="n">top_list</span>
    <span class="k">return</span> <span class="n">period</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">xf</span><span class="p">).</span><span class="n">mean</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)[:,</span> <span class="n">top_list</span><span class="p">]</span>
</code></pre></div></div> <h3 id="11-torchfftrfftx-dim1">1.1 torch.fft.rfft(x, dim=1)</h3> <ul> <li><strong>torch.fft.rfft()</strong></li> </ul> <p><code class="language-plaintext highlighter-rouge">torch.fft.rfft()</code> 是 PyTorch 中用于执行实数输入的快速傅里叶变换（FFT）的函数。该函数主要用于将实数输入转换为复数频谱。下面是一个详细解释和示例：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">torch</span>

<span class="c1"># 创建一个实数输入的张量
</span><span class="n">input_tensor</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="n">tensor</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">])</span>

<span class="c1"># 使用 torch.fft.rfft() 进行实数输入的快速傅里叶变换
</span><span class="n">complex_spectrum</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="n">fft</span><span class="p">.</span><span class="n">rfft</span><span class="p">(</span><span class="n">input_tensor</span><span class="p">)</span>

<span class="c1"># 打印变换后的复数频谱
</span><span class="k">print</span><span class="p">(</span><span class="s">"Complex Spectrum:"</span><span class="p">,</span> <span class="n">complex_spectrum</span><span class="p">)</span>

<span class="c1"># 获取频谱的实部和虚部
</span><span class="n">real_part</span> <span class="o">=</span> <span class="n">complex_spectrum</span><span class="p">.</span><span class="n">real</span>
<span class="n">imaginary_part</span> <span class="o">=</span> <span class="n">complex_spectrum</span><span class="p">.</span><span class="n">imag</span>

<span class="c1"># 打印实部和虚部
</span><span class="k">print</span><span class="p">(</span><span class="s">"Real Part:"</span><span class="p">,</span> <span class="n">real_part</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Imaginary Part:"</span><span class="p">,</span> <span class="n">imaginary_part</span><span class="p">)</span>
</code></pre></div></div> <p><strong>解释：</strong></p> <ol> <li>首先，我们创建一个包含实数值的 PyTorch 张量 <code class="language-plaintext highlighter-rouge">input_tensor</code>。</li> <li>然后，我们使用 <code class="language-plaintext highlighter-rouge">torch.fft.rfft()</code> 函数对该实数输入进行快速傅里叶变换，得到一个复数频谱 <code class="language-plaintext highlighter-rouge">complex_spectrum</code>。</li> <li>最后，我们打印复数频谱，并将其实部和虚部分别打印出来。</li> </ol> <p>在这个例子中，<code class="language-plaintext highlighter-rouge">torch.fft.rfft()</code> 的输出是一个包含复数的张量，其中实部包含输入信号的正半轴频谱，而虚部则包含负半轴频谱。这种变换通常用于分析信号在频域中的特性。</p> <p><strong>输出为：</strong></p> <blockquote> <p>Complex Spectrum: tensor([10.+0.j, -2.+2.j, -2.+0.j]) Real Part: tensor([10., -2., -2.]) Imaginary Part: tensor([0., 2., 0.])</p> </blockquote> <p><strong>为什么四个输入得到3个输出？</strong></p> <blockquote> <p>在傅里叶变换中，由于对称性，实数序列的傅里叶变换结果是具有一定规律的。对于长度为 <code class="language-plaintext highlighter-rouge">n</code> 的实数序列，其傅里叶变换结果的长度是 <code class="language-plaintext highlighter-rouge">n/2 + 1</code>。这是因为复数的共轭对称性，导致一半的频谱是冗余的。</p> <p>在你的例子中，输入张量的长度为4，因此傅里叶变换的输出长度是 <code class="language-plaintext highlighter-rouge">4/2 + 1 = 3</code>。</p> <p>如果你对具体的计算感兴趣，可以考虑查看傅里叶变换的相关数学理论。总体来说，这种长度减半的规律是由于信号是实数序列，而复数频谱是共轭对称的性质造成的。</p> </blockquote> <p><strong>复数的共轭对称性</strong></p> <blockquote> <p>复数的共轭对称性是指对于一个复数，它的共轭（conjugate）在复平面上关于实轴对称。对于复数 <code class="language-plaintext highlighter-rouge">a + bi</code>，其中 <code class="language-plaintext highlighter-rouge">a</code> 和 <code class="language-plaintext highlighter-rouge">b</code> 分别是实部和虚部，其共轭记为 <code class="language-plaintext highlighter-rouge">a - bi</code>。</p> <p>更具体地说，如果有复数 <code class="language-plaintext highlighter-rouge">z = a + bi</code>，那么其共轭 <code class="language-plaintext highlighter-rouge">z*</code> 是 <code class="language-plaintext highlighter-rouge">a - bi</code>。这可以用下面的图示来表示：</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code> b |   .  * (a, b)
     |   
     |   
 0 |------------------ a (实轴)
     |   
     | 
-b|   .  * (a, -b)  &lt;- 共轭对称
</code></pre></div> </div> <p>在频谱分析的上下文中，共轭对称性体现在傅里叶变换的频谱中。如果一个信号是实数序列，在频谱中正频率和负频率部分是共轭对称的。具体来说，如果某个频率分量 <code class="language-plaintext highlighter-rouge">f</code> 存在于正频率部分，那么 <code class="language-plaintext highlighter-rouge">-f</code> 就存在于负频率部分，且它们的振幅和相位是共轭关系。</p> <p>这种对称性使得在频谱中只需存储一半的信息，因为另一半可以通过共轭关系获得。这也是为什么在实数序列的傅里叶变换中，输出的长度是输入长度的一半加一。</p> </blockquote> <hr /> <ul> <li><strong>torch.fft.rfft(x, dim=1)</strong></li> </ul> <p><code class="language-plaintext highlighter-rouge">torch.fft.rfft(x, dim=1)</code> 是 PyTorch 中进行实数输入的一维快速傅里叶变换（FFT）的函数，其中 <code class="language-plaintext highlighter-rouge">dim=1</code> 指定了沿着哪个维度进行变换。</p> <p>首先，假设 <code class="language-plaintext highlighter-rouge">x</code> 是一个张量，其中包含实数序列。通常情况下，<code class="language-plaintext highlighter-rouge">x</code> 的最后一个维度（<code class="language-plaintext highlighter-rouge">dim=-1</code>）应该是实数序列的维度。例如， <code class="language-plaintext highlighter-rouge">x</code> 的形状是 <code class="language-plaintext highlighter-rouge">(batch_size, 序列长度, 通道数)</code>，那么 <code class="language-plaintext highlighter-rouge">dim=-1</code> 就是在序列长度的维度上进行傅里叶变换。</p> <p>现在，如果我们调用 <code class="language-plaintext highlighter-rouge">torch.fft.rfft(x, dim=1)</code>，它会在指定的维度上执行傅里叶变换。这就意味着对于输入张量 <code class="language-plaintext highlighter-rouge">x</code> 中的每个切片（沿着 <code class="language-plaintext highlighter-rouge">dim=1</code> 的方向），都会进行一维实数输入的快速傅里叶变换。</p> <p><strong>示例：</strong></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">torch</span>

<span class="c1"># 假设 x 的形状为 (batch_size, sequence_length)
</span><span class="n">x</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

<span class="c1"># 在序列长度的维度上进行实数输入的一维 FFT
</span><span class="n">result</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="n">fft</span><span class="p">.</span><span class="n">rfft</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># 打印结果
# (3, 4//2+1, 2)
# (3, 3, 2)
</span><span class="k">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span>
</code></pre></div></div> <p>在这个示例中，<code class="language-plaintext highlighter-rouge">x</code> 是一个形状为 <code class="language-plaintext highlighter-rouge">(3, 4)</code> 的张量，其中 <code class="language-plaintext highlighter-rouge">dim=1</code> 表示在每个序列的长度维度上执行傅里叶变换。<code class="language-plaintext highlighter-rouge">result</code> 是变换后的结果。</p> <p>需要注意的是，<code class="language-plaintext highlighter-rouge">torch.fft.rfft</code> 返回的结果是复数频谱的张量。如果需要获取实部和虚部，可以使用 <code class="language-plaintext highlighter-rouge">.real</code> 和 <code class="language-plaintext highlighter-rouge">.imag</code> 属性。</p> <p><strong>输出结果为：</strong></p> <blockquote> <p>tensor([[[-1.4285+0.0000j, 0.6463+0.0000j], [-1.8562+1.6229j, 1.0616+0.0355j], [-3.8019+0.0000j, 1.3853+0.0000j]],</p> <p>​ [[-2.6533+0.0000j, -2.2790+0.0000j], ​ [ 0.6657-0.6588j, -1.7569-1.6168j], ​ [-0.3022+0.0000j, -1.0560+0.0000j]],</p> <p>​ [[-3.9908+0.0000j, 1.0519+0.0000j], ​ [-2.7840+0.2070j, -3.1494+0.0602j], ​ [-0.4287+0.0000j, -0.7184+0.0000j]]])</p> <p>torch.Size([3, 3, 2])</p> </blockquote> <h2 id="12-frequency_list--absxfmean0mean-1">1.2 frequency_list = abs(xf).mean(0).mean(-1)</h2> <p>这一行代码涉及到对傅里叶变换结果的处理，计算频谱的平均振幅。让我们逐步解释：</p> <ol> <li><code class="language-plaintext highlighter-rouge">frequency_list = abs(xf).mean(0).mean(-1)</code>: 这一部分是对频谱进行处理： <ul> <li><code class="language-plaintext highlighter-rouge">abs(xf)</code>: 计算复数频谱的振幅，即取绝对值。</li> <li><code class="language-plaintext highlighter-rouge">.mean(0)</code>: 沿着第一个维度（即 batch_size 维度）计算平均值，得到每个样本的平均振幅。</li> <li><code class="language-plaintext highlighter-rouge">.mean(-1)</code>: 沿着最后一个维度（即频率/通道/特征维度）计算平均值，得到每个样本、每个频率的平均振幅。</li> </ul> </li> </ol> <p>最终，<code class="language-plaintext highlighter-rouge">frequency_list</code> 包含了每个频率的平均振幅。这样的处理可以用于分析信号在频域上的能量分布，因为平均振幅反映了信号中各个频率成分的相对贡献。</p> <p>举例来说，如果 <code class="language-plaintext highlighter-rouge">frequency_list</code> 的第 i 个元素表示第 i 个频率的平均振幅，那么可以通过分析这个列表来了解信号中哪些频率成分具有较大的能量。</p> <p><strong>这样的好处是什么，为什么需要求frequency_list ？</strong></p> <blockquote> <ol> <li> <p><strong>频域分析：</strong> 平均振幅提供了信号在频域上的分布信息。通过分析频率谱，你可以了解信号中各个频率成分的相对贡献。这对于理解信号的频率特征、检测特定频率的成分以及识别周期性模式都很有用。</p> </li> <li> <p><strong>能量分布：</strong> 平均振幅可以视为信号在不同频率上的能量分布。这对于识别信号中的主要频率、找到频域上的能量集中点以及确定信号的频率特征非常有帮助。</p> </li> <li> <p><strong>特征提取：</strong> 在某些应用中，频率分析可以用于提取信号的关键特征。通过计算频率谱的平均振幅，可以捕获信号中与频率相关的信息，这在一些信号处理任务中是有用的。</p> </li> <li> <p><strong>滤波和去噪：</strong> 通过频率分析，可以了解信号中的频率成分，从而进行滤波或去除噪音。对频率谱进行分析可以帮助确定哪些频率应该保留或去除，从而对信号进行处理。</p> </li> </ol> <p>总体而言，对频率谱进行分析和计算平均振幅可以提供对信号在频域上的理解，这对于很多信号处理和分析任务都是至关重要的。</p> </blockquote> <h2 id="13-frequency_list0--0">1.3 frequency_list[0] = 0</h2> <p>将 <code class="language-plaintext highlighter-rouge">frequency_list[0]</code> 置零可能是为了去除直流分量（零频率分量）的影响。在频率谱中，索引为0的位置通常对应于零频率，也就是直流成分。</p> <p>直流成分表示信号的平均值或偏移。在某些情况下，我们可能对信号的变化更感兴趣，而不是整个信号的平均值。通过将 <code class="language-plaintext highlighter-rouge">frequency_list[0]</code> 置零，我们可以去除直流成分的影响，更关注信号中的变化和其他频率成分。</p> <p>这种操作在信号处理和频谱分析中是常见的，特别是当我们关注信号的变化或周期性成分而不关心平均水平时。它有助于突出频谱中的其他特征，使得分析更加集中于信号的变动和周期性。</p> <p><strong>关于直流分量的解释</strong></p> <blockquote> <p>直流分量是信号中的恒定成分，通常表示信号的平均值或直流偏移。直流分量不随时间变化，它是信号在水平方向上的偏移或平移。</p> <p>让我们通过一个直观的例子来理解直流分量：</p> <p>假设有一个以时间为横轴的信号图，其中纵轴表示信号的振幅。如果信号在整个时间范围内都有一个常数振幅，那么这个信号就包含直流分量。直流分量的存在会使整个信号在纵轴上发生平移，即整个信号的基准水平线上下移动。</p> <p>举个例子，考虑一个表示温度的信号。如果这个信号中存在直流分量，那么它可能表示一个常数的环境温度，而信号的波动则表示温度随时间的变化。直流分量可以看作是整个信号的平均温度，而波动则反映了温度相对于平均值的变化。</p> <p>在频谱分析中，直流分量通常对应于频谱中的零频率分量，即索引为0的位置。通过将直流分量从频谱中去除，我们可以更专注于信号中变化的频率成分，而不受整体平移的影响。这在很多信号处理任务中是有用的，特别是当我们关注信号的变动和周期性成分时。</p> </blockquote> <h2 id="14-_-top_list--torchtopkfrequency_list-k">1.4 _, top_list = torch.topk(frequency_list, k)</h2> <p><code class="language-plaintext highlighter-rouge">torch.topk</code> 是 PyTorch 中用于获取张量中最大的 k 个元素的函数。frequency_list<code class="language-plaintext highlighter-rouge"> 是一个包含频率振幅的张量，而 </code>_<code class="language-plaintext highlighter-rouge"> 和 </code>top_list` 是函数的返回结果。</p> <p>让我们逐步解释这行代码：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">_</span><span class="p">,</span> <span class="n">top_list</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="n">topk</span><span class="p">(</span><span class="n">frequency_list</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
</code></pre></div></div> <ul> <li> <p><code class="language-plaintext highlighter-rouge">torch.topk</code>: 这个函数用于获取张量中最大的 k 个元素。它返回两个张量，第一个是最大值的值（在这里我们用 <code class="language-plaintext highlighter-rouge">_</code> 表示忽略，因为我们不使用这个值），第二个是最大值对应的索引。</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">frequency_list</code>: 这是包含频率振幅的张量，其中每个元素表示某个频率的平均振幅。</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">k</code>: 这是要获取的最大元素的数量。</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">_, top_list</code>: 这是用来接收 <code class="language-plaintext highlighter-rouge">torch.topk</code> 函数的返回结果。<code class="language-plaintext highlighter-rouge">_</code> 用于忽略最大值的值，而 <code class="language-plaintext highlighter-rouge">top_list</code> 包含最大值对应的索引。</p> </li> </ul> <p>总体而言，这行代码的目的是从 <code class="language-plaintext highlighter-rouge">frequency_list</code> 中找到最大的 k 个频率振幅，并获取这些最大值对应的索引。这可以用于找到信号中主要的频率成分。如果 <code class="language-plaintext highlighter-rouge">top_list</code> 包含的是频率的索引，你可以通过这些索引查找对应的频率值。</p> <p><strong>举例：</strong></p> <p>假设我们有一个包含频率振幅的张量 <code class="language-plaintext highlighter-rouge">frequency_list</code>，内容如下：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">torch</span>

<span class="n">frequency_list</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="n">tensor</span><span class="p">([</span><span class="mf">5.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">8.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">])</span>
</code></pre></div></div> <p>现在，我们想找到最大的两个频率振幅对应的索引。我们可以使用 <code class="language-plaintext highlighter-rouge">torch.topk</code> 函数来实现：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">k</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">_</span><span class="p">,</span> <span class="n">top_list</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="n">topk</span><span class="p">(</span><span class="n">frequency_list</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="s">"Top k frequencies indices:"</span><span class="p">,</span> <span class="n">top_list</span><span class="p">)</span>
</code></pre></div></div> <p>输出是：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Top k frequencies indices: tensor([2, 0])
</code></pre></div></div> <p>这表示在 <code class="language-plaintext highlighter-rouge">frequency_list</code> 中，最大的两个频率振幅对应的索引分别是2和0。也就是说，频率振幅最大的是索引为2的元素（8.0），其次是索引为0的元素（5.0）。</p> <h2 id="15-top_list--top_listdetachcpunumpy">1.5 top_list = top_list.detach().cpu().numpy()</h2> <p>这行代码对 <code class="language-plaintext highlighter-rouge">top_list</code> 进行了一系列操作，将其从 PyTorch 的张量类型转换为 NumPy 数组。让我们逐步解释这些操作：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">top_list</span> <span class="o">=</span> <span class="n">top_list</span><span class="p">.</span><span class="n">detach</span><span class="p">().</span><span class="n">cpu</span><span class="p">().</span><span class="n">numpy</span><span class="p">()</span>
</code></pre></div></div> <ul> <li> <p><code class="language-plaintext highlighter-rouge">top_list.detach()</code>: <code class="language-plaintext highlighter-rouge">detach()</code> 方法用于创建一个没有梯度信息的张量副本。在 PyTorch 中，张量的梯度信息通常用于自动微分。<code class="language-plaintext highlighter-rouge">detach()</code> 可以用于生成新的张量，该张量与原始张量共享数据，但没有梯度信息。</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">.cpu()</code>: 如果张量存储在 GPU 上，<code class="language-plaintext highlighter-rouge">cpu()</code> 方法用于将其移到 CPU 上。在这里，这一步可能是为了确保张量在 CPU 上，以便进行 NumPy 转换。</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">.numpy()</code>: <code class="language-plaintext highlighter-rouge">numpy()</code> 方法用于将 PyTorch 张量转换为 NumPy 数组。这是因为 PyTorch 和 NumPy 是两个不同的库，有时需要在它们之间进行数据转换。</p> </li> </ul> <p>综合这些步骤，<code class="language-plaintext highlighter-rouge">top_list</code> 最终被转换为一个不带梯度信息的 CPU 上的 NumPy 数组。这样的转换通常是为了在 PyTorch 和 NumPy 之间进行数据交互，因为它们在许多方面具有互操作性。 NumPy 数组是 Python 中广泛使用的数据结构，可以用于进行各种科学计算和数据分析任务。</p> <h2 id="16-period--xshape1--top_list">1.6 period = x.shape[1] // top_list</h2> <p>这行代码计算了一个名为 <code class="language-plaintext highlighter-rouge">period</code> 的值，它是 <code class="language-plaintext highlighter-rouge">x</code> 张量的第二个维度（即序列长度）除以 <code class="language-plaintext highlighter-rouge">top_list</code> 中每个元素的值。这通常是用于计算信号中特定频率成分的周期。</p> <p>让我们分解这行代码：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">period</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">//</span> <span class="n">top_list</span>
</code></pre></div></div> <ul> <li> <p><code class="language-plaintext highlighter-rouge">x.shape[1]</code>: 这是张量 <code class="language-plaintext highlighter-rouge">x</code> 的第二个维度的长度，即序列长度。在这个上下文中，我们假设 <code class="language-plaintext highlighter-rouge">x</code> 的形状是 <code class="language-plaintext highlighter-rouge">(batch_size, sequence_length)</code>。</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">top_list</code>: 这是包含最大频率振幅的索引的列表。每个索引对应于在 <code class="language-plaintext highlighter-rouge">x</code> 中找到的重要频率。</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">//</code>: 这是整数除法运算符，返回除法的整数部分。在这里，它用于计算 <code class="language-plaintext highlighter-rouge">x.shape[1]</code> 除以 <code class="language-plaintext highlighter-rouge">top_list</code> 中的每个元素。</p> </li> </ul> <p>最终，<code class="language-plaintext highlighter-rouge">period</code> 将包含每个最大频率对应的周期。例如，如果 <code class="language-plaintext highlighter-rouge">top_list</code> 中的某个元素是2，那么 <code class="language-plaintext highlighter-rouge">period</code> 中对应的值将是 <code class="language-plaintext highlighter-rouge">x</code> 中的信号在该频率上的周期长度。这样的计算可以用于分析信号的周期性成分。</p> <h2 id="17-return-period-absxfmean-1-top_list">1.7 return period, abs(xf).mean(-1)[:, top_list]</h2> <p>这行代码包含了一个返回语句，返回两个值：<code class="language-plaintext highlighter-rouge">period</code> 和一个部分截取的频谱信息。让我们逐步解释这行代码：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">return</span> <span class="n">period</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">xf</span><span class="p">).</span><span class="n">mean</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)[:,</span> <span class="n">top_list</span><span class="p">]</span>
</code></pre></div></div> <ol> <li> <p><code class="language-plaintext highlighter-rouge">period</code>: 这是之前计算的周期，表示信号中每个最大频率成分的周期长度。</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">abs(xf).mean(-1)[:, top_list]</code>：</p> <ul> <li><code class="language-plaintext highlighter-rouge">abs(xf)</code>: 先取复数频谱的振幅，即绝对值。这表示我们对频谱的振幅部分感兴趣。</li> <li><code class="language-plaintext highlighter-rouge">.mean(-1)</code>: 沿着最后一个维度（通常是频率维度）计算平均值，得到每个样本、每个频率的平均振幅。这部分可以看作是对整个频谱的平均振幅信息。</li> <li><code class="language-plaintext highlighter-rouge">[:, top_list]</code>: 通过索引 <code class="language-plaintext highlighter-rouge">top_list</code>，选择仅包含最大频率成分的部分。</li> </ul> </li> </ol> <p>综合起来，这行代码返回了信号中每个最大频率成分的周期长度以及相应频率成分的平均振幅信息。这样的返回结果可能用于进一步分析信号中不同频率的周期性成分及其振幅特征。</p> <div style="margin-top:2em;padding:0 1.5em;border:1px solid #d3d3d3;background-color:#deebf7"> <h3>文档信息</h3> <ul> <li>本文作者：<a href="https://blog.slienceme.cn" target="_blank">slience_me</a></li> <li>本文链接：<a href="https://blog.slienceme.cn/2024/01/19/TimesNet%E4%B9%8BFFT%E8%AF%A6%E8%A7%A3/" target="_blank">https://blog.slienceme.cn/2024/01/19/TimesNet%E4%B9%8BFFT%E8%AF%A6%E8%A7%A3/</a></li> <li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank">创意共享3.0许可证</a>）</li> </ul> </div> </article> <div class="share"> <div class="share-component" data-disabled='qq,facebook'></div> </div> <div class="comment"> <script src="https://giscus.app/client.js" data-repo="slience-me/blog-comments" data-repo-id="R_kgDOKr27jA" data-category="Announcements" data-category-id="DIC_kwDOKr27jM4CnWMe" data-mapping="title" data-strict="1" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="light" data-lang="zh-CN" data-loading="lazy" crossorigin="anonymous" async> </script> </div> </div> <div class="column one-fourth"> <h3>Search</h3> <div id="site_search"> <div id="docsearch"> <input style="width:96%" type="text" id="search_box" placeholder="Search"> </div> </div> <script src="https://cdn.jsdelivr.net/npm/@docsearch/js@3"></script> <script type="text/javascript"> docsearch({ appId: "8W5T6R2WWG", apiKey: "e56e511c7c9f85e2c97e2817664aafb2", indexName: "doc", container: "#docsearch" }); </script> <h3 class="post-directory-title mobile-hidden">Table of Contents</h3> <div id="post-directory-module" class="mobile-hidden"> <section class="post-directory"> <dl></dl> </section> </div> <script src="https://blog.slienceme.cn/assets/js/jquery.toc.js"></script> </div> </div> </section> <footer class="container"> <div class="site-footer" role="contentinfo"> <div class="copyright left mobile-block"> <img src="/images/logo/logo.png" class="w-full" style="height: 10px;width: 10px;" alt="logo" />;"> <a href="https://beian.mps.gov.cn/#/query/webSearch?code=13102202000626" rel="noreferrer" target="_blank">冀公网安备13102202000626</a> | <a href="https://beian.miit.gov.cn/#/Integrated/index" target="_blank" rel="noreferrer">津ICP备2024026565号-1</a> Copyright © 2019-present slience_me&emsp; <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a> </div> <ul class="site-footer-links right mobile-hidden"> <li> <a href="javascript:window.scrollTo(0,0)" >TOP</a> </li> </ul> <br/> <script defer src="https://vercount.one/js"></script> <div class="mobile-hidden" style="margin-top:8px"> <span id="busuanzi_container_site_pv" style="display:none"> 本站访问量<span id="busuanzi_value_site_pv"></span>次 </span> <span id="busuanzi_container_site_uv" style="display:none"> / 本站访客数<span id="busuanzi_value_site_uv"></span>人 </span> <span id="busuanzi_container_page_pv" style="display:none"> / 本页访问量<span id="busuanzi_value_page_pv"></span>次 / 统计始于2024-12-01 </span> </div> </div> </footer> <div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a> </div> <script src="https://blog.slienceme.cn/assets/vendor/share.js/dist/js/share.min.js"></script> <script src="https://blog.slienceme.cn/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function($) { $('.geopattern').each(function(){ $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script> </body> </html>
