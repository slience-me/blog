<!DOCTYPE html> <html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"> <head> <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /> <title>Java｜Java语言高级（第三部分）异常多线程 &mdash; Slience_me的博客</title> <link rel="stylesheet" href="https://blog.slienceme.cn/assets/vendor/primer-css/css/primer.css"> <link rel="stylesheet" href="https://blog.slienceme.cn/assets/css/components/collection.css"> <link rel="stylesheet" href="https://blog.slienceme.cn/assets/css/components/repo-card.css"> <link rel="stylesheet" href="https://blog.slienceme.cn/assets/css/sections/repo-list.css"> <link rel="stylesheet" href="https://blog.slienceme.cn/assets/css/components/boxed-group.css"> <link rel="stylesheet" href="https://blog.slienceme.cn/assets/css/globals/common.css"> <link rel="stylesheet" href="https://blog.slienceme.cn/assets/css/globals/responsive.css"> <link rel="stylesheet" href="https://blog.slienceme.cn/assets/css/posts/index.css"> <link rel="stylesheet" href="https://blog.slienceme.cn/assets/vendor/octicons/octicons/octicons.css"> <link rel="stylesheet" href="https://mazhuang.org/rouge-themes/dist/github.css"> <link rel="stylesheet" href="https://blog.slienceme.cn/assets/vendor/share.js/dist/css/share.min.css"> <link rel="canonical" href="https://blog.slienceme.cn/2021/01/26/Java%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7-%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86-%E5%BC%82%E5%B8%B8%E5%A4%9A%E7%BA%BF%E7%A8%8B/"> <link rel="alternate" type="application/atom+xml" title="Slience_me的博客" href="https://blog.slienceme.cn/feed.xml"> <link rel="shortcut icon" href="https://blog.slienceme.cn/favicon.ico"> <meta property="og:title" content="Java｜Java语言高级（第三部分）异常多线程"> <meta name="keywords" content="编程语言, Java"> <meta name="og:keywords" content="编程语言, Java"> <meta name="description" content=""> <meta name="og:description" content=""> <meta property="og:url" content="https://blog.slienceme.cn/2021/01/26/Java%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7-%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86-%E5%BC%82%E5%B8%B8%E5%A4%9A%E7%BA%BF%E7%A8%8B/"> <meta property="og:site_name" content="Slience_me的博客"> <meta property="og:type" content="article"> <meta property="og:locale" content="zh_CN" /> <meta property="article:published_time" content="2021-01-26"> <meta name="google-site-verification" content="2feHjT1GNs1Yi2JQfOtdYx7d048naG_-cMwZaDAopIA" /> <script src="https://blog.slienceme.cn/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="https://blog.slienceme.cn/assets/js/main.js"></script> </head> <body class="" data-mz=""> <header class="site-header"> <div class="container"> <h1><a href="https://blog.slienceme.cn/" title="Slience_me的博客"><span class="octicon octicon-mark-github"></span> Slience_me的博客</a></h1> <button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button> <nav class="site-header-nav" role="navigation"> <a href="https://blog.slienceme.cn/" class="site-header-nav-item" target="" title="首页">首页</a> <a href="https://blog.slienceme.cn/categories/" class="site-header-nav-item" target="" title="分类">分类</a> <a href="https://blog.slienceme.cn/archives/" class="mobile-hidden site-header-nav-item" target="" title="归档">归档</a> <a href="https://blog.slienceme.cn/open-source/" class="mobile-hidden site-header-nav-item" target="" title="开源">开源</a> <a href="https://blog.slienceme.cn/fragments/" class="site-header-nav-item" target="" title="片段">片段</a> <a href="https://blog.slienceme.cn/wiki/" class="site-header-nav-item" target="" title="维基">维基</a> <a href="https://blog.slienceme.cn/links/" class="mobile-hidden site-header-nav-item" target="" title="链接">链接</a> <a href="https://blog.slienceme.cn/about/" class="site-header-nav-item" target="" title="关于">关于</a> <a class="mobile-hidden" href="https://blog.slienceme.cn/feed.xml"><span class="octicon octicon-rss" style="color:orange;"></span></a> </nav> </div> </header> <section class="collection-head small geopattern" data-pattern-id="Java｜Java语言高级（第"> <div class="container"> <div class="columns"> <div class="column three-fourths"> <div class="collection-title"> <h1 class="collection-header">Java｜Java语言高级（第三部分）异常多线程</h1> <div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2021/01/26 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="https://blog.slienceme.cn/categories/#Java" title="Java">Java</a> </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 62242 字，约 178 分钟 </span> </div> </div> </div> <div class="column one-fourth mobile-hidden"> <div class="collection-title"> </div> </div> </div> </div> </section> <section class="container content"> <div class="columns"> <div class="column three-fourths" > <article class="article-content markdown-body"> <p><img src="https://blog.slienceme.cn/images/posts/logo_slienceme3.png" alt="img" /></p> <p>本文作者： <a href="https://slienceme.cn/">slience_me</a></p> <hr /> <h1 id="java语言高级第三部分异常多线程">Java语言高级（第三部分）异常多线程</h1> <h1 id="第五章-异常与多线程">第五章 异常与多线程</h1> <h2 id="1-异常">1. 异常</h2> <h3 id="11-异常概念">1.1 异常概念</h3> <p>异常，就是不正常的意思。在生活中:医生说,你的身体某个部位有异常,该部位和正常相比有点不同,该部位的功能将受影响.在程序中的意思就是：</p> <ul> <li><strong>异常</strong> ：指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止。</li> </ul> <p>在Java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象。Java处理异常的方式是中断处理。</p> <blockquote> <p>异常指的并不是语法错误,语法错了,编译不通过,不会产生字节码文件,根本不能运行.</p> </blockquote> <h3 id="12-异常体系">1.2 异常体系</h3> <p>异常机制其实是帮助我们<strong>找到</strong>程序中的问题，异常的根类是<code class="language-plaintext highlighter-rouge">java.lang.Throwable</code>，其下有两个子类：<code class="language-plaintext highlighter-rouge">java.lang.Error</code>与<code class="language-plaintext highlighter-rouge">java.lang.Exception</code>，平常所说的异常指<code class="language-plaintext highlighter-rouge">java.lang.Exception</code>。</p> <p><img src="https://blog.slienceme.cn/images/posts/2021012609475828.png" alt="Alt Text" /></p> <p><strong>Throwable体系：</strong></p> <ul> <li><strong>Error</strong>:严重错误Error，无法通过处理的错误，只能事先避免，好比绝症。</li> <li><strong>Exception</strong>:表示异常，异常产生后程序员可以通过代码的方式纠正，使程序继续运行，是必须要处理的。好比感冒、阑尾炎。</li> </ul> <p><strong>Throwable中的常用方法：</strong></p> <ul> <li> <p><code class="language-plaintext highlighter-rouge">public void printStackTrace()</code>:打印异常的详细信息。</p> <p><em>包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。</em></p> </li> <li> <p><code class="language-plaintext highlighter-rouge">public String getMessage()</code>:获取发生异常的原因。</p> <p><em>提示给用户的时候,就提示错误原因。</em></p> </li> <li> <p><code class="language-plaintext highlighter-rouge">public String toString()</code>:获取异常的类型和异常描述信息(不用)。</p> </li> </ul> <p><strong><em>出现异常,不要紧张,把异常的简单类名,拷贝到API中去查。</em></strong></p> <p><img src="https://blog.slienceme.cn/images/posts/20210126094841261.bmp.jpg" alt="Alt Text" /></p> <h3 id="13-异常分类">1.3 异常分类</h3> <p>我们平常说的异常就是指Exception，因为这类异常一旦出现，我们就要对代码进行更正，修复程序。</p> <p><strong>异常(Exception)的分类</strong>:根据在编译时期还是运行时期去检查异常?</p> <ul> <li><strong>编译时期异常</strong>:checked异常。在编译时期,就会检查,如果没有处理异常,则编译失败。(如日期格式化异常)</li> <li><strong>运行时期异常</strong>:runtime异常。在运行时期,检查异常.在编译时期,运行异常不会编译器检测(不报错)。(如数学异常)</li> </ul> <p><img src="https://blog.slienceme.cn/images/posts/20210126094908160.png" alt="Alt Text" /></p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
    java.lang.Throwable:类是 Java 语言中所有错误或异常的超类。
        Exception:编译期异常,进行编译(写代码)java程序出现的问题
            RuntimeException:运行期异常,java程序运行过程中出现的问题
            异常就相当于程序得了一个小毛病(感冒,发烧),把异常处理掉,程序可以继续执行(吃点药,继续革命工作)
        Error:错误
            错误就相当于程序得了一个无法治愈的毛病(非典,艾滋).必须修改源代码,程序才能继续执行
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo01Exception</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="cm">/*throws ParseException*/</span> <span class="o">{</span>
        <span class="c1">//Exception:编译期异常,进行编译(写代码)java程序出现的问题</span>
        <span class="cm">/*SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");//用来格式化日期
        Date date = null;
        try {
            date = sdf.parse("1999-0909");//把字符串格式的日期,解析为Date格式的日期
        } catch (ParseException e) {
            e.printStackTrace();
        }
        System.out.println(date);*/</span>

        <span class="c1">//RuntimeException:运行期异常,java程序运行过程中出现的问题</span>
        <span class="cm">/*int[] arr = {1,2,3};
        //System.out.println(arr[0]);
        try {
            //可能会出现异常的代码
            System.out.println(arr[3]);
        }catch(Exception e){
            //异常的处理逻辑
            System.out.println(e);
        }*/</span>

        <span class="cm">/*
            Error:错误
            OutOfMemoryError: Java heap space
            内存溢出的错误,创建的数组太大了,超出了给JVM分配的内存
         */</span>
        <span class="c1">//int[] arr = new int[1024*1024*1024];</span>
        <span class="c1">//必须修改代码,创建的数组小一点</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="o">];</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"后续代码"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h3 id="14-----异常的产生过程解析">1.4 异常的产生过程解析</h3> <p>先运行下面的程序，程序会产生一个数组索引越界异常ArrayIndexOfBoundsException。我们通过图解来解析下异常产生的过程。</p> <p>工具类</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ArrayTools</span> <span class="o">{</span>
    <span class="c1">// 对给定的数组通过给定的角标获取元素。</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">getElement</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">,</span> <span class="kt">int</span> <span class="n">index</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">element</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">index</span><span class="o">];</span>
        <span class="k">return</span> <span class="n">element</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>测试类</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ExceptionDemo</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="o">{</span> <span class="mi">34</span><span class="o">,</span> <span class="mi">12</span><span class="o">,</span> <span class="mi">67</span> <span class="o">};</span>
        <span class="n">intnum</span> <span class="o">=</span> <span class="nc">ArrayTools</span><span class="o">.</span><span class="na">getElement</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"num="</span> <span class="o">+</span> <span class="n">num</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"over"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>上述程序执行过程图解：</p> <p><img src="https://blog.slienceme.cn/images/posts/20210126094953681.png" alt="Alt Text" /></p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
    异常的产生过程解析(分析异常的怎么产生的,如何处理异常)
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo02Exception</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//创建int类型的数组,并赋值</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">e</span> <span class="o">=</span> <span class="n">getElement</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span><span class="mi">3</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="cm">/*
        定义一个方法,获取数组指定索引处的元素
        参数:
            int[] arr
            int index
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">getElement</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">,</span><span class="kt">int</span> <span class="n">index</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">ele</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">index</span><span class="o">];</span>
        <span class="k">return</span> <span class="n">ele</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h2 id="2-异常的处理">2. 异常的处理</h2> <p>Java异常处理的五个关键字：<strong>try、catch、finally、throw、throws</strong></p> <h3 id="21--抛出异常throw">2.1 抛出异常throw</h3> <p>在编写程序时，我们必须要考虑程序出现问题的情况。比如，在定义方法时，方法需要接受参数。那么，当调用方法使用接受到的参数时，首先需要先对参数数据进行合法的判断，数据若不合法，就应该告诉调用者，传递合法的数据进来。这时需要使用抛出异常的方式来告诉调用者。</p> <p>在java中，提供了一个<strong>throw</strong>关键字，它用来抛出一个指定的异常对象。那么，抛出一个异常具体如何操作呢？</p> <ol> <li> <p>创建一个异常对象。封装一些提示信息(信息可以自己编写)。</p> </li> <li> <p>需要将这个异常对象告知给调用者。怎么告知呢？怎么将这个异常对象传递到调用者处呢？通过关键字throw就可以完成。throw 异常对象。</p> <p>throw<strong>用在方法内</strong>，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。</p> </li> </ol> <p><strong>使用格式：</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>throw new 异常类名(参数);
</code></pre></div></div> <p>例如：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">throw</span> <span class="k">new</span> <span class="nc">NullPointerException</span><span class="o">(</span><span class="s">"要访问的arr数组不存在"</span><span class="o">);</span>

<span class="k">throw</span> <span class="k">new</span> <span class="nf">ArrayIndexOutOfBoundsException</span><span class="o">(</span><span class="s">"该索引在数组中不存在，已超出范围"</span><span class="o">);</span>
</code></pre></div></div> <p>学习完抛出异常的格式后，我们通过下面程序演示下throw的使用。</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ThrowDemo</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//创建一个数组 </span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">52</span><span class="o">,</span><span class="mi">2</span><span class="o">};</span>
        <span class="c1">//根据索引找对应的元素 </span>
        <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">4</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">element</span> <span class="o">=</span> <span class="n">getElement</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="n">index</span><span class="o">);</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">element</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"over"</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="cm">/*
     * 根据 索引找到数组中对应的元素
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">getElement</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">,</span><span class="kt">int</span> <span class="n">index</span><span class="o">){</span> 
       	<span class="c1">//判断  索引是否越界</span>
        <span class="k">if</span><span class="o">(</span><span class="n">index</span><span class="o">&lt;</span><span class="mi">0</span> <span class="o">||</span> <span class="n">index</span><span class="o">&gt;</span><span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">){</span>
             <span class="cm">/*
             判断条件如果满足，当执行完throw抛出异常对象后，方法已经无法继续运算。
             这时就会结束当前方法的执行，并将异常告知给调用者。这时就需要通过异常来解决。 
              */</span>
             <span class="k">throw</span> <span class="k">new</span> <span class="nf">ArrayIndexOutOfBoundsException</span><span class="o">(</span><span class="s">"哥们，角标越界了~~~"</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="kt">int</span> <span class="n">element</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">index</span><span class="o">];</span>
        <span class="k">return</span> <span class="n">element</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <blockquote> <p>注意：如果产生了问题，我们就会throw将问题描述类即异常进行抛出，也就是将问题返回给该方法的调用者。</p> <p>那么对于调用者来说，该怎么处理呢？一种是进行捕获处理，另一种就是继续讲问题声明出去，使用throws声明处理。</p> </blockquote> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
    throw关键字
    作用:
        可以使用throw关键字在指定的方法中抛出指定的异常
    使用格式:
        throw new xxxException("异常产生的原因");
    注意:
        1.throw关键字必须写在方法的内部
        2.throw关键字后边new的对象必须是Exception或者Exception的子类对象
        3.throw关键字抛出指定的异常对象,我们就必须处理这个异常对象
            throw关键字后边创建的是RuntimeException或者是 RuntimeException的子类对象,我们可以不处理,默认交给JVM处理(打印异常对象,中断程序)
            throw关键字后边创建的是编译异常(写代码的时候报错),我们就必须处理这个异常,要么throws,要么try...catch
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo03Throw</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//int[] arr = null;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">3</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">e</span> <span class="o">=</span> <span class="n">getElement</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span><span class="mi">3</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="cm">/*
        定义一个方法,获取数组指定索引处的元素
        参数:
            int[] arr
            int index
        以后(工作中)我们首先必须对方法传递过来的参数进行合法性校验
        如果参数不合法,那么我们就必须使用抛出异常的方式,告知方法的调用者,传递的参数有问题
        注意:
            NullPointerException是一个运行期异常,我们不用处理,默认交给JVM处理
            ArrayIndexOutOfBoundsException是一个运行期异常,我们不用处理,默认交给JVM处理
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">getElement</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">,</span><span class="kt">int</span> <span class="n">index</span><span class="o">){</span>
        <span class="cm">/*
            我们可以对传递过来的参数数组,进行合法性校验
            如果数组arr的值是null
            那么我们就抛出空指针异常,告知方法的调用者"传递的数组的值是null"
         */</span>
        <span class="k">if</span><span class="o">(</span><span class="n">arr</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">NullPointerException</span><span class="o">(</span><span class="s">"传递的数组的值是null"</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="cm">/*
            我们可以对传递过来的参数index进行合法性校验
            如果index的范围不在数组的索引范围内
            那么我们就抛出数组索引越界异常,告知方法的调用者"传递的索引超出了数组的使用范围"
         */</span>
        <span class="k">if</span><span class="o">(</span><span class="n">index</span><span class="o">&lt;</span><span class="mi">0</span> <span class="o">||</span> <span class="n">index</span><span class="o">&gt;</span><span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">){</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">ArrayIndexOutOfBoundsException</span><span class="o">(</span><span class="s">"传递的索引超出了数组的使用范围"</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="kt">int</span> <span class="n">ele</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">index</span><span class="o">];</span>
        <span class="k">return</span> <span class="n">ele</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h3 id="22-objects非空判断">2.2 Objects非空判断</h3> <p>还记得我们学习过一个类Objects吗，曾经提到过它由一些静态的实用方法组成，这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的），那么在它的源码中，对对象为null的值进行了抛出异常操作。</p> <ul> <li><code class="language-plaintext highlighter-rouge">public static &lt;T&gt; T requireNonNull(T obj)</code>:查看指定引用对象不是null。</li> </ul> <p>查看源码发现这里对为null的进行了抛出异常操作：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="no">T</span> <span class="nf">requireNonNull</span><span class="o">(</span><span class="no">T</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">obj</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
      	<span class="k">throw</span> <span class="k">new</span> <span class="nf">NullPointerException</span><span class="o">();</span>
    <span class="k">return</span> <span class="n">obj</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.Objects</span><span class="o">;</span>

<span class="cm">/*
    Obects类中的静态方法
    public static &lt;T&gt; T requireNonNull(T obj):查看指定引用对象不是null。
    源码:
        public static &lt;T&gt; T requireNonNull(T obj) {
            if (obj == null)
                throw new NullPointerException();
            return obj;
        }
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo04Objects</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">method</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">method</span><span class="o">(</span><span class="nc">Object</span> <span class="n">obj</span><span class="o">){</span>
        <span class="c1">//对传递过来的参数进行合法性判断,判断是否为null</span>
        <span class="cm">/*if(obj == null){
            throw new NullPointerException("传递的对象的值是null");
        }*/</span>

        <span class="c1">//Objects.requireNonNull(obj);</span>
        <span class="nc">Objects</span><span class="o">.</span><span class="na">requireNonNull</span><span class="o">(</span><span class="n">obj</span><span class="o">,</span><span class="s">"传递的对象的值是null"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h3 id="23--声明异常throws">2.3 声明异常throws</h3> <p><strong>声明异常</strong>：将问题标识出来，报告给调用者。如果方法内通过throw抛出了编译时异常，而没有捕获处理（稍后讲解该方式），那么必须通过throws进行声明，让调用者去处理。</p> <p>关键字<strong>throws</strong>运用于方法声明之上,用于表示当前方法不处理异常,而是提醒该方法的调用者来处理异常(抛出异常).</p> <p><strong>声明异常格式：</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>修饰符 返回值类型 方法名(参数) throws 异常类名1,异常类名2…{   }	
</code></pre></div></div> <p>声明异常的代码演示：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ThrowsDemo</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">FileNotFoundException</span> <span class="o">{</span>
        <span class="n">read</span><span class="o">(</span><span class="s">"a.txt"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// 如果定义功能时有问题发生需要报告给调用者。可以通过在方法上使用throws关键字进行声明</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">read</span><span class="o">(</span><span class="nc">String</span> <span class="n">path</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">FileNotFoundException</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">path</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">"a.txt"</span><span class="o">))</span> <span class="o">{</span><span class="c1">//如果不是 a.txt这个文件 </span>
            <span class="c1">// 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">FileNotFoundException</span><span class="o">(</span><span class="s">"文件不存在"</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>throws用于进行异常类的声明，若该方法可能有多种异常情况产生，那么在throws后面可以写多个异常类，用逗号隔开。</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ThrowsDemo2</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="n">read</span><span class="o">(</span><span class="s">"a.txt"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">read</span><span class="o">(</span><span class="nc">String</span> <span class="n">path</span><span class="o">)</span><span class="kd">throws</span> <span class="nc">FileNotFoundException</span><span class="o">,</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">path</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">"a.txt"</span><span class="o">))</span> <span class="o">{</span><span class="c1">//如果不是 a.txt这个文件 </span>
            <span class="c1">// 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">FileNotFoundException</span><span class="o">(</span><span class="s">"文件不存在"</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">path</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">"b.txt"</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IOException</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.io.FileNotFoundException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>

<span class="cm">/*
    throws关键字:异常处理的第一种方式,交给别人处理
    作用:
        当方法内部抛出异常对象的时候,那么我们就必须处理这个异常对象
        可以使用throws关键字处理异常对象,会把异常对象声明抛出给方法的调用者处理(自己不处理,给别人处理),最终交给JVM处理--&gt;中断处理
    使用格式:在方法声明时使用
        修饰符 返回值类型 方法名(参数列表) throws AAAExcepiton,BBBExcepiton...{
            throw new AAAExcepiton("产生原因");
            throw new BBBExcepiton("产生原因");
            ...
        }
     注意:
        1.throws关键字必须写在方法声明处
        2.throws关键字后边声明的异常必须是Exception或者是Exception的子类
        3.方法内部如果抛出了多个异常对象,那么throws后边必须也声明多个异常
            如果抛出的多个异常对象有子父类关系,那么直接声明父类异常即可
        4.调用了一个声明抛出异常的方法,我们就必须的处理声明的异常
            要么继续使用throws声明抛出,交给方法的调用者处理,最终交给JVM
            要么try...catch自己处理异常
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo05Throws</span> <span class="o">{</span>
    <span class="cm">/*
        FileNotFoundException extends IOException extends Excepiton
        如果抛出的多个异常对象有子父类关系,那么直接声明父类异常即可
     */</span>
    <span class="c1">//public static void main(String[] args) throws FileNotFoundException,IOException {</span>
    <span class="c1">//public static void main(String[] args) throws IOException {</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="n">readFile</span><span class="o">(</span><span class="s">"c:\\a.tx"</span><span class="o">);</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"后续代码"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="cm">/*
        定义一个方法,对传递的文件路径进行合法性判断
        如果路径不是"c:\\a.txt",那么我们就抛出文件找不到异常对象,告知方法的调用者
        注意:
            FileNotFoundException是编译异常,抛出了编译异常,就必须处理这个异常
            可以使用throws继续声明抛出FileNotFoundException这个异常对象,让方法的调用者处理
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">readFile</span><span class="o">(</span><span class="nc">String</span> <span class="n">fileName</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">FileNotFoundException</span><span class="o">,</span><span class="nc">IOException</span><span class="o">{</span>
        <span class="k">if</span><span class="o">(!</span><span class="n">fileName</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">"c:\\a.txt"</span><span class="o">)){</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">FileNotFoundException</span><span class="o">(</span><span class="s">"传递的文件路径不是c:\\a.txt"</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="cm">/*
            如果传递的路径,不是.txt结尾
            那么我们就抛出IO异常对象,告知方法的调用者,文件的后缀名不对

         */</span>
        <span class="k">if</span><span class="o">(!</span><span class="n">fileName</span><span class="o">.</span><span class="na">endsWith</span><span class="o">(</span><span class="s">".txt"</span><span class="o">)){</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IOException</span><span class="o">(</span><span class="s">"文件的后缀名不对"</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"路径没有问题,读取文件"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h3 id="24--捕获异常trycatch">2.4 捕获异常try…catch</h3> <p>如果异常出现的话,会立刻终止程序,所以我们得处理异常:</p> <ol> <li>该方法不处理,而是声明抛出,由该方法的调用者来处理(throws)。</li> <li>在方法中使用try-catch的语句块来处理异常。</li> </ol> <p><strong>try-catch</strong>的方式就是捕获异常。</p> <ul> <li><strong>捕获异常</strong>：Java中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理。</li> </ul> <p>捕获异常语法如下：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span><span class="o">{</span>
     <span class="n">编写可能会出现异常的代码</span>
<span class="o">}</span><span class="k">catch</span><span class="o">(</span><span class="n">异常类型</span>  <span class="n">e</span><span class="o">){</span>
     <span class="n">处理异常的代码</span>
     <span class="c1">//记录日志/打印异常信息/继续抛出异常</span>
<span class="o">}</span>
</code></pre></div></div> <p><strong>try：</strong>该代码块中编写可能产生异常的代码。</p> <p><strong>catch：</strong>用来进行某种异常的捕获，实现对捕获到的异常进行处理。</p> <blockquote> <p>注意:try和catch都不能单独使用,必须连用。</p> </blockquote> <p>演示如下：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TryCatchDemo</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span><span class="c1">// 当产生异常时，必须有处理方式。要么捕获，要么声明。</span>
            <span class="n">read</span><span class="o">(</span><span class="s">"b.txt"</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">FileNotFoundException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span><span class="c1">// 括号中需要定义什么呢？</span>
          	<span class="c1">//try中抛出的是什么异常，在括号中就定义什么异常类型</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"over"</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="cm">/*
     *
     * 我们 当前的这个方法中 有异常  有编译期异常
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">read</span><span class="o">(</span><span class="nc">String</span> <span class="n">path</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">FileNotFoundException</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">path</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">"a.txt"</span><span class="o">))</span> <span class="o">{</span><span class="c1">//如果不是 a.txt这个文件 </span>
            <span class="c1">// 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">FileNotFoundException</span><span class="o">(</span><span class="s">"文件不存在"</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>如何获取异常信息：</p> <p>Throwable类中定义了一些查看方法:</p> <ul> <li> <p><code class="language-plaintext highlighter-rouge">public String getMessage()</code>:获取异常的描述信息,原因(提示给用户的时候,就提示错误原因。</p> </li> <li><code class="language-plaintext highlighter-rouge">public String toString()</code>:获取异常的类型和异常描述信息(不用)。</li> <li><code class="language-plaintext highlighter-rouge">public void printStackTrace()</code>:打印异常的跟踪栈信息并输出到控制台。</li> </ul> <p>​ <em>包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。</em></p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>

<span class="cm">/*
    try...catch:异常处理的第二种方式,自己处理异常
    格式:
        try{
            可能产生异常的代码
        }catch(定义一个异常的变量,用来接收try中抛出的异常对象){
            异常的处理逻辑,异常异常对象之后,怎么处理异常对象
            一般在工作中,会把异常的信息记录到一个日志中
        }
        ...
        catch(异常类名 变量名){

        }
    注意:
        1.try中可能会抛出多个异常对象,那么就可以使用多个catch来处理这些异常对象
        2.如果try中产生了异常,那么就会执行catch中的异常处理逻辑,执行完毕catch中的处理逻辑,继续执行try...catch之后的代码
          如果try中没有产生异常,那么就不会执行catch中异常的处理逻辑,执行完try中的代码,继续执行try...catch之后的代码
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo01TryCatch</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">try</span><span class="o">{</span>
            <span class="c1">//可能产生异常的代码</span>
            <span class="n">readFile</span><span class="o">(</span><span class="s">"d:\\a.tx"</span><span class="o">);</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"资源释放"</span><span class="o">);</span>
        <span class="o">}</span><span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">){</span><span class="c1">//try中抛出什么异常对象,catch就定义什么异常变量,用来接收这个异常对象</span>
            <span class="c1">//异常的处理逻辑,异常异常对象之后,怎么处理异常对象</span>
            <span class="c1">//System.out.println("catch - 传递的文件后缀不是.txt");</span>

            <span class="cm">/*
                Throwable类中定义了3个异常处理的方法
                 String getMessage() 返回此 throwable 的简短描述。
                 String toString() 返回此 throwable 的详细消息字符串。
                 void printStackTrace()  JVM打印异常对象,默认此方法,打印的异常信息是最全面的
             */</span>
            <span class="c1">//System.out.println(e.getMessage());//文件的后缀名不对</span>
            <span class="c1">//System.out.println(e.toString());//重写Object类的toString java.io.IOException: 文件的后缀名不对</span>
            <span class="c1">//System.out.println(e);//java.io.IOException: 文件的后缀名不对</span>

            <span class="cm">/*
                java.io.IOException: 文件的后缀名不对
                    at demo02.Exception.Demo01TryCatch.readFile(Demo01TryCatch.java:55)
                    at demo02.Exception.Demo01TryCatch.main(Demo01TryCatch.java:27)
             */</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"后续代码"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="cm">/*
       如果传递的路径,不是.txt结尾
       那么我们就抛出IO异常对象,告知方法的调用者,文件的后缀名不对

    */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">readFile</span><span class="o">(</span><span class="nc">String</span> <span class="n">fileName</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>

        <span class="k">if</span><span class="o">(!</span><span class="n">fileName</span><span class="o">.</span><span class="na">endsWith</span><span class="o">(</span><span class="s">".txt"</span><span class="o">)){</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IOException</span><span class="o">(</span><span class="s">"文件的后缀名不对"</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"路径没有问题,读取文件"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h3 id="24-finally-代码块">2.4 finally 代码块</h3> <p><strong>finally</strong>：有一些特定的代码无论异常是否发生，都需要执行。另外，因为异常会引发程序跳转，导致有些语句执行不到。而finally就是解决这个问题的，在finally代码块中存放的代码都是一定会被执行的。</p> <p>什么时候的代码必须最终执行？</p> <p>当我们在try语句块中打开了一些物理资源(磁盘文件/网络连接/数据库连接等),我们都得在使用完之后,最终关闭打开的资源。</p> <p>finally的语法:</p> <p>try…catch….finally:自身需要处理异常,最终还得关闭资源。</p> <blockquote> <p>注意:finally不能单独使用。</p> </blockquote> <p>比如在我们之后学习的IO流中，当打开了一个关联文件的资源，最后程序不管结果如何，都需要把这个资源关闭掉。</p> <p>finally代码参考如下：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TryCatchDemo4</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">read</span><span class="o">(</span><span class="s">"a.txt"</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">FileNotFoundException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">//抓取到的是编译期异常  抛出去的是运行期 </span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"不管程序怎样，这里都将会被执行。"</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"over"</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="cm">/*
     *
     * 我们 当前的这个方法中 有异常  有编译期异常
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">read</span><span class="o">(</span><span class="nc">String</span> <span class="n">path</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">FileNotFoundException</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">path</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">"a.txt"</span><span class="o">))</span> <span class="o">{</span><span class="c1">//如果不是 a.txt这个文件 </span>
            <span class="c1">// 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">FileNotFoundException</span><span class="o">(</span><span class="s">"文件不存在"</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <blockquote> <p>当只有在try或者catch中调用退出JVM的相关方法,此时finally才不会执行,否则finally永远会执行。</p> </blockquote> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>

<span class="cm">/*
    finally代码块
     格式:
        try{
            可能产生异常的代码
        }catch(定义一个异常的变量,用来接收try中抛出的异常对象){
            异常的处理逻辑,异常异常对象之后,怎么处理异常对象
            一般在工作中,会把异常的信息记录到一个日志中
        }
        ...
        catch(异常类名 变量名){

        }finally{
            无论是否出现异常都会执行
        }
     注意:
        1.finally不能单独使用,必须和try一起使用
        2.finally一般用于资源释放(资源回收),无论程序是否出现异常,最后都要资源释放(IO)
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo02TryCatchFinally</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="c1">//可能会产生异常的代码</span>
            <span class="n">readFile</span><span class="o">(</span><span class="s">"c:\\a.tx"</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">//异常的处理逻辑</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="c1">//无论是否出现异常,都会执行</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"资源释放"</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="cm">/*
       如果传递的路径,不是.txt结尾
       那么我们就抛出IO异常对象,告知方法的调用者,文件的后缀名不对

    */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">readFile</span><span class="o">(</span><span class="nc">String</span> <span class="n">fileName</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>

        <span class="k">if</span><span class="o">(!</span><span class="n">fileName</span><span class="o">.</span><span class="na">endsWith</span><span class="o">(</span><span class="s">".txt"</span><span class="o">)){</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IOException</span><span class="o">(</span><span class="s">"文件的后缀名不对"</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"路径没有问题,读取文件"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h3 id="25---异常注意事项">2.5 异常注意事项</h3> <ul> <li> <p>多个异常使用捕获又该如何处理呢？</p> <ol> <li>多个异常分别处理。</li> <li>多个异常一次捕获，多次处理。</li> <li>多个异常一次捕获一次处理。</li> </ol> <p>一般我们是使用一次捕获多次处理方式，格式如下：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span><span class="o">{</span>
     <span class="n">编写可能会出现异常的代码</span>
<span class="o">}</span><span class="k">catch</span><span class="o">(</span><span class="n">异常类型A</span>  <span class="n">e</span><span class="o">){</span>  <span class="n">当try中出现A类型异常</span><span class="o">,</span><span class="n">就用该catch来捕获</span><span class="o">.</span>
     <span class="n">处理异常的代码</span>
     <span class="c1">//记录日志/打印异常信息/继续抛出异常</span>
<span class="o">}</span><span class="k">catch</span><span class="o">(</span><span class="n">异常类型B</span>  <span class="n">e</span><span class="o">){</span>  <span class="n">当try中出现B类型异常</span><span class="o">,</span><span class="n">就用该catch来捕获</span><span class="o">.</span>
     <span class="n">处理异常的代码</span>
     <span class="c1">//记录日志/打印异常信息/继续抛出异常</span>
<span class="o">}</span>
</code></pre></div> </div> <blockquote> <p>注意:这种异常处理方式，要求多个catch中的异常不能相同，并且若catch中的多个异常之间有子父类异常的关系，那么子类异常要求在上面的catch处理，父类异常在下面的catch处理。</p> </blockquote> </li> <li> <p>运行时异常被抛出可以不处理。即不捕获也不声明抛出。</p> </li> <li> <p>如果finally有return语句,永远返回finally中的结果,避免该情况.</p> </li> <li> <p>如果父类抛出了多个异常,子类重写父类方法时,抛出和父类相同的异常或者是父类异常的子类或者不抛出异常。</p> </li> <li> <p>父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出</p> </li> </ul> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="cm">/*
    异常的注意事项
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo01Exception</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="cm">/*
            多个异常使用捕获又该如何处理呢？
            1. 多个异常分别处理。
            2. 多个异常一次捕获，多次处理。
            3. 多个异常一次捕获一次处理。
         */</span>

        <span class="c1">//1. 多个异常分别处理。</span>
       <span class="cm">/* try {
            int[] arr = {1,2,3};
            System.out.println(arr[3]);//ArrayIndexOutOfBoundsException: 3
        }catch (ArrayIndexOutOfBoundsException e){
            System.out.println(e);
        }

        try{
            List&lt;Integer&gt; list = List.of(1, 2, 3);
            System.out.println(list.get(3));//IndexOutOfBoundsException: Index 3 out-of-bounds for length 3
        }catch (IndexOutOfBoundsException e){
            System.out.println(e);
        }*/</span>

        <span class="c1">//2. 多个异常一次捕获，多次处理。</span>
        <span class="cm">/*try {
            int[] arr = {1,2,3};
            //System.out.println(arr[3]);//ArrayIndexOutOfBoundsException: 3
            List&lt;Integer&gt; list = List.of(1, 2, 3);
            System.out.println(list.get(3));//IndexOutOfBoundsException: Index 3 out-of-bounds for length 3
        }catch (ArrayIndexOutOfBoundsException e){
            System.out.println(e);
        }catch (IndexOutOfBoundsException e){
            System.out.println(e);
        }*/</span>

        <span class="cm">/*
            一个try多个catch注意事项:
                catch里边定义的异常变量,如果有子父类关系,那么子类的异常变量必须写在上边,否则就会报错
                ArrayIndexOutOfBoundsException extends IndexOutOfBoundsException
         */</span>
        <span class="cm">/*try {
            int[] arr = {1,2,3};
            //System.out.println(arr[3]);//ArrayIndexOutOfBoundsException: 3
            List&lt;Integer&gt; list = List.of(1, 2, 3);
            System.out.println(list.get(3));//IndexOutOfBoundsException: Index 3 out-of-bounds for length 3
        }catch (IndexOutOfBoundsException e){
            System.out.println(e);
        }catch (ArrayIndexOutOfBoundsException e){
            System.out.println(e);
        }*/</span>

        <span class="c1">//3. 多个异常一次捕获一次处理。</span>
        <span class="cm">/*try {
            int[] arr = {1,2,3};
            //System.out.println(arr[3]);//ArrayIndexOutOfBoundsException: 3
            List&lt;Integer&gt; list = List.of(1, 2, 3);
            System.out.println(list.get(3));//IndexOutOfBoundsException: Index 3 out-of-bounds for length 3
        }catch (Exception e){
            System.out.println(e);
        }*/</span>

        <span class="c1">//运行时异常被抛出可以不处理。即不捕获也不声明抛出。</span>
        <span class="c1">//默认给虚拟机处理,终止程序,什么时候不抛出运行时异常了,在来继续执行程序</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="mi">3</span><span class="o">]);</span><span class="c1">//ArrayIndexOutOfBoundsException: 3</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="nc">List</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">3</span><span class="o">));</span><span class="c1">//IndexOutOfBoundsException: Index 3 out-of-bounds for length 3</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"后续代码!"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
    如果finally有return语句,永远返回finally中的结果,避免该情况.
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo02Exception</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">getA</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">a</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">//定义一个方法,返回变量a的值</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">getA</span><span class="o">(){</span>
        <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>
        <span class="k">try</span><span class="o">{</span>
            <span class="k">return</span> <span class="n">a</span><span class="o">;</span>
        <span class="o">}</span><span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">){</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
        <span class="o">}</span><span class="k">finally</span> <span class="o">{</span>
            <span class="c1">//一定会执行的代码</span>
            <span class="n">a</span> <span class="o">=</span> <span class="mi">100</span><span class="o">;</span>
            <span class="k">return</span> <span class="n">a</span><span class="o">;</span>
        <span class="o">}</span>

    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
    子父类的异常:
        - 如果父类抛出了多个异常,子类重写父类方法时,抛出和父类相同的异常或者是父类异常的子类或者不抛出异常。
        - 父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出
    注意:
        父类异常时什么样,子类异常就什么样
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Fu</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">show01</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">NullPointerException</span><span class="o">,</span><span class="nc">ClassCastException</span><span class="o">{}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">show02</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">IndexOutOfBoundsException</span><span class="o">{}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">show03</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">IndexOutOfBoundsException</span><span class="o">{}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">show04</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Zi</span> <span class="kd">extends</span> <span class="nc">Fu</span><span class="o">{</span>
    <span class="c1">//子类重写父类方法时,抛出和父类相同的异常</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">show01</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">NullPointerException</span><span class="o">,</span><span class="nc">ClassCastException</span><span class="o">{}</span>
    <span class="c1">//子类重写父类方法时,抛出父类异常的子类</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">show02</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">ArrayIndexOutOfBoundsException</span><span class="o">{}</span>
    <span class="c1">//子类重写父类方法时,不抛出异常</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">show03</span><span class="o">()</span> <span class="o">{}</span>

    <span class="cm">/*
        父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常。

     */</span>
    <span class="c1">//public void show04() throws Exception{}</span>

    <span class="c1">//此时子类产生该异常，只能捕获处理，不能声明抛出</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">show04</span><span class="o">()</span>  <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="k">throw</span>  <span class="k">new</span> <span class="nf">Exception</span><span class="o">(</span><span class="s">"编译期异常"</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
    子父类的异常:
        - 如果父类抛出了多个异常,子类重写父类方法时,抛出和父类相同的异常或者是父类异常的子类或者不抛出异常。
        - 父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出
    注意:
        父类异常时什么样,子类异常就什么样
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Fu</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">show01</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">NullPointerException</span><span class="o">,</span><span class="nc">ClassCastException</span><span class="o">{}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">show02</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">IndexOutOfBoundsException</span><span class="o">{}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">show03</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">IndexOutOfBoundsException</span><span class="o">{}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">show04</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Zi</span> <span class="kd">extends</span> <span class="nc">Fu</span><span class="o">{</span>
    <span class="c1">//子类重写父类方法时,抛出和父类相同的异常</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">show01</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">NullPointerException</span><span class="o">,</span><span class="nc">ClassCastException</span><span class="o">{}</span>
    <span class="c1">//子类重写父类方法时,抛出父类异常的子类</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">show02</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">ArrayIndexOutOfBoundsException</span><span class="o">{}</span>
    <span class="c1">//子类重写父类方法时,不抛出异常</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">show03</span><span class="o">()</span> <span class="o">{}</span>

    <span class="cm">/*
        父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常。

     */</span>
    <span class="c1">//public void show04() throws Exception{}</span>

    <span class="c1">//此时子类产生该异常，只能捕获处理，不能声明抛出</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">show04</span><span class="o">()</span>  <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="k">throw</span>  <span class="k">new</span> <span class="nf">Exception</span><span class="o">(</span><span class="s">"编译期异常"</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h2 id="3-自定义异常">3. 自定义异常</h2> <h3 id="31-概述">3.1 概述</h3> <p><strong>为什么需要自定义异常类:</strong></p> <p>我们说了Java中不同的异常类,分别表示着某一种具体的异常情况,那么在开发中总是有些异常情况是SUN没有定义好的,此时我们根据自己业务的异常情况来定义异常类。例如年龄负数问题,考试成绩负数问题等等。</p> <p>在上述代码中，发现这些异常都是JDK内部定义好的，但是实际开发中也会出现很多异常,这些异常很可能在JDK中没有定义过,例如年龄负数问题,考试成绩负数问题.那么能不能自己定义异常呢？</p> <p><strong>什么是自定义异常类:</strong></p> <p>在开发中根据自己业务的异常情况来定义异常类.</p> <p>自定义一个业务逻辑异常: <strong>RegisterException</strong>。一个注册异常类。</p> <p><strong>异常类如何定义:</strong></p> <ol> <li>自定义一个编译期异常: 自定义类 并继承于<code class="language-plaintext highlighter-rouge">java.lang.Exception</code>。</li> <li>自定义一个运行时期的异常类:自定义类 并继承于<code class="language-plaintext highlighter-rouge">java.lang.RuntimeException</code>。</li> </ol> <h3 id="32-自定义异常的练习">3.2 自定义异常的练习</h3> <p>要求：我们模拟注册操作，如果用户名已存在，则抛出异常并提示：亲，该用户名已经被注册。</p> <p>首先定义一个登陆异常类RegisterException：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 业务逻辑异常</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RegisterException</span> <span class="kd">extends</span> <span class="nc">Exception</span> <span class="o">{</span>
    <span class="cm">/**
     * 空参构造
     */</span>
    <span class="kd">public</span> <span class="nf">RegisterException</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">}</span>

    <span class="cm">/**
     *
     * @param message 表示异常提示
     */</span>
    <span class="kd">public</span> <span class="nf">RegisterException</span><span class="o">(</span><span class="nc">String</span> <span class="n">message</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">message</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>模拟登陆操作，使用数组模拟数据库中存储的数据，并提供当前注册账号是否存在方法用于判断。</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo</span> <span class="o">{</span>
    <span class="c1">// 模拟数据库中已存在账号</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">String</span><span class="o">[]</span> <span class="n">names</span> <span class="o">=</span> <span class="o">{</span><span class="s">"bill"</span><span class="o">,</span><span class="s">"hill"</span><span class="o">,</span><span class="s">"jill"</span><span class="o">};</span>
   
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>     
        <span class="c1">//调用方法</span>
        <span class="k">try</span><span class="o">{</span>
              <span class="c1">// 可能出现异常的代码</span>
            <span class="n">checkUsername</span><span class="o">(</span><span class="s">"nill"</span><span class="o">);</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"注册成功"</span><span class="o">);</span><span class="c1">//如果没有异常就是注册成功</span>
        <span class="o">}</span><span class="k">catch</span><span class="o">(</span><span class="nc">RegisterException</span> <span class="n">e</span><span class="o">){</span>
            <span class="c1">//处理异常</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">//判断当前注册账号是否存在</span>
    <span class="c1">//因为是编译期异常，又想调用者去处理 所以声明该异常</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">checkUsername</span><span class="o">(</span><span class="nc">String</span> <span class="n">uname</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">LoginException</span><span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">name</span> <span class="o">:</span> <span class="n">names</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">name</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">uname</span><span class="o">)){</span><span class="c1">//如果名字在这里面 就抛出登陆异常</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">RegisterException</span><span class="o">(</span><span class="s">"亲"</span><span class="o">+</span><span class="n">name</span><span class="o">+</span><span class="s">"已经被注册了！"</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.Scanner</span><span class="o">;</span>

<span class="cm">/*
    要求：我们模拟注册操作，如果用户名已存在，则抛出异常并提示：亲，该用户名已经被注册。

    分析:
        1.使用数组保存已经注册过的用户名(数据库)
        2.使用Scanner获取用户输入的注册的用户名(前端,页面)
        3.定义一个方法,对用户输入的中注册的用户名进行判断
            遍历存储已经注册过用户名的数组,获取每一个用户名
            使用获取到的用户名和用户输入的用户名比较
                true:
                    用户名已经存在,抛出RegisterException异常,告知用户"亲，该用户名已经被注册";
                false:
                    继续遍历比较
            如果循环结束了,还没有找到重复的用户名,提示用户"恭喜您,注册成功!";
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo01RegisterException</span> <span class="o">{</span>
    <span class="c1">// 1.使用数组保存已经注册过的用户名(数据库)</span>
    <span class="kd">static</span> <span class="nc">String</span><span class="o">[]</span> <span class="n">usernames</span> <span class="o">=</span> <span class="o">{</span><span class="s">"张三"</span><span class="o">,</span><span class="s">"李四"</span><span class="o">,</span><span class="s">"王五"</span><span class="o">};</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="cm">/*throws RegisterException*/</span> <span class="o">{</span>
        <span class="c1">//2.使用Scanner获取用户输入的注册的用户名(前端,页面)</span>
        <span class="nc">Scanner</span> <span class="n">sc</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Scanner</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"请输入您要注册的用户名:"</span><span class="o">);</span>
        <span class="nc">String</span> <span class="n">username</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
        <span class="n">checkUsername</span><span class="o">(</span><span class="n">username</span><span class="o">);</span>

    <span class="o">}</span>

    <span class="c1">//3.定义一个方法,对用户输入的中注册的用户名进行判断</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">checkUsername</span><span class="o">(</span><span class="nc">String</span> <span class="n">username</span><span class="o">)</span> <span class="cm">/*throws RegisterException*/</span> <span class="o">{</span>
        <span class="c1">//遍历存储已经注册过用户名的数组,获取每一个用户名</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">name</span> <span class="o">:</span> <span class="n">usernames</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">//使用获取到的用户名和用户输入的用户名比较</span>
            <span class="k">if</span><span class="o">(</span><span class="n">name</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">username</span><span class="o">)){</span>
                <span class="c1">//true:用户名已经存在,抛出RegisterException异常,告知用户"亲，该用户名已经被注册";</span>
                <span class="k">try</span> <span class="o">{</span>
                    <span class="k">throw</span> <span class="k">new</span> <span class="nf">RegisterException</span><span class="o">(</span><span class="s">"亲，该用户名已经被注册"</span><span class="o">);</span>
                <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">RegisterException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
                    <span class="k">return</span><span class="o">;</span> <span class="c1">//结束方法</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">//如果循环结束了,还没有找到重复的用户名,提示用户"恭喜您,注册成功!";</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"恭喜您,注册成功!"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.Scanner</span><span class="o">;</span>

<span class="cm">/*
    要求：我们模拟注册操作，如果用户名已存在，则抛出异常并提示：亲，该用户名已经被注册。

    分析:
        1.使用数组保存已经注册过的用户名(数据库)
        2.使用Scanner获取用户输入的注册的用户名(前端,页面)
        3.定义一个方法,对用户输入的中注册的用户名进行判断
            遍历存储已经注册过用户名的数组,获取每一个用户名
            使用获取到的用户名和用户输入的用户名比较
                true:
                    用户名已经存在,抛出RegisterException异常,告知用户"亲，该用户名已经被注册";
                false:
                    继续遍历比较
            如果循环结束了,还没有找到重复的用户名,提示用户"恭喜您,注册成功!";
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo02RegisterException</span> <span class="o">{</span>
    <span class="c1">// 1.使用数组保存已经注册过的用户名(数据库)</span>
    <span class="kd">static</span> <span class="nc">String</span><span class="o">[]</span> <span class="n">usernames</span> <span class="o">=</span> <span class="o">{</span><span class="s">"张三"</span><span class="o">,</span><span class="s">"李四"</span><span class="o">,</span><span class="s">"王五"</span><span class="o">};</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//2.使用Scanner获取用户输入的注册的用户名(前端,页面)</span>
        <span class="nc">Scanner</span> <span class="n">sc</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Scanner</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"请输入您要注册的用户名:"</span><span class="o">);</span>
        <span class="nc">String</span> <span class="n">username</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
        <span class="n">checkUsername</span><span class="o">(</span><span class="n">username</span><span class="o">);</span>

    <span class="o">}</span>

    <span class="c1">//3.定义一个方法,对用户输入的中注册的用户名进行判断</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">checkUsername</span><span class="o">(</span><span class="nc">String</span> <span class="n">username</span><span class="o">)</span>  <span class="o">{</span>
        <span class="c1">//遍历存储已经注册过用户名的数组,获取每一个用户名</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">name</span> <span class="o">:</span> <span class="n">usernames</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">//使用获取到的用户名和用户输入的用户名比较</span>
            <span class="k">if</span><span class="o">(</span><span class="n">name</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">username</span><span class="o">)){</span>
                <span class="c1">//true:用户名已经存在,抛出RegisterException异常,告知用户"亲，该用户名已经被注册";</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">RegisterException</span><span class="o">(</span><span class="s">"亲，该用户名已经被注册"</span><span class="o">);</span><span class="c1">//抛出运行期异常,无需处理,交给JVM处理,中断处理</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">//如果循环结束了,还没有找到重复的用户名,提示用户"恭喜您,注册成功!";</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"恭喜您,注册成功!"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
    自定义异常类:
        java提供的异常类,不够我们使用,需要自己定义一些异常类
    格式:
        public class XXXExcepiton extends Exception | RuntimeException{
            添加一个空参数的构造方法
            添加一个带异常信息的构造方法
        }
     注意:
        1.自定义异常类一般都是以Exception结尾,说明该类是一个异常类
        2.自定义异常类,必须的继承Exception或者RuntimeException
            继承Exception:那么自定义的异常类就是一个编译期异常,如果方法内部抛出了编译期异常,就必须处理这个异常,要么throws,要么try...catch
            继承RuntimeException:那么自定义的异常类就是一个运行期异常,无需处理,交给虚拟机处理(中断处理)
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RegisterException</span> <span class="kd">extends</span> <span class="cm">/*Exception*/</span> <span class="nc">RuntimeException</span><span class="o">{</span>
    <span class="c1">//添加一个空参数的构造方法</span>
    <span class="kd">public</span> <span class="nf">RegisterException</span><span class="o">(){</span>
        <span class="kd">super</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="cm">/*
        添加一个带异常信息的构造方法
        查看源码发现,所有的异常类都会有一个带异常信息的构造方法,方法内部会调用父类带异常信息的构造方法,让父类来处理这个异常信息
     */</span>
    <span class="kd">public</span> <span class="nf">RegisterException</span><span class="o">(</span><span class="nc">String</span> <span class="n">message</span><span class="o">){</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">message</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h2 id="4-多线程">4. 多线程</h2> <p>我们在之前，学习的程序在没有跳转语句的前提下，都是由上至下依次执行，那现在想要设计一个程序，边打游戏边听歌，怎么设计？</p> <p>要解决上述问题,咱们得使用多进程或者多线程来解决.</p> <h3 id="41-并发与并行">4.1 并发与并行</h3> <ul> <li><strong>并发</strong>：指两个或多个事件在<strong>同一个时间段内</strong>发生.(交替执行)</li> <li><strong>并行</strong>：指两个或多个事件在<strong>同一时刻</strong>发生（同时发生）。</li> </ul> <p><img src="https://blog.slienceme.cn/images/posts/20210126095032933.bmp.jpg" alt="Alt Text" /> <img src="https://blog.slienceme.cn/images/posts/20210126104459743.png" alt="Alt Text" /></p> <p>在操作系统中，安装了多个程序，并发指的是在一段时间内宏观上有多个程序同时运行，这在单 CPU 系统中，每一时刻只能有一道程序执行，即微观上这些程序是分时的交替运行，只不过是给人的感觉是同时运行，那是因为分时交替运行的时间是非常短的。</p> <p>而在多个 CPU 系统中，则这些可以并发执行的程序便可以分配到多个处理器上（CPU），实现多任务并行执行，即利用每个处理器来处理一个可以并发执行的程序，这样多个程序便可以同时执行。目前电脑市场上说的多核 CPU，便是多核处理器，核 越多，并行处理的程序越多，能大大的提高电脑运行的效率。</p> <blockquote> <p>注意：单核处理器的计算机肯定是不能并行的处理多个任务的，只能是多个任务在单个CPU上并发运行。同理,线程也是一样的，从宏观角度上理解线程是并行运行的，但是从微观角度上分析却是串行运行的，即一个线程一个线程的去运行，当系统只有一个CPU时，线程会以某种顺序执行多个线程，我们把这种情况称之为线程调度。</p> </blockquote> <h3 id="42-线程与进程">4.2 线程与进程</h3> <ul> <li> <p><strong>进程</strong>：是指一个内存中运行的应用程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。</p> </li> <li> <p><strong>线程</strong>：线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。</p> <p>简而言之：一个程序运行后至少有一个进程，一个进程中可以包含多个线程</p> </li> </ul> <p>我们可以再电脑底部任务栏，右键—–&gt;打开任务管理器,可以查看当前任务的进程：</p> <p><strong>进程</strong></p> <p><img src="https://blog.slienceme.cn/images/posts/20210126095041974.png" alt="Alt Text" /></p> <p><strong>线程</strong></p> <p><img src="https://blog.slienceme.cn/images/posts/20210126095059413.png" alt="Alt Text" /> <img src="https://blog.slienceme.cn/images/posts/20210126105523520.png" alt="Alt Text" /></p> <p><strong>线程调度:</strong></p> <ul> <li> <p>分时调度</p> <p>所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。</p> </li> <li> <p>抢占式调度</p> <p>优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)，Java使用的为抢占式调度。</p> <ul> <li>设置线程的优先级</li> </ul> </li> </ul> <p><img src="https://blog.slienceme.cn/images/posts/20210126095115901.bmp.jpg" alt="Alt Text" /></p> <ul> <li>抢占式调度详解</li> </ul> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>大部分操作系统都支持多进程并发运行，现在的操作系统几乎都支持同时运行多个程序。比如：现在我们上课一边使用编辑器，一边使用录屏软件，同时还开着画图板，dos窗口等软件。此时，这些程序是在同时运行，”感觉这些软件好像在同一时刻运行着“。

实际上，CPU(中央处理器)使用抢占式调度模式在多个线程间进行着高速的切换。对于CPU的一个核而言，某个时刻，只能执行一个线程，而 CPU的在多个线程间切换速度相对我们的感觉要快，看上去就是在同一时刻运行。
其实，多线程程序并不能提高程序的运行速度，但能够提高程序运行效率，让CPU的使用率更高。
</code></pre></div></div> <p><img src="https://blog.slienceme.cn/images/posts/20210126095130826.bmp.jpg" alt="Alt Text" /></p> <h3 id="43-创建线程类">4.3 创建线程类</h3> <p>Java使用<code class="language-plaintext highlighter-rouge">java.lang.Thread</code>类代表<strong>线程</strong>，所有的线程对象都必须是Thread类或其子类的实例。每个线程的作用是完成一定的任务，实际上就是执行一段程序流即一段顺序执行的代码。Java使用线程执行体来代表这段程序流。Java中通过继承Thread类来<strong>创建</strong>并<strong>启动多线程</strong>的步骤如下：</p> <ol> <li>定义Thread类的子类，并重写该类的run()方法，该run()方法的方法体就代表了线程需要完成的任务,因此把run()方法称为线程执行体。</li> <li>创建Thread子类的实例，即创建了线程对象</li> <li>调用线程对象的start()方法来启动该线程</li> </ol> <p>代码如下：</p> <p>测试类：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo01</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
		<span class="c1">//创建自定义线程对象</span>
		<span class="nc">MyThread</span> <span class="n">mt</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MyThread</span><span class="o">(</span><span class="s">"新的线程！"</span><span class="o">);</span>
		<span class="c1">//开启新线程</span>
		<span class="n">mt</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
		<span class="c1">//在主方法中执行for循环</span>
		<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
			<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"main线程！"</span><span class="o">+</span><span class="n">i</span><span class="o">);</span>
		<span class="o">}</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>自定义线程类：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyThread</span> <span class="kd">extends</span> <span class="nc">Thread</span> <span class="o">{</span>
	<span class="c1">//定义指定线程名称的构造方法</span>
	<span class="kd">public</span> <span class="nf">MyThread</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
		<span class="c1">//调用父类的String参数的构造方法，指定线程的名称</span>
		<span class="kd">super</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
	<span class="o">}</span>
	<span class="cm">/**
	 * 重写run方法，完成该线程执行的逻辑
	 */</span>
	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
			<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">getName</span><span class="o">()+</span><span class="s">"：正在执行！"</span><span class="o">+</span><span class="n">i</span><span class="o">);</span>
		<span class="o">}</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
    主线程:执行主(main)方法的线程

    单线程程序:java程序中只有一个线程
    执行从main方法开始,从上到下依次执行

    JVM执行main方法,main方法会进入到栈内存
    JVM会找操作系统开辟一条main方法通向cpu的执行路径
    cpu就可以通过这个路径来执行main方法
    而这个路径有一个名字,叫main(主)线程
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo01MainThread</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Person</span> <span class="n">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"小强"</span><span class="o">);</span>
        <span class="n">p1</span><span class="o">.</span><span class="na">run</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="mi">0</span><span class="o">/</span><span class="mi">0</span><span class="o">);</span><span class="c1">//ArithmeticException: / by zero</span>
        <span class="nc">Person</span> <span class="n">p2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"旺财"</span><span class="o">);</span>
        <span class="n">p2</span><span class="o">.</span><span class="na">run</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">(){</span>
        <span class="c1">//定义循环,执行20次</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">20</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">name</span><span class="o">+</span><span class="s">"--&gt;"</span><span class="o">+</span><span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nf">Person</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nf">Person</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getName</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setName</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h2 id="5-线程">5. 线程</h2> <h3 id="51-多线程原理">5.1 多线程原理</h3> <p>昨天的时候我们已经写过一版多线程的代码，很多同学对原理不是很清楚，那么我们今天先画个多线程执行时序图 来体现一下多线程程序的执行流程。</p> <p>代码如下：</p> <p>自定义线程类：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyThread</span> <span class="kd">extends</span> <span class="nc">Thread</span><span class="o">{</span> <span class="cm">/*

*	利用继承中的特点

*	将线程名称传递 进行设置

*/</span>

<span class="kd">public</span> <span class="nf">MyThread</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">){</span> 
	<span class="kd">super</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
<span class="o">}</span>

<span class="cm">/*
*	重写run方法
*	定义线程要执行的代码
*/</span>

<span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">(){</span>

	<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span> 
		<span class="c1">//getName()方法 来自父亲 </span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">getName</span><span class="o">()+</span><span class="n">i</span><span class="o">);</span>
		<span class="o">}</span>

	<span class="o">}</span>

<span class="o">}</span>

</code></pre></div></div> <p>测试类：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    	<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"这里是main线程"</span><span class="o">);</span>  
     	<span class="nc">MyThread</span> <span class="n">mt</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MyThread</span><span class="o">(</span><span class="s">"小强"</span><span class="o">);</span>            
     	<span class="n">mt</span><span class="o">.</span><span class="na">start</span><span class="o">();</span><span class="c1">//开启了一个新的线程    </span>
     	<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>    
			<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"旺财:"</span><span class="o">+</span><span class="n">i</span><span class="o">);</span>            
		<span class="o">}</span>        
	<span class="o">}</span>    
<span class="o">}</span>  
</code></pre></div></div> <p>流程图： <img src="https://blog.slienceme.cn/images/posts/20210124111520624.png" alt="Alt Text" /> 程序启动运行 main时候，java虚拟机启动一个进程，主线程main在main()调用时候被创建。随着调用mt的对象的 start方法，另外一个新的线程也启动了，这样，整个应用就在多线程下运行。</p> <p>通过这张图我们可以很清晰的看到多线程的执行流程，那么为什么可以完成并发执行呢？我们再来讲一讲原理。</p> <p>多线程执行时，到底在内存中是如何运行的呢？以上个程序为例，进行图解说明：</p> <p>多线程执行时，在栈内存中，其实<strong>每一个执行线程都有一片自己所属的栈内存空间</strong>。进行方法的压栈和弹栈。 <img src="https://blog.slienceme.cn/images/posts/20210124111627365.png" alt="Alt Text" /> 当执行线程的任务结束了，线程自动在栈内存中释放了。但是当所有的执行线程都结束了，那么进程就结束了。</p> <p><img src="https://blog.slienceme.cn/images/posts/2021012611131223.png" alt="Alt Text" /></p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//1.创建一个Thread类的子类</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyThread</span> <span class="kd">extends</span> <span class="nc">Thread</span><span class="o">{</span>
    <span class="c1">//2.在Thread类的子类中重写Thread类中的run方法,设置线程任务(开启线程要做什么?)</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span><span class="mi">20</span> <span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"run:"</span><span class="o">+</span><span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
    创建多线程程序的第一种方式:创建Thread类的子类
    java.lang.Thread类:是描述线程的类,我们想要实现多线程程序,就必须继承Thread类

    实现步骤:
        1.创建一个Thread类的子类
        2.在Thread类的子类中重写Thread类中的run方法,设置线程任务(开启线程要做什么?)
        3.创建Thread类的子类对象
        4.调用Thread类中的方法start方法,开启新的线程,执行run方法
             void start() 使该线程开始执行；Java 虚拟机调用该线程的 run 方法。
             结果是两个线程并发地运行；当前线程（main线程）和另一个线程（创建的新线程,执行其 run 方法）。
             多次启动一个线程是非法的。特别是当线程已经结束执行后，不能再重新启动。
    java程序属于抢占式调度,那个线程的优先级高,那个线程优先执行;同一个优先级,随机选择一个执行
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo01Thread</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//3.创建Thread类的子类对象</span>
        <span class="nc">MyThread</span> <span class="n">mt</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MyThread</span><span class="o">();</span>
        <span class="c1">//4.调用Thread类中的方法start方法,开启新的线程,执行run方法</span>
        <span class="n">mt</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span><span class="mi">20</span> <span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"main:"</span><span class="o">+</span><span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p><img src="https://blog.slienceme.cn/images/posts/20210126164056138.png" alt="Alt Text" /></p> <h3 id="52-thread-类">5.2 Thread 类</h3> <p>在上一天内容中我们已经可以完成最基本的线程开启，那么在我们完成操作过程中用到了 java.lang.Thread 类， API中该类中定义了有关线程的一些方法，具体如下：</p> <p><strong>构造方法：</strong></p> <ul> <li><code class="language-plaintext highlighter-rouge">public Thread()</code> :分配一个新的线程对象。</li> <li><code class="language-plaintext highlighter-rouge">public Thread(String name)</code> :分配一个指定名字的新的线程对象。</li> <li><code class="language-plaintext highlighter-rouge">public Thread(Runnable target)</code> :分配一个带有指定目标新的线程对象。</li> <li><code class="language-plaintext highlighter-rouge">public Thread(Runnable target,String name)</code> :分配一个带有指定目标新的线程对象并指定名字。</li> </ul> <p><strong>常用方法：</strong></p> <ul> <li><code class="language-plaintext highlighter-rouge">public String getName()</code> :获取当前线程名称。</li> <li><code class="language-plaintext highlighter-rouge">public void start()</code> :导致此线程开始执行; Java虚拟机调用此线程的run方法。</li> <li><code class="language-plaintext highlighter-rouge">public void run()</code> :此线程要执行的任务在此处定义代码。</li> <li><code class="language-plaintext highlighter-rouge">public static void sleep(long millis)</code> :使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。</li> <li><code class="language-plaintext highlighter-rouge">public static Thread currentThread()</code> :返回对当前正在执行的线程对象的引用。</li> </ul> <p>翻阅API后得知创建线程的方式总共有两种，一种是继承Thread类方式，一种是实现Runnable接口方式</p> <p><strong>getName</strong></p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
    获取线程的名称:
        1.使用Thread类中的方法getName()
            String getName() 返回该线程的名称。
        2.可以先获取到当前正在执行的线程,使用线程中的方法getName()获取线程的名称
            static Thread currentThread() 返回对当前正在执行的线程对象的引用。
 */</span>
<span class="c1">// 定义一个Thread类的子类</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyThread</span> <span class="kd">extends</span> <span class="nc">Thread</span><span class="o">{</span>
    <span class="c1">//重写Thread类中的run方法,设置线程任务</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">//获取线程名称</span>
        <span class="c1">//String name = getName();</span>
        <span class="c1">//System.out.println(name);</span>

        <span class="c1">//Thread t = Thread.currentThread();</span>
        <span class="c1">//System.out.println(t);//Thread[Thread-0,5,main]</span>
        <span class="c1">//String name = t.getName();</span>
        <span class="c1">//System.out.println(name);</span>

        <span class="c1">//链式编程</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
    线程的名称:
        主线程: main
        新线程: Thread-0,Thread-1,Thread-2
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo01GetThreadName</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//创建Thread类的子类对象</span>
        <span class="nc">MyThread</span> <span class="n">mt</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MyThread</span><span class="o">();</span>
        <span class="c1">//调用start方法,开启新线程,执行run方法</span>
        <span class="n">mt</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>

        <span class="k">new</span> <span class="nf">MyThread</span><span class="o">().</span><span class="na">start</span><span class="o">();</span>
        <span class="k">new</span> <span class="nf">MyThread</span><span class="o">().</span><span class="na">start</span><span class="o">();</span>

        <span class="c1">//链式编程</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <hr /> <p><strong>setName</strong></p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
    设置线程的名称:(了解)
        1.使用Thread类中的方法setName(名字)
            void setName(String name) 改变线程名称，使之与参数 name 相同。
        2.创建一个带参数的构造方法,参数传递线程的名称;调用父类的带参构造方法,把线程名称传递给父类,让父类(Thread)给子线程起一个名字
            Thread(String name) 分配新的 Thread 对象。
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyThread</span> <span class="kd">extends</span> <span class="nc">Thread</span><span class="o">{</span>

    <span class="kd">public</span> <span class="nf">MyThread</span><span class="o">(){}</span>

    <span class="kd">public</span> <span class="nf">MyThread</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">){</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">name</span><span class="o">);</span><span class="c1">//把线程名称传递给父类,让父类(Thread)给子线程起一个名字</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">//获取线程的名称</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo01SetThreadName</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//开启多线程</span>
        <span class="nc">MyThread</span> <span class="n">mt</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MyThread</span><span class="o">();</span>
        <span class="n">mt</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">"小强"</span><span class="o">);</span>
        <span class="n">mt</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>

        <span class="c1">//开启多线程</span>
        <span class="k">new</span> <span class="nf">MyThread</span><span class="o">(</span><span class="s">"旺财"</span><span class="o">).</span><span class="na">start</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p><strong>sleep</strong></p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
    public static void sleep(long millis):使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。
    毫秒数结束之后,线程继续执行
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo01Sleep</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//模拟秒表</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span><span class="mi">60</span> <span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>

            <span class="c1">//使用Thread类的sleep方法让程序睡眠1秒钟</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h3 id="53--创建线程方式二">5.3 创建线程方式二</h3> <p>采用 <code class="language-plaintext highlighter-rouge">java.lang.Runnable</code> 也是非常常见的一种，我们只需要重写run方法即可。</p> <p>步骤如下：</p> <ol> <li>定义Runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。</li> <li>创建Runnable实现类的实例，并以此实例作为Thread的target来创建Thread对象，该Thread对象才是真正 的线程对象。</li> <li>调用线程对象的start()方法来启动线程。</li> </ol> <p>代码如下：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyRunnable</span> <span class="kd">implements</span> <span class="nc">Runnable</span><span class="o">{</span>
	<span class="nd">@Override</span>    
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>    
		<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>        
			<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()+</span><span class="s">" "</span><span class="o">+</span><span class="n">i</span><span class="o">);</span>            
		<span class="o">}</span>        
	<span class="o">}</span>    
<span class="o">}</span>
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//创建自定义类对象  线程任务对象</span>
        <span class="nc">MyRunnable</span> <span class="n">mr</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MyRunnable</span><span class="o">();</span>
        <span class="c1">//创建线程对象</span>
        <span class="nc">Thread</span> <span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="n">mr</span><span class="o">,</span> <span class="s">"小强"</span><span class="o">);</span>
        <span class="n">t</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"旺财 "</span> <span class="o">+</span> <span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>通过实现 Runnable接口，使得该类有了多线程类的特征。run()方法是多线程程序的一个执行目标。所有的多线程代码都在run方法里面。Thread类实际上也是实现了Runnable接口的类。</p> <p>在启动的多线程的时候，需要先通过Thread类的构造方法Thread(Runnable target) 构造出对象，然后调用Thread 对象的start()方法来运行多线程代码。</p> <p>实际上所有的多线程代码都是通过运行Thread的start()方法来运行的。因此，不管是继承Thread类还是实现Runnable接口来实现多线程，最终还是通过Thread的对象的API来控制线程的，熟悉Thread类的API是进行多线程编程的基础。</p> <blockquote> <p>tips:Runnable对象仅仅作为Thread对象的target，Runnable实现类里包含的run()方法仅作为线程执行体。而实际的线程对象依然是Thread实例，只是该Thread线程负责执行其target的run()方法。</p> </blockquote> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//1.创建一个Runnable接口的实现类</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RunnableImpl</span> <span class="kd">implements</span> <span class="nc">Runnable</span><span class="o">{</span>
    <span class="c1">//2.在实现类中重写Runnable接口的run方法,设置线程任务</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span><span class="mi">20</span> <span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()+</span><span class="s">"--&gt;"</span><span class="o">+</span><span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//1.创建一个Runnable接口的实现类</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RunnableImpl2</span> <span class="kd">implements</span> <span class="nc">Runnable</span><span class="o">{</span>
    <span class="c1">//2.在实现类中重写Runnable接口的run方法,设置线程任务</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span><span class="mi">20</span> <span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"HelloWorld"</span><span class="o">+</span><span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
    创建多线程程序的第二种方式:实现Runnable接口
    java.lang.Runnable
        Runnable 接口应该由那些打算通过某一线程执行其实例的类来实现。类必须定义一个称为 run 的无参数方法。
    java.lang.Thread类的构造方法
        Thread(Runnable target) 分配新的 Thread 对象。
        Thread(Runnable target, String name) 分配新的 Thread 对象。

    实现步骤:
        1.创建一个Runnable接口的实现类
        2.在实现类中重写Runnable接口的run方法,设置线程任务
        3.创建一个Runnable接口的实现类对象
        4.创建Thread类对象,构造方法中传递Runnable接口的实现类对象
        5.调用Thread类中的start方法,开启新的线程执行run方法

    实现Runnable接口创建多线程程序的好处:
        1.避免了单继承的局限性
            一个类只能继承一个类(一个人只能有一个亲爹),类继承了Thread类就不能继承其他的类
            实现了Runnable接口,还可以继承其他的类,实现其他的接口
        2.增强了程序的扩展性,降低了程序的耦合性(解耦)
            实现Runnable接口的方式,把设置线程任务和开启新线程进行了分离(解耦)
            实现类中,重写了run方法:用来设置线程任务
            创建Thread类对象,调用start方法:用来开启新线程
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo01Runnable</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//3.创建一个Runnable接口的实现类对象</span>
        <span class="nc">RunnableImpl</span> <span class="n">run</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">RunnableImpl</span><span class="o">();</span>
        <span class="c1">//4.创建Thread类对象,构造方法中传递Runnable接口的实现类对象</span>
        <span class="c1">//Thread t = new Thread(run);//打印线程名称</span>
        <span class="nc">Thread</span> <span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="k">new</span> <span class="nc">RunnableImpl2</span><span class="o">());</span><span class="c1">//打印HelloWorld</span>
        <span class="c1">//5.调用Thread类中的start方法,开启新的线程执行run方法</span>
        <span class="n">t</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span><span class="mi">20</span> <span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()+</span><span class="s">"--&gt;"</span><span class="o">+</span><span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h3 id="54-thread-和runnable的区别">5.4 Thread 和Runnable的区别</h3> <p>如果一个类继承Thread，则不适合资源共享。但是如果实现了Runable接口的话，则很容易的实现资源共享。</p> <p><strong>总结：</strong></p> <p><strong>实现Runnable接口比继承Thread类所具有的优势：</strong></p> <ol> <li>适合多个相同的程序代码的线程去共享同一个资源。</li> <li>可以避免java中的单继承的局限性。</li> <li>增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独立。</li> <li>线程池只能放入实现Runable或Callable类线程，不能直接放入继承Thread的类。</li> </ol> <blockquote> <p>扩充：在java中，每次程序运行至少启动2个线程。一个是main线程，一个是垃圾收集线程。因为每当使用 java命令执行一个类的时候，实际上都会启动一个JVM，每一个JVM其实在就是在操作系统中启动了一个进程。</p> </blockquote> <h3 id="55--匿名内部类方式实现线程的创建">5.5 匿名内部类方式实现线程的创建</h3> <p>使用线程的内匿名内部类方式，可以方便的实现每个线程执行不同的线程任务操作。 使用匿名内部类的方式实现Runnable接口，重新Runnable接口中的run方法：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kd">public</span> <span class="kd">class</span> <span class="nc">NoNameInnerClassThread</span> <span class="o">{</span>
   <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>            
<span class="c1">// new Runnable(){      </span>
<span class="c1">// public void run(){          </span>
<span class="c1">// for (int i = 0; i &lt; 20; i++) {              </span>
<span class="c1">// System.out.println("张宇:"+i);                  </span>
<span class="c1">// }              </span>
<span class="c1">// }            </span>
<span class="c1">//    }; //‐‐‐这个整体  相当于new MyRunnable()    </span>
        <span class="nc">Runnable</span> <span class="n">r</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Runnable</span><span class="o">(){</span>
            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">(){</span>
                <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                   <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"张宇:"</span><span class="o">+</span><span class="n">i</span><span class="o">);</span>  
                <span class="o">}</span>
            <span class="o">}</span> 
        <span class="o">};</span>
        <span class="k">new</span> <span class="nf">Thread</span><span class="o">(</span><span class="n">r</span><span class="o">).</span><span class="na">start</span><span class="o">();</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
           <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"费玉清:"</span><span class="o">+</span><span class="n">i</span><span class="o">);</span>  
        <span class="o">}</span>
   <span class="o">}</span> 
<span class="o">}</span>
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
    匿名内部类方式实现线程的创建

    匿名:没有名字
    内部类:写在其他类内部的类

    匿名内部类作用:简化代码
        把子类继承父类,重写父类的方法,创建子类对象合一步完成
        把实现类实现类接口,重写接口中的方法,创建实现类对象合成一步完成
    匿名内部类的最终产物:子类/实现类对象,而这个类没有名字

    格式:
        new 父类/接口(){
            重复父类/接口中的方法
        };
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo01InnerClassThread</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//线程的父类是Thread</span>
        <span class="c1">// new MyThread().start();</span>
        <span class="k">new</span> <span class="nf">Thread</span><span class="o">(){</span>
            <span class="c1">//重写run方法,设置线程任务</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
                <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span><span class="mi">20</span> <span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()+</span><span class="s">"--&gt;"</span><span class="o">+</span><span class="s">"ren"</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}.</span><span class="na">start</span><span class="o">();</span>

        <span class="c1">//线程的接口Runnable</span>
        <span class="c1">//Runnable r = new RunnableImpl();//多态</span>
        <span class="nc">Runnable</span> <span class="n">r</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Runnable</span><span class="o">(){</span>
            <span class="c1">//重写run方法,设置线程任务</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
                <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span><span class="mi">20</span> <span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()+</span><span class="s">"--&gt;"</span><span class="o">+</span><span class="s">"min"</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">};</span>
        <span class="k">new</span> <span class="nf">Thread</span><span class="o">(</span><span class="n">r</span><span class="o">).</span><span class="na">start</span><span class="o">();</span>

        <span class="c1">//简化接口的方式</span>
        <span class="k">new</span> <span class="nf">Thread</span><span class="o">(</span><span class="k">new</span> <span class="nc">Runnable</span><span class="o">(){</span>
            <span class="c1">//重写run方法,设置线程任务</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
                <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span><span class="mi">20</span> <span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()+</span><span class="s">"--&gt;"</span><span class="o">+</span><span class="s">"xingfu"</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}).</span><span class="na">start</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h2 id="6-线程安全">6. 线程安全</h2> <h3 id="61-线程安全">6.1 线程安全</h3> <p>如果有多个线程在同时运行，而这些线程可能会同时运行这段代码。程序每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。</p> <p>我们通过一个案例，演示线程的安全问题：</p> <p>电影院要卖票，我们模拟电影院的卖票过程。假设要播放的电影是 “葫芦娃大战奥特曼”，本次电影的座位共100个(本场电影只能卖100张票)。</p> <p>我们来模拟电影院的售票窗口，实现多个窗口同时卖 “葫芦娃大战奥特曼”这场电影票(多个窗口一起卖这100张票)</p> <p>需要窗口，采用线程对象来模拟；需要票，Runnable接口子类来模拟</p> <p><img src="https://blog.slienceme.cn/images/posts/20210126171837291.png" alt="Alt Text" /></p> <p>模拟票：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Ticket</span> <span class="kd">implements</span> <span class="nc">Runnable</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">ticket</span> <span class="o">=</span> <span class="mi">100</span><span class="o">;</span>
    <span class="cm">/*
     * 执行卖票操作
     */</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">//每个窗口卖票的操作</span>
        <span class="c1">//窗口 永远开启</span>
        <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">ticket</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span><span class="c1">//有票 可以卖</span>
                <span class="c1">//出票操作</span>
                <span class="c1">//使用sleep模拟一下出票时间</span>
                <span class="k">try</span> <span class="o">{</span>
                    <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">100</span><span class="o">);</span>
                <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                    <span class="c1">// TODO Auto‐generated catch block</span>
                    <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
                <span class="o">}</span>
                <span class="c1">//获取当前线程对象的名字</span>
                <span class="nc">String</span> <span class="n">name</span> <span class="o">=</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">();</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">name</span> <span class="o">+</span> <span class="s">"正在卖:"</span> <span class="o">+</span> <span class="n">ticket</span><span class="err">‐‐</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>测试类：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>    
		<span class="c1">//创建线程任务对象        </span>
		<span class="nc">Ticket</span> <span class="n">ticket</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Ticket</span><span class="o">();</span>        
		<span class="c1">//创建三个窗口对象        </span>
		<span class="nc">Thread</span> <span class="n">t1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="n">ticket</span><span class="o">,</span> <span class="s">"窗口1"</span><span class="o">);</span>        
		<span class="nc">Thread</span> <span class="n">t2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="n">ticket</span><span class="o">,</span> <span class="s">"窗口2"</span><span class="o">);</span>        
		<span class="nc">Thread</span> <span class="n">t3</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="n">ticket</span><span class="o">,</span> <span class="s">"窗口3"</span><span class="o">);</span>        
       
		<span class="c1">//同时卖票        </span>
		<span class="n">t1</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>        
		<span class="n">t2</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>        
		<span class="n">t3</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>        
	<span class="o">}</span>    
<span class="o">}</span>
</code></pre></div></div> <p>结果中有一部分这样现象： <img src="https://blog.slienceme.cn/images/posts/20210124112740741.png" alt="Alt Text" /> 发现程序出现了两个问题：</p> <ol> <li>相同的票数,比如5这张票被卖了两回。</li> <li>不存在的票，比如0票与-1票，是不存在的。</li> </ol> <p>这种问题，几个窗口(线程)票数不同步了，这种问题称为线程不安全。 <img src="https://blog.slienceme.cn/images/posts/20210126173244291.png" alt="Alt Text" /></p> <blockquote> <p>线程安全问题都是由全局变量及静态变量引起的。若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。</p> </blockquote> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
    实现卖票案例
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RunnableImpl</span> <span class="kd">implements</span> <span class="nc">Runnable</span><span class="o">{</span>
    <span class="c1">//定义一个多个线程共享的票源</span>
    <span class="kd">private</span>  <span class="kt">int</span> <span class="n">ticket</span> <span class="o">=</span> <span class="mi">100</span><span class="o">;</span>


    <span class="c1">//设置线程任务:卖票</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">//使用死循环,让卖票操作重复执行</span>
        <span class="k">while</span><span class="o">(</span><span class="kc">true</span><span class="o">){</span>
            <span class="c1">//先判断票是否存在</span>
            <span class="k">if</span><span class="o">(</span><span class="n">ticket</span><span class="o">&gt;</span><span class="mi">0</span><span class="o">){</span>
                <span class="c1">//提高安全问题出现的概率,让程序睡眠</span>
                <span class="k">try</span> <span class="o">{</span>
                    <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>
                <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
                <span class="o">}</span>

                <span class="c1">//票存在,卖票 ticket--</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()+</span><span class="s">"--&gt;正在卖第"</span><span class="o">+</span><span class="n">ticket</span><span class="o">+</span><span class="s">"张票"</span><span class="o">);</span>
                <span class="n">ticket</span><span class="o">--;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
    模拟卖票案例
    创建3个线程,同时开启,对共享的票进行出售
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo01Ticket</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//创建Runnable接口的实现类对象</span>
        <span class="nc">RunnableImpl</span> <span class="n">run</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">RunnableImpl</span><span class="o">();</span>
        <span class="c1">//创建Thread类对象,构造方法中传递Runnable接口的实现类对象</span>
        <span class="nc">Thread</span> <span class="n">t0</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="n">run</span><span class="o">);</span>
        <span class="nc">Thread</span> <span class="n">t1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="n">run</span><span class="o">);</span>
        <span class="nc">Thread</span> <span class="n">t2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="n">run</span><span class="o">);</span>
        <span class="c1">//调用start方法开启多线程</span>
        <span class="n">t0</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">t1</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">t2</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h3 id="62--线程同步">6.2 线程同步</h3> <p>当我们使用多个线程访问同一资源的时候，且多个线程中对资源有写的操作，就容易出现线程安全问题。</p> <p>要解决上述多线程并发访问一个资源的安全性问题:也就是解决重复票与不存在票问题，Java中提供了同步机制(synchronized)来解决。</p> <p>根据案例简述：</p> <blockquote> <p>窗口1线程进入操作的时候，窗口2和窗口3线程只能在外等着，窗口1操作结束，窗口1和窗口2和窗口3才有机会进入代码去执行。也就是说在某个线程修改共享资源的时候，其他线程不能修改该资源，等待修改完毕同步之后，才能去抢夺CPU资源，完成对应的操作，保证了数据的同步性，解决了线程不安全的现象。</p> </blockquote> <p>为了保证每个线程都能正常执行原子操作,Java引入了线程同步机制。</p> <p>那么怎么去使用呢？有三种方式完成同步操作：</p> <ol> <li>同步代码块。</li> <li>同步方法。</li> <li>锁机制。</li> </ol> <h3 id="63-同步代码块">6.3 同步代码块</h3> <ul> <li><strong>同步代码块</strong> ： <code class="language-plaintext highlighter-rouge">synchronized</code> 关键字可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。</li> </ul> <p>格式:</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">synchronized</span><span class="o">(</span><span class="n">同步锁</span><span class="o">){</span>
     <span class="n">需要同步操作的代码</span>
<span class="o">}</span>
</code></pre></div></div> <p><strong>同步锁:</strong></p> <p>对象的同步锁只是一个概念,可以想象为在对象上标记了一个锁.</p> <ol> <li>锁对象 可以是任意类型。</li> <li>多个线程对象 要使用同一把锁。</li> </ol> <blockquote> <p>注意:在任何时候,最多允许一个线程拥有同步锁,谁拿到锁就进入代码块,其他的线程只能在外等着(BLOCKED)。</p> </blockquote> <p>使用同步代码块解决代码：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Ticket</span> <span class="kd">implements</span> <span class="nc">Runnable</span><span class="o">{</span>
	<span class="kd">private</span> <span class="kt">int</span> <span class="n">ticket</span> <span class="o">=</span> <span class="mi">100</span><span class="o">;</span>    
   
	<span class="nc">Object</span> <span class="n">lock</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">();</span>    
	<span class="cm">/*    
	 * 执行卖票操作    
	 */</span>    
	<span class="nd">@Override</span>    
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>    
		<span class="c1">//每个窗口卖票的操作         </span>
		<span class="c1">//窗口 永远开启         </span>
		<span class="k">while</span><span class="o">(</span><span class="kc">true</span><span class="o">){</span>        
			<span class="kd">synchronized</span> <span class="o">(</span><span class="n">lock</span><span class="o">)</span> <span class="o">{</span>            
				<span class="k">if</span><span class="o">(</span><span class="n">ticket</span><span class="o">&gt;</span><span class="mi">0</span><span class="o">){</span><span class="c1">//有票 可以卖                </span>
					<span class="c1">//出票操作                    </span>
					<span class="c1">//使用sleep模拟一下出票时间                     </span>
					<span class="k">try</span> <span class="o">{</span>                    
					<span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">50</span><span class="o">);</span>                        
					<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>                    
					<span class="c1">// TODO Auto‐generated catch block                        </span>
					<span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>                        
					<span class="o">}</span>                    
					<span class="c1">//获取当前线程对象的名字                     </span>
					<span class="nc">String</span> <span class="n">name</span> <span class="o">=</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">();</span>                    
					<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">name</span><span class="o">+</span><span class="s">"正在卖:"</span><span class="o">+</span><span class="n">ticket</span><span class="err">‐‐</span><span class="o">);</span>                    
					<span class="o">}</span>                
				<span class="o">}</span> 
			<span class="o">}</span>        
		<span class="o">}</span>    
<span class="o">}</span>
</code></pre></div></div> <p>当使用了同步代码块后，上述的线程的安全问题，解决了。</p> <p><img src="https://blog.slienceme.cn/images/posts/20210126174145956.png" alt="Alt Text" /></p> <hr /> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
    卖票案例出现了线程安全问题
    卖出了不存在的票和重复的票

    解决线程安全问题的一种方案:使用同步代码块
    格式:
        synchronized(锁对象){
            可能会出现线程安全问题的代码(访问了共享数据的代码)
        }

    注意:
        1.通过代码块中的锁对象,可以使用任意的对象
        2.但是必须保证多个线程使用的锁对象是同一个
        3.锁对象作用:
            把同步代码块锁住,只让一个线程在同步代码块中执行
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RunnableImpl</span> <span class="kd">implements</span> <span class="nc">Runnable</span><span class="o">{</span>
    <span class="c1">//定义一个多个线程共享的票源</span>
    <span class="kd">private</span>  <span class="kt">int</span> <span class="n">ticket</span> <span class="o">=</span> <span class="mi">100</span><span class="o">;</span>

    <span class="c1">//创建一个锁对象</span>
    <span class="nc">Object</span> <span class="n">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">();</span>

    <span class="c1">//设置线程任务:卖票</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">//使用死循环,让卖票操作重复执行</span>
        <span class="k">while</span><span class="o">(</span><span class="kc">true</span><span class="o">){</span>
           <span class="c1">//同步代码块</span>
            <span class="kd">synchronized</span> <span class="o">(</span><span class="n">obj</span><span class="o">){</span>
                <span class="c1">//先判断票是否存在</span>
                <span class="k">if</span><span class="o">(</span><span class="n">ticket</span><span class="o">&gt;</span><span class="mi">0</span><span class="o">){</span>
                    <span class="c1">//提高安全问题出现的概率,让程序睡眠</span>
                    <span class="k">try</span> <span class="o">{</span>
                        <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>
                    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
                    <span class="o">}</span>

                    <span class="c1">//票存在,卖票 ticket--</span>
                    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()+</span><span class="s">"--&gt;正在卖第"</span><span class="o">+</span><span class="n">ticket</span><span class="o">+</span><span class="s">"张票"</span><span class="o">);</span>
                    <span class="n">ticket</span><span class="o">--;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
    模拟卖票案例
    创建3个线程,同时开启,对共享的票进行出售
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo01Ticket</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//创建Runnable接口的实现类对象</span>
        <span class="nc">RunnableImpl</span> <span class="n">run</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">RunnableImpl</span><span class="o">();</span>
        <span class="c1">//创建Thread类对象,构造方法中传递Runnable接口的实现类对象</span>
        <span class="nc">Thread</span> <span class="n">t0</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="n">run</span><span class="o">);</span>
        <span class="nc">Thread</span> <span class="n">t1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="n">run</span><span class="o">);</span>
        <span class="nc">Thread</span> <span class="n">t2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="n">run</span><span class="o">);</span>
        <span class="c1">//调用start方法开启多线程</span>
        <span class="n">t0</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">t1</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">t2</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h3 id="64-同步方法">6.4 同步方法</h3> <ul> <li><strong>同步方法</strong> :使用synchronized修饰的方法,就叫做同步方法,保证A线程执行该方法的时候,其他线程只能在方法外等着。</li> </ul> <p>格式：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">method</span><span class="o">(){</span>
   <span class="n">可能会产生线程安全问题的代码</span> 
<span class="o">}</span>
</code></pre></div></div> <blockquote> <p>同步锁是谁?</p> <p>对于非static方法,同步锁就是this。</p> <p>对于static方法,我们使用当前方法所在类的字节码对象(类名.class)。</p> </blockquote> <p>使用同步方法代码如下：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Ticket</span> <span class="kd">implements</span> <span class="nc">Runnable</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">ticket</span> <span class="o">=</span> <span class="mi">100</span><span class="o">;</span>

    <span class="cm">/*
     * 执行卖票操作
     */</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
<span class="c1">//每个窗口卖票的操作         </span>
<span class="c1">//窗口 永远开启         </span>
        <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">sellTicket</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="cm">/*
     * 锁对象 是 谁调用这个方法 就是谁
     *   隐含 锁对象 就是  this
     *
     */</span>
    <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">sellTicket</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">ticket</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span><span class="c1">//有票 可以卖  </span>
            <span class="c1">//出票操作</span>
            <span class="c1">//使用sleep模拟一下出票时间</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">100</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// TODO Auto‐generated catch block  </span>
                <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
            <span class="o">}</span>
            <span class="c1">//获取当前线程对象的名字</span>
            <span class="nc">String</span> <span class="n">name</span> <span class="o">=</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">();</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">name</span> <span class="o">+</span> <span class="s">"正在卖:"</span> <span class="o">+</span> <span class="n">ticket</span><span class="err">‐‐</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
    卖票案例出现了线程安全问题
    卖出了不存在的票和重复的票

    解决线程安全问题的二种方案:使用同步方法
    使用步骤:
        1.把访问了共享数据的代码抽取出来,放到一个方法中
        2.在方法上添加synchronized修饰符

    格式:定义方法的格式
    修饰符 synchronized 返回值类型 方法名(参数列表){
        可能会出现线程安全问题的代码(访问了共享数据的代码)
    }
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RunnableImpl</span> <span class="kd">implements</span> <span class="nc">Runnable</span><span class="o">{</span>
    <span class="c1">//定义一个多个线程共享的票源</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">ticket</span> <span class="o">=</span> <span class="mi">100</span><span class="o">;</span>


    <span class="c1">//设置线程任务:卖票</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"this:"</span><span class="o">+</span><span class="k">this</span><span class="o">);</span><span class="c1">//this:demo08.Synchronized.RunnableImpl@58ceff1</span>
        <span class="c1">//使用死循环,让卖票操作重复执行</span>
        <span class="k">while</span><span class="o">(</span><span class="kc">true</span><span class="o">){</span>
            <span class="n">payTicketStatic</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="cm">/*
        静态的同步方法
        锁对象是谁?
        不能是this
        this是创建对象之后产生的,静态方法优先于对象
        静态方法的锁对象是本类的class属性--&gt;class文件对象(反射)
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="cm">/*synchronized*/</span> <span class="kt">void</span> <span class="nf">payTicketStatic</span><span class="o">(){</span>
        <span class="kd">synchronized</span> <span class="o">(</span><span class="nc">RunnableImpl</span><span class="o">.</span><span class="na">class</span><span class="o">){</span>
            <span class="c1">//先判断票是否存在</span>
            <span class="k">if</span><span class="o">(</span><span class="n">ticket</span><span class="o">&gt;</span><span class="mi">0</span><span class="o">){</span>
                <span class="c1">//提高安全问题出现的概率,让程序睡眠</span>
                <span class="k">try</span> <span class="o">{</span>
                    <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>
                <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
                <span class="o">}</span>

                <span class="c1">//票存在,卖票 ticket--</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()+</span><span class="s">"--&gt;正在卖第"</span><span class="o">+</span><span class="n">ticket</span><span class="o">+</span><span class="s">"张票"</span><span class="o">);</span>
                <span class="n">ticket</span><span class="o">--;</span>
            <span class="o">}</span>
        <span class="o">}</span>
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
    模拟卖票案例
    创建3个线程,同时开启,对共享的票进行出售
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo01Ticket</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//创建Runnable接口的实现类对象</span>
        <span class="nc">RunnableImpl</span> <span class="n">run</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">RunnableImpl</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"run:"</span><span class="o">+</span><span class="n">run</span><span class="o">);</span><span class="c1">//run:demo08.Synchronized.RunnableImpl@58ceff1</span>
        <span class="c1">//创建Thread类对象,构造方法中传递Runnable接口的实现类对象</span>
        <span class="nc">Thread</span> <span class="n">t0</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="n">run</span><span class="o">);</span>
        <span class="nc">Thread</span> <span class="n">t1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="n">run</span><span class="o">);</span>
        <span class="nc">Thread</span> <span class="n">t2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="n">run</span><span class="o">);</span>
        <span class="c1">//调用start方法开启多线程</span>
        <span class="n">t0</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">t1</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">t2</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h3 id="65-lock-锁">6.5 Lock 锁</h3> <p><code class="language-plaintext highlighter-rouge">java.util.concurrent.locks.Lock</code> 机制提供了比<strong>synchronized</strong>代码块和<strong>synchronized</strong>方法更广泛的锁定操作,同步代码块/同步方法具有的功能Lock都有,除此之外更强大,更体现面向对象。</p> <p>Lock锁也称同步锁，加锁与释放锁方法化了，如下：</p> <ul> <li><code class="language-plaintext highlighter-rouge">public void lock()</code> :加同步锁。</li> <li><code class="language-plaintext highlighter-rouge">public void unlock()</code> :释放同步锁。</li> </ul> <p>使用如下：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Ticket</span> <span class="kd">implements</span> <span class="nc">Runnable</span><span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">ticket</span> <span class="o">=</span> <span class="mi">100</span><span class="o">;</span>

    <span class="nc">Lock</span> <span class="n">lock</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ReentrantLock</span><span class="o">();</span>
    <span class="cm">/*
     * 执行卖票操作
     */</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
<span class="c1">//每个窗口卖票的操作         </span>
<span class="c1">//窗口 永远开启         </span>
        <span class="k">while</span><span class="o">(</span><span class="kc">true</span><span class="o">){</span>
            <span class="n">lock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
            <span class="k">if</span><span class="o">(</span><span class="n">ticket</span><span class="o">&gt;</span><span class="mi">0</span><span class="o">){</span><span class="c1">//有票 可以卖            </span>
<span class="c1">//出票操作                 </span>
<span class="c1">//使用sleep模拟一下出票时间                 </span>
                <span class="k">try</span> <span class="o">{</span>
                    <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">50</span><span class="o">);</span>
                <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
<span class="c1">// TODO Auto‐generated catch block                    </span>
                    <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
                <span class="o">}</span>
<span class="c1">//获取当前线程对象的名字                 </span>
                <span class="nc">String</span> <span class="n">name</span> <span class="o">=</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">();</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">name</span><span class="o">+</span><span class="s">"正在卖:"</span><span class="o">+</span><span class="n">ticket</span><span class="err">‐‐</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.concurrent.locks.Lock</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.concurrent.locks.ReentrantLock</span><span class="o">;</span>

<span class="cm">/*
    卖票案例出现了线程安全问题
    卖出了不存在的票和重复的票

    解决线程安全问题的三种方案:使用Lock锁
    java.util.concurrent.locks.Lock接口
    Lock 实现提供了比使用 synchronized 方法和语句可获得的更广泛的锁定操作。
    Lock接口中的方法:
        void lock()获取锁。
        void unlock()  释放锁。
    java.util.concurrent.locks.ReentrantLock implements Lock接口


    使用步骤:
        1.在成员位置创建一个ReentrantLock对象
        2.在可能会出现安全问题的代码前调用Lock接口中的方法lock获取锁
        3.在可能会出现安全问题的代码后调用Lock接口中的方法unlock释放锁
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RunnableImpl</span> <span class="kd">implements</span> <span class="nc">Runnable</span><span class="o">{</span>
    <span class="c1">//定义一个多个线程共享的票源</span>
    <span class="kd">private</span>  <span class="kt">int</span> <span class="n">ticket</span> <span class="o">=</span> <span class="mi">100</span><span class="o">;</span>

    <span class="c1">//1.在成员位置创建一个ReentrantLock对象</span>
    <span class="nc">Lock</span> <span class="n">l</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ReentrantLock</span><span class="o">();</span>

    <span class="c1">//设置线程任务:卖票</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">//使用死循环,让卖票操作重复执行</span>
        <span class="k">while</span><span class="o">(</span><span class="kc">true</span><span class="o">){</span>
            <span class="c1">//2.在可能会出现安全问题的代码前调用Lock接口中的方法lock获取锁</span>
            <span class="n">l</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>

            <span class="c1">//先判断票是否存在</span>
            <span class="k">if</span><span class="o">(</span><span class="n">ticket</span><span class="o">&gt;</span><span class="mi">0</span><span class="o">){</span>
                <span class="c1">//提高安全问题出现的概率,让程序睡眠</span>
                <span class="k">try</span> <span class="o">{</span>
                    <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>
                    <span class="c1">//票存在,卖票 ticket--</span>
                    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()+</span><span class="s">"--&gt;正在卖第"</span><span class="o">+</span><span class="n">ticket</span><span class="o">+</span><span class="s">"张票"</span><span class="o">);</span>
                    <span class="n">ticket</span><span class="o">--;</span>
                <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
                <span class="o">}</span><span class="k">finally</span> <span class="o">{</span>
                    <span class="c1">//3.在可能会出现安全问题的代码后调用Lock接口中的方法unlock释放锁</span>
                    <span class="n">l</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span><span class="c1">//无论程序是否异常,都会把锁释放</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="cm">/*//设置线程任务:卖票
    @Override
    public void run() {
        //使用死循环,让卖票操作重复执行
        while(true){
           //2.在可能会出现安全问题的代码前调用Lock接口中的方法lock获取锁
           l.lock();

            //先判断票是否存在
            if(ticket&gt;0){
                //提高安全问题出现的概率,让程序睡眠
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

                //票存在,卖票 ticket--
                System.out.println(Thread.currentThread().getName()+"--&gt;正在卖第"+ticket+"张票");
                ticket--;
            }

            //3.在可能会出现安全问题的代码后调用Lock接口中的方法unlock释放锁
            l.unlock();
        }
    }*/</span>
<span class="o">}</span>
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
    模拟卖票案例
    创建3个线程,同时开启,对共享的票进行出售
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo01Ticket</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//创建Runnable接口的实现类对象</span>
        <span class="nc">RunnableImpl</span> <span class="n">run</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">RunnableImpl</span><span class="o">();</span>
        <span class="c1">//创建Thread类对象,构造方法中传递Runnable接口的实现类对象</span>
        <span class="nc">Thread</span> <span class="n">t0</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="n">run</span><span class="o">);</span>
        <span class="nc">Thread</span> <span class="n">t1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="n">run</span><span class="o">);</span>
        <span class="nc">Thread</span> <span class="n">t2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="n">run</span><span class="o">);</span>
        <span class="c1">//调用start方法开启多线程</span>
        <span class="n">t0</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">t1</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">t2</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h2 id="7-线程状态">7. 线程状态</h2> <h3 id="71-线程状态概述">7.1 线程状态概述</h3> <p>当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。在线程的生命周期中，有几种状态呢？在API中 <code class="language-plaintext highlighter-rouge">java.lang.Thread.State</code> 这个枚举中给出了六种线程状态：</p> <p>这里先列出各个线程状态发生的条件，下面将会对每种状态进行详细解析</p> <p><img src="https://blog.slienceme.cn/images/posts/20210124124707935.png" alt="Alt Text" /> 我们不需要去研究这几种状态的实现原理，我们只需知道在做线程操作中存在这样的状态。那我们怎么去理解这几个状态呢，新建与被终止还是很容易理解的，我们就研究一下线程从Runnable（可运行）状态与非运行状态之间的转换问题。</p> <p><img src="https://blog.slienceme.cn/images/posts/20210126184725199.bmp.jpg" alt="Alt Text" /></p> <h3 id="72-timed-waiting-计时等待">7.2 Timed Waiting （计时等待）</h3> <p>Timed Waiting在API中的描述为：一个正在限时等待另一个线程执行一个（唤醒）动作的线程处于这一状态。单独的去理解这句话，真是玄之又玄，其实我们在之前的操作中已经接触过这个状态了，在哪里呢？</p> <p>在我们写卖票的案例中，为了减少线程执行太快，现象不明显等问题，我们在run方法中添加了sleep语句，这样就强制当前正在执行的线程休眠（暂停执行），以“减慢线程”。</p> <p>其实当我们调用了sleep方法之后，当前执行的线程就进入到“休眠状态”，其实就是所谓的Timed Waiting(计时等待)，那么我们通过一个案例加深对该状态的一个理解。</p> <p><strong>实现一个计数器，计数到100，在每个数字之间暂停1秒，每隔10个数字输出一个字符串</strong></p> <p>代码：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyThread</span> <span class="kd">extends</span> <span class="nc">Thread</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">((</span><span class="n">i</span><span class="o">)</span> <span class="o">%</span> <span class="mi">10</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"‐‐‐‐‐‐‐"</span> <span class="o">+</span> <span class="n">i</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>
               <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"    线程睡眠1秒！\n"</span><span class="o">);</span>  
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">new</span> <span class="nf">MyThread</span><span class="o">().</span><span class="na">start</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>通过案例可以发现， sleep方法的使用还是很简单的。我们需要记住下面几点：</p> <ol> <li>进入 TIMED_WAITING 状态的一种常见情形是调用的 sleep 方法，单独的线程也可以调用，不一定非要有协 作关系。</li> <li>为了让其他线程有机会执行，可以将Thread.sleep()的调用放线程run()之内。这样才能保证该线程执行过程 中会睡眠</li> <li>sleep与锁无关，线程睡眠到期自动苏醒，并返回到Runnable（可运行）状态。</li> </ol> <blockquote> <p>小提示：sleep()中指定的时间是线程不会运行的最短时间。因此，sleep()方法不能保证该线程睡眠到期后就 开始立刻执行。</p> </blockquote> <p><strong>Timed Waiting 线程状态图：</strong> <img src="https://blog.slienceme.cn/images/posts/20210124124902878.png" alt="Alt Text" /></p> <h3 id="73-blocked-锁阻塞">7.3 BLOCKED （锁阻塞）</h3> <p>Blocked 状态在API中的介绍为：一个正在阻塞等待一个监视器锁（锁对象）的线程处于这一状态。</p> <p>我们已经学完同步机制，那么这个状态是非常好理解的了。比如，线程A与线程B代码中使用同一锁，如果线程A获 取到锁，线程A进入到Runnable状态，那么线程B就进入到Blocked锁阻塞状态。</p> <p>这是由Runnable状态进入Blocked状态。除此Waiting以及Time Waiting状态也会在某种情况下进入阻塞状态，而 这部分内容作为扩充知识点带领大家了解一下。</p> <p>Blocked 线程状态图 <img src="https://blog.slienceme.cn/images/posts/20210124124938964.png" alt="Alt Text" /></p> <h3 id="74-waiting-无限等待">7.4 Waiting （无限等待）</h3> <p>Wating状态在API中介绍为：一个正在无限期等待另一个线程执行一个特别的（唤醒）动作的线程处于这一状态。</p> <p>那么我们之前遇到过这种状态吗？答案是并没有，但并不妨碍我们进行一个简单深入的了解。我们通过一段代码来 学习一下：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kd">public</span> <span class="kd">class</span> <span class="nc">WaitingTest</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Object</span> <span class="n">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">();</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 演示waiting</span>
        <span class="k">new</span> <span class="nf">Thread</span><span class="o">(</span><span class="k">new</span> <span class="nc">Runnable</span><span class="o">()</span> <span class="o">{</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
                <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">){</span>
                    <span class="kd">synchronized</span> <span class="o">(</span><span class="n">obj</span><span class="o">){</span>
                        <span class="k">try</span> <span class="o">{</span>
                            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()</span> <span class="o">+</span><span class="s">"=== 获取到锁对
 象，调用wait方法，进入waiting态，释放锁对象"</span><span class="o">);</span>
                            <span class="n">obj</span><span class="o">.</span><span class="na">wait</span><span class="o">();</span>  <span class="c1">//无限等待</span>
                            <span class="c1">//obj.wait(5000); //计时等待, 5秒 时间到，自动醒来</span>
                        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
                        <span class="o">}</span>
                        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()</span> <span class="o">+</span> <span class="s">"=== 从waiting状
态醒来，获取到锁对象，继续执行了"</span><span class="o">);</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">},</span><span class="s">"等待线程"</span><span class="o">).</span><span class="na">start</span><span class="o">();</span>
        <span class="k">new</span> <span class="nf">Thread</span><span class="o">(</span><span class="k">new</span> <span class="nc">Runnable</span><span class="o">()</span> <span class="o">{</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
<span class="c1">//                while (true){   //每隔3秒 唤醒一次</span>
                    <span class="k">try</span> <span class="o">{</span>
                        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()</span> <span class="o">+</span><span class="s">"‐‐‐‐‐ 等待3秒钟"</span><span class="o">);</span>
                        <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">3000</span><span class="o">);</span>
                    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
                    <span class="o">}</span>
                    <span class="kd">synchronized</span> <span class="o">(</span><span class="n">obj</span><span class="o">){</span>
                        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()</span> <span class="o">+</span><span class="s">"‐‐‐‐‐ 获取到锁对象,调用notify方法，释放锁对象"</span><span class="o">);</span>
                        <span class="n">obj</span><span class="o">.</span><span class="na">notify</span><span class="o">();</span>
                    <span class="o">}</span>
                <span class="o">}</span>
<span class="c1">//            }</span>
        <span class="o">},</span><span class="s">"唤醒线程"</span><span class="o">).</span><span class="na">start</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>通过上述案例我们会发现，一个调用了某个对象的 Object.wait 方法的线程会等待另一个线程调用此对象的Object.notify()方法 或 Object.notifyAll()方法。</p> <p>其实waiting状态并不是一个线程的操作，它体现的是多个线程间的通信，可以理解为多个线程之间的协作关系，多个线程会争取锁，同时相互之间又存在协作关系。就好比在公司里你和你的同事们，你们可能存在晋升时的竞争，但更多时候你们更多是一起合作以完成某些任务。</p> <p>当多个线程协作时，比如A，B线程，如果A线程在Runnable（可运行）状态中调用了wait()方法那么A线程就进入了Waiting（无限等待）状态，同时失去了同步锁。假如这个时候B线程获取到了同步锁，在运行状态中调用了notify()方法，那么就会将无限等待的A线程唤醒。注意是唤醒，如果获取到锁对象，那么A线程唤醒后就进入 Runnable（可运行）状态；如果没有获取锁对象，那么就进入到Blocked（锁阻塞状态）。</p> <p>Waiting 线程状态图 <img src="https://blog.slienceme.cn/images/posts/20210124125145535.png" alt="Alt Text" /></p> <h3 id="75--补充知识点">7.5 补充知识点</h3> <p>到此为止我们已经对线程状态有了基本的认识，想要有更多的了解，详情可以见下图： <img src="https://blog.slienceme.cn/images/posts/20210124125212222.png" alt="Alt Text" /></p> <blockquote> <p>一条有意思的tips: 我们在翻阅API的时候会发现Timed Waiting（计时等待） 与 Waiting（无限等待）状态联系还是很紧密的， 比如Waiting（无限等待） 状态中wait方法是空参的，而timed waiting（计时等待）中wait方法是带参的。 这种带参的方法，其实是一种倒计时操作，相当于我们生活中的小闹钟，我们设定好时间，到时通知，可是如果提前得到（唤醒）通知，那么设定好时间在通知也就显得多此一举了，那么这种设计方案其实是一举两得。如果没有得到（唤醒）通知，那么线程就处于Timed Waiting状态,直到倒计时完毕自动醒来；如果在倒计时期间得到（唤醒）通知，那么线程从Timed Waiting状态立刻唤醒。</p> </blockquote> <p><img src="https://blog.slienceme.cn/images/posts/20210126185748444.png" alt="Alt Text" /></p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
    等待唤醒案例:线程之间的通信
        创建一个顾客线程(消费者):告知老板要的包子的种类和数量,调用wait方法,放弃cpu的执行,进入到WAITING状态(无限等待)
        创建一个老板线程(生产者):花了5秒做包子,做好包子之后,调用notify方法,唤醒顾客吃包子

    注意:
        顾客和老板线程必须使用同步代码块包裹起来,保证等待和唤醒只能有一个在执行
        同步使用的锁对象必须保证唯一
        只有锁对象才能调用wait和notify方法

    Obejct类中的方法
    void wait()
          在其他线程调用此对象的 notify() 方法或 notifyAll() 方法前，导致当前线程等待。
    void notify()
          唤醒在此对象监视器上等待的单个线程。
          会继续执行wait方法之后的代码
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo01WaitAndNotify</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//创建锁对象,保证唯一</span>
        <span class="nc">Object</span> <span class="n">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">();</span>
        <span class="c1">// 创建一个顾客线程(消费者)</span>
        <span class="k">new</span> <span class="nf">Thread</span><span class="o">(){</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
               <span class="c1">//一直等着买包子</span>
               <span class="k">while</span><span class="o">(</span><span class="kc">true</span><span class="o">){</span>
                   <span class="c1">//保证等待和唤醒的线程只能有一个执行,需要使用同步技术</span>
                   <span class="kd">synchronized</span> <span class="o">(</span><span class="n">obj</span><span class="o">){</span>
                       <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"告知老板要的包子的种类和数量"</span><span class="o">);</span>
                       <span class="c1">//调用wait方法,放弃cpu的执行,进入到WAITING状态(无限等待)</span>
                       <span class="k">try</span> <span class="o">{</span>
                           <span class="n">obj</span><span class="o">.</span><span class="na">wait</span><span class="o">();</span>
                       <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                           <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
                       <span class="o">}</span>
                       <span class="c1">//唤醒之后执行的代码</span>
                       <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"包子已经做好了,开吃!"</span><span class="o">);</span>
                       <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"---------------------------------------"</span><span class="o">);</span>
                   <span class="o">}</span>
               <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}.</span><span class="na">start</span><span class="o">();</span>

        <span class="c1">//创建一个老板线程(生产者)</span>
        <span class="k">new</span> <span class="nf">Thread</span><span class="o">(){</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
                <span class="c1">//一直做包子</span>
                <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">){</span>
                    <span class="c1">//花了5秒做包子</span>
                    <span class="k">try</span> <span class="o">{</span>
                        <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">5000</span><span class="o">);</span><span class="c1">//花5秒钟做包子</span>
                    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
                    <span class="o">}</span>

                    <span class="c1">//保证等待和唤醒的线程只能有一个执行,需要使用同步技术</span>
                    <span class="kd">synchronized</span> <span class="o">(</span><span class="n">obj</span><span class="o">){</span>
                        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"老板5秒钟之后做好包子,告知顾客,可以吃包子了"</span><span class="o">);</span>
                        <span class="c1">//做好包子之后,调用notify方法,唤醒顾客吃包子</span>
                        <span class="n">obj</span><span class="o">.</span><span class="na">notify</span><span class="o">();</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}.</span><span class="na">start</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
    进入到TimeWaiting(计时等待)有两种方式
    1.使用sleep(long m)方法,在毫秒值结束之后,线程睡醒进入到Runnable/Blocked状态
    2.使用wait(long m)方法,wait方法如果在毫秒值结束之后,还没有被notify唤醒,就会自动醒来,线程睡醒进入到Runnable/Blocked状态

    唤醒的方法:
         void notify() 唤醒在此对象监视器上等待的单个线程。
         void notifyAll() 唤醒在此对象监视器上等待的所有线程。
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo02WaitAndNotify</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//创建锁对象,保证唯一</span>
        <span class="nc">Object</span> <span class="n">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">();</span>
        <span class="c1">// 创建一个顾客线程(消费者)</span>
        <span class="k">new</span> <span class="nf">Thread</span><span class="o">(){</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
                <span class="c1">//一直等着买包子</span>
                <span class="k">while</span><span class="o">(</span><span class="kc">true</span><span class="o">){</span>
                    <span class="c1">//保证等待和唤醒的线程只能有一个执行,需要使用同步技术</span>
                    <span class="kd">synchronized</span> <span class="o">(</span><span class="n">obj</span><span class="o">){</span>
                        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"顾客1告知老板要的包子的种类和数量"</span><span class="o">);</span>
                        <span class="c1">//调用wait方法,放弃cpu的执行,进入到WAITING状态(无限等待)</span>
                        <span class="k">try</span> <span class="o">{</span>
                            <span class="n">obj</span><span class="o">.</span><span class="na">wait</span><span class="o">();</span>
                        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
                        <span class="o">}</span>
                        <span class="c1">//唤醒之后执行的代码</span>
                        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"包子已经做好了,顾客1开吃!"</span><span class="o">);</span>
                        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"---------------------------------------"</span><span class="o">);</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}.</span><span class="na">start</span><span class="o">();</span>

        <span class="c1">// 创建一个顾客线程(消费者)</span>
        <span class="k">new</span> <span class="nf">Thread</span><span class="o">(){</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
                <span class="c1">//一直等着买包子</span>
                <span class="k">while</span><span class="o">(</span><span class="kc">true</span><span class="o">){</span>
                    <span class="c1">//保证等待和唤醒的线程只能有一个执行,需要使用同步技术</span>
                    <span class="kd">synchronized</span> <span class="o">(</span><span class="n">obj</span><span class="o">){</span>
                        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"顾客2告知老板要的包子的种类和数量"</span><span class="o">);</span>
                        <span class="c1">//调用wait方法,放弃cpu的执行,进入到WAITING状态(无限等待)</span>
                        <span class="k">try</span> <span class="o">{</span>
                            <span class="n">obj</span><span class="o">.</span><span class="na">wait</span><span class="o">();</span>
                        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
                        <span class="o">}</span>
                        <span class="c1">//唤醒之后执行的代码</span>
                        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"包子已经做好了,顾客2开吃!"</span><span class="o">);</span>
                        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"---------------------------------------"</span><span class="o">);</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}.</span><span class="na">start</span><span class="o">();</span>

        <span class="c1">//创建一个老板线程(生产者)</span>
        <span class="k">new</span> <span class="nf">Thread</span><span class="o">(){</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
                <span class="c1">//一直做包子</span>
                <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">){</span>
                    <span class="c1">//花了5秒做包子</span>
                    <span class="k">try</span> <span class="o">{</span>
                        <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">5000</span><span class="o">);</span><span class="c1">//花5秒钟做包子</span>
                    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
                    <span class="o">}</span>

                    <span class="c1">//保证等待和唤醒的线程只能有一个执行,需要使用同步技术</span>
                    <span class="kd">synchronized</span> <span class="o">(</span><span class="n">obj</span><span class="o">){</span>
                        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"老板5秒钟之后做好包子,告知顾客,可以吃包子了"</span><span class="o">);</span>
                        <span class="c1">//做好包子之后,调用notify方法,唤醒顾客吃包子</span>
                        <span class="c1">//obj.notify();//如果有多个等待线程,随机唤醒一个</span>
                        <span class="n">obj</span><span class="o">.</span><span class="na">notifyAll</span><span class="o">();</span><span class="c1">//唤醒所有等待的线程</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}.</span><span class="na">start</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h2 id="8-等待唤醒机制">8. 等待唤醒机制</h2> <h3 id="81-线程间通信">8.1 线程间通信</h3> <p><strong>概念：</strong> 多个线程在处理同一个资源，但是处理的动作（线程的任务）却不相同。</p> <p>比如：线程A用来生成包子的，线程B用来吃包子的，包子可以理解为同一资源，线程A与线程B处理的动作，一个是生产，一个是消费，那么线程A与线程B之间就存在线程通信问题。</p> <p><img src="https://blog.slienceme.cn/images/posts/20210126095549240.bmp.jpg" alt="Alt Text" /> <img src="https://blog.slienceme.cn/images/posts/20210126191215455.bmp.jpg" alt="Alt Text" /></p> <p><strong>为什么要处理线程间通信：</strong></p> <p>多个线程并发执行时, 在默认情况下CPU是随机切换线程的，当我们需要多个线程来共同完成一件任务，并且我们希望他们有规律的执行, 那么多线程之间需要一些协调通信，以此来帮我们达到多线程共同操作一份数据。</p> <p><strong>如何保证线程间通信有效利用资源：</strong></p> <p>多个线程在处理同一个资源，并且任务不同时，需要线程通信来帮助解决线程之间对同一个变量的使用或操作。 就是多个线程在操作同一份数据时， 避免对同一共享变量的争夺。也就是我们需要通过一定的手段使各个线程能有效的利用资源。而这种手段即—— <strong>等待唤醒机制。</strong></p> <h3 id="82-等待唤醒机制">8.2 等待唤醒机制</h3> <p><strong>什么是等待唤醒机制</strong></p> <p>这是多个线程间的一种<strong>协作</strong>机制。谈到线程我们经常想到的是线程间的<strong>竞争（race）</strong>，比如去争夺锁，但这并不是故事的全部，线程间也会有协作机制。就好比在公司里你和你的同事们，你们可能存在在晋升时的竞争，但更多时候你们更多是一起合作以完成某些任务。</p> <p>就是在一个线程进行了规定操作后，就进入等待状态（<strong>wait()</strong>）， 等待其他线程执行完他们的指定代码过后 再将其唤醒（<strong>notify()</strong>）;在有多个线程进行等待时， 如果需要，可以使用 notifyAll()来唤醒所有的等待线程。</p> <p>wait/notify 就是线程间的一种协作机制。</p> <p><strong>等待唤醒中的方法</strong></p> <p>等待唤醒机制就是用于解决线程间通信的问题的，使用到的3个方法的含义如下：</p> <ol> <li>wait：线程不再活动，不再参与调度，进入 wait set 中，因此不会浪费 CPU 资源，也不会去竞争锁了，这时的线程状态即是 WAITING。它还要等着别的线程执行一个<strong>特别的动作</strong>，也即是“<strong>通知（notify）</strong>”在这个对象上等待的线程从wait set 中释放出来，重新进入到调度队列（ready queue）中</li> <li>notify：则选取所通知对象的 wait set 中的一个线程释放；例如，餐馆有空位置后，等候就餐最久的顾客最先入座。</li> <li>notifyAll：则释放所通知对象的 wait set 上的全部线程。</li> </ol> <blockquote> <p>注意：</p> <p>哪怕只通知了一个等待的线程，被通知线程也不能立即恢复执行，因为它当初中断的地方是在同步块内，而此刻它已经不持有锁，所以她需要再次尝试去获取锁（很可能面临其它线程的竞争），成功后才能在当初调用 wait 方法之后的地方恢复执行。</p> <p>总结如下：</p> <ul> <li>如果能获取锁，线程就从 WAITING 状态变成 RUNNABLE 状态；</li> <li>否则，从 wait set 出来，又进入 entry set，线程就从 WAITING 状态又变成 BLOCKED 状态</li> </ul> </blockquote> <p><strong>调用wait和notify方法需要注意的细节</strong></p> <ol> <li>wait方法与notify方法必须要由同一个锁对象调用。因为：对应的锁对象可以通过notify唤醒使用同一个锁对象调用的wait方法后的线程。</li> <li>wait方法与notify方法是属于Object类的方法的。因为：锁对象可以是任意对象，而任意对象的所属类都是继承了Object类的。</li> <li>wait方法与notify方法必须要在同步代码块或者是同步函数中使用。因为：必须要通过锁对象调用这2个方法。</li> </ol> <h3 id="83-生产者与消费者问题">8.3 生产者与消费者问题</h3> <p>等待唤醒机制其实就是经典的“生产者与消费者”的问题。</p> <p>就拿生产包子消费包子来说等待唤醒机制如何有效利用资源：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">包子铺线程生产包子</span><span class="err">，</span><span class="n">吃货线程消费包子</span><span class="err">。</span><span class="n">当包子没有时</span><span class="err">（</span><span class="n">包子状态为false</span><span class="err">），</span><span class="n">吃货线程等待</span><span class="err">，</span><span class="n">包子铺线程生产包子</span><span class="err">（</span><span class="n">即包子状态为true</span><span class="err">），</span><span class="n">并通知吃货线程</span><span class="err">（</span><span class="n">解除吃货的等待状态</span><span class="err">）</span><span class="o">,</span><span class="n">因为已经有包子了</span><span class="err">，</span><span class="n">那么包子铺线程进入等待状态</span><span class="err">。</span><span class="n">接下来</span><span class="err">，</span><span class="n">吃货线程能否进一步执行则取决于锁的获取情况</span><span class="err">。</span><span class="n">如果吃货获取到锁</span><span class="err">，</span><span class="n">那么就执行吃包子动作</span><span class="err">，</span><span class="n">包子吃完</span><span class="err">（</span><span class="n">包子状态为false</span><span class="err">），</span><span class="n">并通知包子铺线程</span><span class="err">（</span><span class="n">解除包子铺的等待状态</span><span class="err">）</span><span class="o">,</span><span class="n">吃货线程进入等待</span><span class="err">。</span><span class="n">包子铺线程能否进一步执行则取决于锁的获取情况</span><span class="err">。</span>
</code></pre></div></div> <p><strong>代码演示：</strong></p> <p>包子资源类：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">BaoZi</span> <span class="o">{</span>
     <span class="nc">String</span>  <span class="n">pier</span> <span class="o">;</span>
     <span class="nc">String</span>  <span class="n">xianer</span> <span class="o">;</span>
     <span class="kt">boolean</span>  <span class="n">flag</span> <span class="o">=</span> <span class="kc">false</span> <span class="o">;</span><span class="c1">//包子资源 是否存在  包子资源状态</span>
<span class="o">}</span>
</code></pre></div></div> <p>吃货线程类：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ChiHuo</span> <span class="kd">extends</span> <span class="nc">Thread</span><span class="o">{</span>
    <span class="kd">private</span> <span class="nc">BaoZi</span> <span class="n">bz</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">ChiHuo</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span><span class="nc">BaoZi</span> <span class="n">bz</span><span class="o">){</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">bz</span> <span class="o">=</span> <span class="n">bz</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">while</span><span class="o">(</span><span class="kc">true</span><span class="o">){</span>
            <span class="kd">synchronized</span> <span class="o">(</span><span class="n">bz</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">bz</span><span class="o">.</span><span class="na">flag</span> <span class="o">==</span> <span class="kc">false</span><span class="o">){</span><span class="c1">//没包子</span>
                    <span class="k">try</span> <span class="o">{</span>
                        <span class="n">bz</span><span class="o">.</span><span class="na">wait</span><span class="o">();</span>
                    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
                    <span class="o">}</span>
                <span class="o">}</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"吃货正在吃"</span><span class="o">+</span><span class="n">bz</span><span class="o">.</span><span class="na">pier</span><span class="o">+</span><span class="n">bz</span><span class="o">.</span><span class="na">xianer</span><span class="o">+</span><span class="s">"包子"</span><span class="o">);</span>
                <span class="n">bz</span><span class="o">.</span><span class="na">flag</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                <span class="n">bz</span><span class="o">.</span><span class="na">notify</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>包子铺线程类：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">BaoZiPu</span> <span class="kd">extends</span> <span class="nc">Thread</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="nc">BaoZi</span> <span class="n">bz</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">BaoZiPu</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span><span class="nc">BaoZi</span> <span class="n">bz</span><span class="o">){</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">bz</span> <span class="o">=</span> <span class="n">bz</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">//造包子</span>
        <span class="k">while</span><span class="o">(</span><span class="kc">true</span><span class="o">){</span>
            <span class="c1">//同步</span>
            <span class="kd">synchronized</span> <span class="o">(</span><span class="n">bz</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">bz</span><span class="o">.</span><span class="na">flag</span> <span class="o">==</span> <span class="kc">true</span><span class="o">){</span><span class="c1">//包子资源  存在</span>
                    <span class="k">try</span> <span class="o">{</span>

                        <span class="n">bz</span><span class="o">.</span><span class="na">wait</span><span class="o">();</span>

                    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
                    <span class="o">}</span>
                <span class="o">}</span>

                <span class="c1">// 没有包子  造包子</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"包子铺开始做包子"</span><span class="o">);</span>
                <span class="k">if</span><span class="o">(</span><span class="n">count</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
                    <span class="c1">// 冰皮  五仁</span>
                    <span class="n">bz</span><span class="o">.</span><span class="na">pier</span> <span class="o">=</span> <span class="s">"冰皮"</span><span class="o">;</span>
                    <span class="n">bz</span><span class="o">.</span><span class="na">xianer</span> <span class="o">=</span> <span class="s">"五仁"</span><span class="o">;</span>
                <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                    <span class="c1">// 薄皮  牛肉大葱</span>
                    <span class="n">bz</span><span class="o">.</span><span class="na">pier</span> <span class="o">=</span> <span class="s">"薄皮"</span><span class="o">;</span>
                    <span class="n">bz</span><span class="o">.</span><span class="na">xianer</span> <span class="o">=</span> <span class="s">"牛肉大葱"</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="n">count</span><span class="o">++;</span>

                <span class="n">bz</span><span class="o">.</span><span class="na">flag</span><span class="o">=</span><span class="kc">true</span><span class="o">;</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"包子造好了："</span><span class="o">+</span><span class="n">bz</span><span class="o">.</span><span class="na">pier</span><span class="o">+</span><span class="n">bz</span><span class="o">.</span><span class="na">xianer</span><span class="o">);</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"吃货来吃吧"</span><span class="o">);</span>
                <span class="c1">//唤醒等待线程 （吃货）</span>
                <span class="n">bz</span><span class="o">.</span><span class="na">notify</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>测试类：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//等待唤醒案例</span>
        <span class="nc">BaoZi</span> <span class="n">bz</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BaoZi</span><span class="o">();</span>

        <span class="nc">ChiHuo</span> <span class="n">ch</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ChiHuo</span><span class="o">(</span><span class="s">"吃货"</span><span class="o">,</span><span class="n">bz</span><span class="o">);</span>
        <span class="nc">BaoZiPu</span> <span class="n">bzp</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BaoZiPu</span><span class="o">(</span><span class="s">"包子铺"</span><span class="o">,</span><span class="n">bz</span><span class="o">);</span>

        <span class="n">ch</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">bzp</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>执行效果：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">包子铺开始做包子</span>
<span class="n">包子造好了</span><span class="err">：</span><span class="n">冰皮五仁</span>
<span class="n">吃货来吃吧</span>
<span class="n">吃货正在吃冰皮五仁包子</span>
<span class="n">包子铺开始做包子</span>
<span class="n">包子造好了</span><span class="err">：</span><span class="n">薄皮牛肉大葱</span>
<span class="n">吃货来吃吧</span>
<span class="n">吃货正在吃薄皮牛肉大葱包子</span>
<span class="n">包子铺开始做包子</span>
<span class="n">包子造好了</span><span class="err">：</span><span class="n">冰皮五仁</span>
<span class="n">吃货来吃吧</span>
<span class="n">吃货正在吃冰皮五仁包子</span>
</code></pre></div></div> <hr /> <hr /> <hr /> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
    生产者(包子铺)类:是一个线程类,可以继承Thread
	设置线程任务(run):生产包子
	对包子的状态进行判断
	true:有包子
		包子铺调用wait方法进入等待状态
	false:没有包子
		包子铺生产包子
		增加一些趣味性:交替生产两种包子
			有两种状态(i%2==0)
		包子铺生产好了包子
		修改包子的状态为true有
		唤醒吃货线程,让吃货线程吃包子

	注意:
	    包子铺线程和包子线程关系--&gt;通信(互斥)
	    必须同时同步技术保证两个线程只能有一个在执行
	    锁对象必须保证唯一,可以使用包子对象作为锁对象
	    包子铺类和吃货的类就需要把包子对象作为参数传递进来
	        1.需要在成员位置创建一个包子变量
	        2.使用带参数构造方法,为这个包子变量赋值
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">BaoZiPu</span> <span class="kd">extends</span> <span class="nc">Thread</span><span class="o">{</span>
    <span class="c1">//1.需要在成员位置创建一个包子变量</span>
    <span class="kd">private</span> <span class="nc">BaoZi</span> <span class="n">bz</span><span class="o">;</span>

    <span class="c1">//2.使用带参数构造方法,为这个包子变量赋值</span>
    <span class="kd">public</span> <span class="nf">BaoZiPu</span><span class="o">(</span><span class="nc">BaoZi</span> <span class="n">bz</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">bz</span> <span class="o">=</span> <span class="n">bz</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">//设置线程任务(run):生产包子</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">//定义一个变量</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">//让包子铺一直生产包子</span>
        <span class="k">while</span><span class="o">(</span><span class="kc">true</span><span class="o">){</span>
            <span class="c1">//必须同时同步技术保证两个线程只能有一个在执行</span>
            <span class="kd">synchronized</span> <span class="o">(</span><span class="n">bz</span><span class="o">){</span>
                <span class="c1">//对包子的状态进行判断</span>
                <span class="k">if</span><span class="o">(</span><span class="n">bz</span><span class="o">.</span><span class="na">flag</span><span class="o">==</span><span class="kc">true</span><span class="o">){</span>
                    <span class="c1">//包子铺调用wait方法进入等待状态</span>
                    <span class="k">try</span> <span class="o">{</span>
                        <span class="n">bz</span><span class="o">.</span><span class="na">wait</span><span class="o">();</span>
                    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
                    <span class="o">}</span>
                <span class="o">}</span>

                <span class="c1">//被唤醒之后执行,包子铺生产包子</span>
                <span class="c1">//增加一些趣味性:交替生产两种包子</span>
                <span class="k">if</span><span class="o">(</span><span class="n">count</span><span class="o">%</span><span class="mi">2</span><span class="o">==</span><span class="mi">0</span><span class="o">){</span>
                    <span class="c1">//生产 薄皮三鲜馅包子</span>
                    <span class="n">bz</span><span class="o">.</span><span class="na">pi</span> <span class="o">=</span> <span class="s">"薄皮"</span><span class="o">;</span>
                    <span class="n">bz</span><span class="o">.</span><span class="na">xian</span> <span class="o">=</span> <span class="s">"三鲜馅"</span><span class="o">;</span>
                <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                    <span class="c1">//生产 冰皮 牛肉大葱陷</span>
                    <span class="n">bz</span><span class="o">.</span><span class="na">pi</span> <span class="o">=</span> <span class="s">"冰皮"</span><span class="o">;</span>
                    <span class="n">bz</span><span class="o">.</span><span class="na">xian</span> <span class="o">=</span> <span class="s">"牛肉大葱陷"</span><span class="o">;</span>

                <span class="o">}</span>
                <span class="n">count</span><span class="o">++;</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"包子铺正在生产:"</span><span class="o">+</span><span class="n">bz</span><span class="o">.</span><span class="na">pi</span><span class="o">+</span><span class="n">bz</span><span class="o">.</span><span class="na">xian</span><span class="o">+</span><span class="s">"包子"</span><span class="o">);</span>
                <span class="c1">//生产包子需要3秒钟</span>
                <span class="k">try</span> <span class="o">{</span>
                    <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">3000</span><span class="o">);</span>
                <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
                <span class="o">}</span>
                <span class="c1">//包子铺生产好了包子</span>
                <span class="c1">//修改包子的状态为true有</span>
                <span class="n">bz</span><span class="o">.</span><span class="na">flag</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                <span class="c1">//唤醒吃货线程,让吃货线程吃包子</span>
                <span class="n">bz</span><span class="o">.</span><span class="na">notify</span><span class="o">();</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"包子铺已经生产好了:"</span><span class="o">+</span><span class="n">bz</span><span class="o">.</span><span class="na">pi</span><span class="o">+</span><span class="n">bz</span><span class="o">.</span><span class="na">xian</span><span class="o">+</span><span class="s">"包子,吃货可以开始吃了"</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
    资源类:包子类
	设置包子的属性
		皮
		陷
		包子的状态: 有 true,没有 false
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">BaoZi</span> <span class="o">{</span>
    <span class="c1">//皮</span>
    <span class="nc">String</span> <span class="n">pi</span><span class="o">;</span>
    <span class="c1">//陷</span>
    <span class="nc">String</span> <span class="n">xian</span><span class="o">;</span>
    <span class="c1">//包子的状态: 有 true,没有 false,设置初始值为false没有包子</span>
    <span class="kt">boolean</span> <span class="n">flag</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>

<span class="o">}</span>
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
    消费者(吃货)类:是一个线程类,可以继承Thread
	设置线程任务(run):吃包子
	对包子的状态进行判断
	false:没有包子
		吃货调用wait方法进入等待状态
	true:有包子
		吃货吃包子
		吃货吃完包子
		修改包子的状态为false没有
		吃货唤醒包子铺线程,生产包子
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ChiHuo</span> <span class="kd">extends</span> <span class="nc">Thread</span><span class="o">{</span>
    <span class="c1">//1.需要在成员位置创建一个包子变量</span>
    <span class="kd">private</span> <span class="nc">BaoZi</span> <span class="n">bz</span><span class="o">;</span>

    <span class="c1">//2.使用带参数构造方法,为这个包子变量赋值</span>
    <span class="kd">public</span> <span class="nf">ChiHuo</span><span class="o">(</span><span class="nc">BaoZi</span> <span class="n">bz</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">bz</span> <span class="o">=</span> <span class="n">bz</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">//设置线程任务(run):吃包子</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">//使用死循环,让吃货一直吃包子</span>
        <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">){</span>
            <span class="c1">//必须同时同步技术保证两个线程只能有一个在执行</span>
            <span class="kd">synchronized</span> <span class="o">(</span><span class="n">bz</span><span class="o">){</span>
                <span class="c1">//对包子的状态进行判断</span>
                <span class="k">if</span><span class="o">(</span><span class="n">bz</span><span class="o">.</span><span class="na">flag</span><span class="o">==</span><span class="kc">false</span><span class="o">){</span>
                    <span class="c1">//吃货调用wait方法进入等待状态</span>
                    <span class="k">try</span> <span class="o">{</span>
                        <span class="n">bz</span><span class="o">.</span><span class="na">wait</span><span class="o">();</span>
                    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
                    <span class="o">}</span>
                <span class="o">}</span>

                <span class="c1">//被唤醒之后执行的代码,吃包子</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"吃货正在吃:"</span><span class="o">+</span><span class="n">bz</span><span class="o">.</span><span class="na">pi</span><span class="o">+</span><span class="n">bz</span><span class="o">.</span><span class="na">xian</span><span class="o">+</span><span class="s">"的包子"</span><span class="o">);</span>
                <span class="c1">//吃货吃完包子</span>
                <span class="c1">//修改包子的状态为false没有</span>
                <span class="n">bz</span><span class="o">.</span><span class="na">flag</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                <span class="c1">//吃货唤醒包子铺线程,生产包子</span>
                <span class="n">bz</span><span class="o">.</span><span class="na">notify</span><span class="o">();</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"吃货已经把:"</span><span class="o">+</span><span class="n">bz</span><span class="o">.</span><span class="na">pi</span><span class="o">+</span><span class="n">bz</span><span class="o">.</span><span class="na">xian</span><span class="o">+</span><span class="s">"的包子吃完了,包子铺开始生产包子"</span><span class="o">);</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"----------------------------------------------------"</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
    测试类:
	包含main方法,程序执行的入口,启动程序
	创建包子对象;
	创建包子铺线程,开启,生产包子;
	创建吃货线程,开启,吃包子;
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//创建包子对象;</span>
        <span class="nc">BaoZi</span> <span class="n">bz</span> <span class="o">=</span><span class="k">new</span> <span class="nc">BaoZi</span><span class="o">();</span>
        <span class="c1">//创建包子铺线程,开启,生产包子;</span>
        <span class="k">new</span> <span class="nf">BaoZiPu</span><span class="o">(</span><span class="n">bz</span><span class="o">).</span><span class="na">start</span><span class="o">();</span>
        <span class="c1">//创建吃货线程,开启,吃包子;</span>
        <span class="k">new</span> <span class="nf">ChiHuo</span><span class="o">(</span><span class="n">bz</span><span class="o">).</span><span class="na">start</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h2 id="9-线程池">9. 线程池</h2> <h3 id="91-线程池思想概述">9.1 线程池思想概述</h3> <p><img src="https://blog.slienceme.cn/images/posts/20210126095559156.jpg" alt="Alt Text" /></p> <p>我们使用线程的时候就去创建一个线程，这样实现起来非常简便，但是就会有一个问题：</p> <p>如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。</p> <p>那么有没有一种办法使得线程可以复用，就是执行完一个任务，并不被销毁，而是可以继续执行其他的任务？</p> <p>在Java中可以通过线程池来达到这样的效果。今天我们就来详细讲解一下Java的线程池。</p> <h3 id="92-线程池概念">9.2 线程池概念</h3> <ul> <li><strong>线程池：</strong>其实就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源。</li> </ul> <p>由于线程池中有很多操作都是与优化资源相关的，我们在这里就不多赘述。我们通过一张图来了解线程池的工作原理：</p> <p><img src="https://blog.slienceme.cn/images/posts/20210126095606961.bmp.jpg" alt="Alt Text" /> <img src="https://blog.slienceme.cn/images/posts/20210126192758971.bmp.jpg" alt="Alt Text" /></p> <p>合理利用线程池能够带来三个好处：</p> <ol> <li>降低资源消耗。减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。</li> <li>提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li> <li>提高线程的可管理性。可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。</li> </ol> <h3 id="93-线程池的使用">9.3 线程池的使用</h3> <p>Java里面线程池的顶级接口是<code class="language-plaintext highlighter-rouge">java.util.concurrent.Executor</code>，但是严格意义上讲<code class="language-plaintext highlighter-rouge">Executor</code>并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是<code class="language-plaintext highlighter-rouge">java.util.concurrent.ExecutorService</code>。</p> <p>要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，很有可能配置的线程池不是较优的，因此在<code class="language-plaintext highlighter-rouge">java.util.concurrent.Executors</code>线程工厂类里面提供了一些静态工厂，生成一些常用的线程池。官方建议使用Executors工程类来创建线程池对象。</p> <p>Executors类中有个创建线程池的方法如下：</p> <ul> <li><code class="language-plaintext highlighter-rouge">public static ExecutorService newFixedThreadPool(int nThreads)</code>：返回线程池对象。(创建的是有界线程池,也就是池中的线程个数可以指定最大数量)</li> </ul> <p>获取到了一个线程池ExecutorService 对象，那么怎么使用呢，在这里定义了一个使用线程池对象的方法如下：</p> <ul> <li> <p><code class="language-plaintext highlighter-rouge">public Future&lt;?&gt; submit(Runnable task)</code>:获取线程池中的某一个线程对象，并执行</p> <blockquote> <p>Future接口：用来记录线程任务执行完毕后产生的结果。线程池创建与使用。</p> </blockquote> </li> </ul> <p>使用线程池中线程对象的步骤：</p> <ol> <li>创建线程池对象。</li> <li>创建Runnable接口子类对象。(task)</li> <li>提交Runnable接口子类对象。(take task)</li> <li>关闭线程池(一般不做)。</li> </ol> <p>Runnable实现类代码：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyRunnable</span> <span class="kd">implements</span> <span class="nc">Runnable</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"我要一个教练"</span><span class="o">);</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">2000</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"教练来了： "</span> <span class="o">+</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"教我游泳,交完后，教练回到了游泳池"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>线程池测试类：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ThreadPoolDemo</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 创建线程池对象</span>
        <span class="nc">ExecutorService</span> <span class="n">service</span> <span class="o">=</span> <span class="nc">Executors</span><span class="o">.</span><span class="na">newFixedThreadPool</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span><span class="c1">//包含2个线程对象</span>
        <span class="c1">// 创建Runnable实例对象</span>
        <span class="nc">MyRunnable</span> <span class="n">r</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MyRunnable</span><span class="o">();</span>

        <span class="c1">//自己创建线程对象的方式</span>
        <span class="c1">// Thread t = new Thread(r);</span>
        <span class="c1">// t.start(); ---&gt; 调用MyRunnable中的run()</span>

        <span class="c1">// 从线程池中获取线程对象,然后调用MyRunnable中的run()</span>
        <span class="n">service</span><span class="o">.</span><span class="na">submit</span><span class="o">(</span><span class="n">r</span><span class="o">);</span>
        <span class="c1">// 再获取个线程对象，调用MyRunnable中的run()</span>
        <span class="n">service</span><span class="o">.</span><span class="na">submit</span><span class="o">(</span><span class="n">r</span><span class="o">);</span>
        <span class="n">service</span><span class="o">.</span><span class="na">submit</span><span class="o">(</span><span class="n">r</span><span class="o">);</span>
        <span class="c1">// 注意：submit方法调用结束后，程序并不终止，是因为线程池控制了线程的关闭。</span>
        <span class="c1">// 将使用完的线程又归还到了线程池中</span>
        <span class="c1">// 关闭线程池</span>
        <span class="c1">//service.shutdown();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
    2.创建一个类,实现Runnable接口,重写run方法,设置线程任务
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RunnableImpl</span> <span class="kd">implements</span> <span class="nc">Runnable</span><span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()+</span><span class="s">"创建了一个新的线程执行"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <hr /> <hr /> <hr /> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.concurrent.ExecutorService</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.concurrent.Executors</span><span class="o">;</span>

<span class="cm">/*
    线程池:JDK1.5之后提供的
    java.util.concurrent.Executors:线程池的工厂类,用来生成线程池
    Executors类中的静态方法:
        static ExecutorService newFixedThreadPool(int nThreads) 创建一个可重用固定线程数的线程池
        参数:
            int nThreads:创建线程池中包含的线程数量
        返回值:
            ExecutorService接口,返回的是ExecutorService接口的实现类对象,我们可以使用ExecutorService接口接收(面向接口编程)
    java.util.concurrent.ExecutorService:线程池接口
        用来从线程池中获取线程,调用start方法,执行线程任务
            submit(Runnable task) 提交一个 Runnable 任务用于执行
        关闭/销毁线程池的方法
            void shutdown()
    线程池的使用步骤:
        1.使用线程池的工厂类Executors里边提供的静态方法newFixedThreadPool生产一个指定线程数量的线程池
        2.创建一个类,实现Runnable接口,重写run方法,设置线程任务
        3.调用ExecutorService中的方法submit,传递线程任务(实现类),开启线程,执行run方法
        4.调用ExecutorService中的方法shutdown销毁线程池(不建议执行)
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo01ThreadPool</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//1.使用线程池的工厂类Executors里边提供的静态方法newFixedThreadPool生产一个指定线程数量的线程池</span>
        <span class="nc">ExecutorService</span> <span class="n">es</span> <span class="o">=</span> <span class="nc">Executors</span><span class="o">.</span><span class="na">newFixedThreadPool</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
        <span class="c1">//3.调用ExecutorService中的方法submit,传递线程任务(实现类),开启线程,执行run方法</span>
        <span class="n">es</span><span class="o">.</span><span class="na">submit</span><span class="o">(</span><span class="k">new</span> <span class="nc">RunnableImpl</span><span class="o">());</span><span class="c1">//pool-1-thread-1创建了一个新的线程执行</span>
        <span class="c1">//线程池会一直开启,使用完了线程,会自动把线程归还给线程池,线程可以继续使用</span>
        <span class="n">es</span><span class="o">.</span><span class="na">submit</span><span class="o">(</span><span class="k">new</span> <span class="nc">RunnableImpl</span><span class="o">());</span><span class="c1">//pool-1-thread-1创建了一个新的线程执行</span>
        <span class="n">es</span><span class="o">.</span><span class="na">submit</span><span class="o">(</span><span class="k">new</span> <span class="nc">RunnableImpl</span><span class="o">());</span><span class="c1">//pool-1-thread-2创建了一个新的线程执行</span>

        <span class="c1">//4.调用ExecutorService中的方法shutdown销毁线程池(不建议执行)</span>
        <span class="n">es</span><span class="o">.</span><span class="na">shutdown</span><span class="o">();</span>

        <span class="n">es</span><span class="o">.</span><span class="na">submit</span><span class="o">(</span><span class="k">new</span> <span class="nc">RunnableImpl</span><span class="o">());</span><span class="c1">//抛异常,线程池都没有了,就不能获取线程了</span>
    <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div> <h2 id="10-lambda表达式">10. Lambda表达式</h2> <h3 id="101-函数式编程思想概述">10.1 函数式编程思想概述</h3> <p><img src="https://blog.slienceme.cn/images/posts/20210126095618866.png" alt="Alt Text" /></p> <p>在数学中，<strong>函数</strong>就是有输入量、输出量的一套计算方案，也就是“拿什么东西做什么事情”。相对而言，面向对象过分强调“必须通过对象的形式来做事情”，而函数式思想则尽量忽略面向对象的复杂语法——<strong>强调做什么，而不是以什么形式做</strong>。</p> <p>面向对象的思想:</p> <p>​ 做一件事情,找一个能解决这个事情的对象,调用对象的方法,完成事情.</p> <p>函数式编程思想:</p> <p>​ 只要能获取到结果,谁去做的,怎么做的都不重要,重视的是结果,不重视过程</p> <h3 id="102-冗余的runnable代码">10.2 冗余的Runnable代码</h3> <h4 id="传统写法">传统写法</h4> <p>当需要启动一个线程去完成任务时，通常会通过<code class="language-plaintext highlighter-rouge">java.lang.Runnable</code>接口来定义任务内容，并使用<code class="language-plaintext highlighter-rouge">java.lang.Thread</code>类来启动该线程。代码如下：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo01Runnable</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    	<span class="c1">// 匿名内部类</span>
		<span class="nc">Runnable</span> <span class="n">task</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Runnable</span><span class="o">()</span> <span class="o">{</span>
			<span class="nd">@Override</span>
			<span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span> <span class="c1">// 覆盖重写抽象方法</span>
				<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"多线程任务执行！"</span><span class="o">);</span>
			<span class="o">}</span>
		<span class="o">};</span>
		<span class="k">new</span> <span class="nf">Thread</span><span class="o">(</span><span class="n">task</span><span class="o">).</span><span class="na">start</span><span class="o">();</span> <span class="c1">// 启动线程</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>本着“一切皆对象”的思想，这种做法是无可厚非的：首先创建一个<code class="language-plaintext highlighter-rouge">Runnable</code>接口的匿名内部类对象来指定任务内容，再将其交给一个线程来启动。</p> <h4 id="代码分析">代码分析</h4> <p>对于<code class="language-plaintext highlighter-rouge">Runnable</code>的匿名内部类用法，可以分析出几点内容：</p> <ul> <li><code class="language-plaintext highlighter-rouge">Thread</code>类需要<code class="language-plaintext highlighter-rouge">Runnable</code>接口作为参数，其中的抽象<code class="language-plaintext highlighter-rouge">run</code>方法是用来指定线程任务内容的核心；</li> <li>为了指定<code class="language-plaintext highlighter-rouge">run</code>的方法体，<strong>不得不</strong>需要<code class="language-plaintext highlighter-rouge">Runnable</code>接口的实现类；</li> <li>为了省去定义一个<code class="language-plaintext highlighter-rouge">RunnableImpl</code>实现类的麻烦，<strong>不得不</strong>使用匿名内部类；</li> <li>必须覆盖重写抽象<code class="language-plaintext highlighter-rouge">run</code>方法，所以方法名称、方法参数、方法返回值<strong>不得不</strong>再写一遍，且不能写错；</li> <li>而实际上，<strong>似乎只有方法体才是关键所在</strong>。</li> </ul> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
    使用实现Runnable接口的方式实现多线程程序
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo01Runnable</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//创建Runnable接口的实现类对象</span>
        <span class="nc">RunnableImpl</span> <span class="n">run</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">RunnableImpl</span><span class="o">();</span>
        <span class="c1">//创建Thread类对象,构造方法中传递Runnable接口的实现类</span>
        <span class="nc">Thread</span> <span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="n">run</span><span class="o">);</span>
        <span class="c1">//调用start方法开启新线程,执行run方法</span>
        <span class="n">t</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>

        <span class="c1">//简化代码,使用匿名内部类,实现多线程程序</span>
        <span class="nc">Runnable</span> <span class="n">r</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Runnable</span><span class="o">(){</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()+</span><span class="s">" 新线程创建了"</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">};</span>
        <span class="k">new</span> <span class="nf">Thread</span><span class="o">(</span><span class="n">r</span><span class="o">).</span><span class="na">start</span><span class="o">();</span>

        <span class="c1">//简化代码</span>
        <span class="k">new</span> <span class="nf">Thread</span><span class="o">(</span><span class="k">new</span> <span class="nc">Runnable</span><span class="o">(){</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()+</span><span class="s">" 新线程创建了"</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}).</span><span class="na">start</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h3 id="103-编程思想转换">10.3 编程思想转换</h3> <h4 id="做什么而不是怎么做">做什么，而不是怎么做</h4> <p>我们真的希望创建一个匿名内部类对象吗？不。我们只是为了做这件事情而<strong>不得不</strong>创建一个对象。我们真正希望做的事情是：将<code class="language-plaintext highlighter-rouge">run</code>方法体内的代码传递给<code class="language-plaintext highlighter-rouge">Thread</code>类知晓。</p> <p><strong>传递一段代码</strong>——这才是我们真正的目的。而创建对象只是受限于面向对象语法而不得不采取的一种手段方式。那，有没有更加简单的办法？如果我们将关注点从“怎么做”回归到“做什么”的本质上，就会发现只要能够更好地达到目的，过程与形式其实并不重要。</p> <h4 id="生活举例">生活举例</h4> <p><img src="https://blog.slienceme.cn/images/posts/2021012609562522.png" alt="Alt Text" /></p> <p>当我们需要从北京到上海时，可以选择高铁、汽车、骑行或是徒步。我们的真正目的是到达上海，而如何才能到达上海的形式并不重要，所以我们一直在探索有没有比高铁更好的方式——搭乘飞机。</p> <p><img src="https://blog.slienceme.cn/images/posts/20210126095633172.png" alt="Alt Text" /></p> <p>而现在这种飞机（甚至是飞船）已经诞生：2014年3月Oracle所发布的Java 8（JDK 1.8）中，加入了<strong>Lambda表达式</strong>的重量级新特性，为我们打开了新世界的大门。</p> <h3 id="104-体验lambda的更优写法">10.4 体验Lambda的更优写法</h3> <p>借助Java 8的全新语法，上述<code class="language-plaintext highlighter-rouge">Runnable</code>接口的匿名内部类写法可以通过更简单的Lambda表达式达到等效：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo02LambdaRunnable</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">new</span> <span class="nf">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"多线程任务执行！"</span><span class="o">)).</span><span class="na">start</span><span class="o">();</span> <span class="c1">// 启动线程</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>这段代码和刚才的执行效果是完全一样的，可以在1.8或更高的编译级别下通过。从代码的语义中可以看出：我们启动了一个线程，而线程任务的内容以一种更加简洁的形式被指定。</p> <p>不再有“不得不创建接口对象”的束缚，不再有“抽象方法覆盖重写”的负担，就是这么简单！</p> <h3 id="105-回顾匿名内部类">10.5 回顾匿名内部类</h3> <p>Lambda是怎样击败面向对象的？在上例中，核心代码其实只是如下所示的内容：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">()</span> <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"多线程任务执行！"</span><span class="o">)</span>
</code></pre></div></div> <p>为了理解Lambda的语义，我们需要从传统的代码起步。</p> <h4 id="使用实现类">使用实现类</h4> <p>要启动一个线程，需要创建一个<code class="language-plaintext highlighter-rouge">Thread</code>类的对象并调用<code class="language-plaintext highlighter-rouge">start</code>方法。而为了指定线程执行的内容，需要调用<code class="language-plaintext highlighter-rouge">Thread</code>类的构造方法：</p> <ul> <li><code class="language-plaintext highlighter-rouge">public Thread(Runnable target)</code></li> </ul> <p>为了获取<code class="language-plaintext highlighter-rouge">Runnable</code>接口的实现对象，可以为该接口定义一个实现类<code class="language-plaintext highlighter-rouge">RunnableImpl</code>：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">RunnableImpl</span> <span class="kd">implements</span> <span class="nc">Runnable</span> <span class="o">{</span>
	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"多线程任务执行！"</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>然后创建该实现类的对象作为<code class="language-plaintext highlighter-rouge">Thread</code>类的构造参数：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo03ThreadInitParam</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
		<span class="nc">Runnable</span> <span class="n">task</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">RunnableImpl</span><span class="o">();</span>
		<span class="k">new</span> <span class="nf">Thread</span><span class="o">(</span><span class="n">task</span><span class="o">).</span><span class="na">start</span><span class="o">();</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h4 id="使用匿名内部类">使用匿名内部类</h4> <p>这个<code class="language-plaintext highlighter-rouge">RunnableImpl</code>类只是为了实现<code class="language-plaintext highlighter-rouge">Runnable</code>接口而存在的，而且仅被使用了唯一一次，所以使用匿名内部类的语法即可省去该类的单独定义，即匿名内部类：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo04ThreadNameless</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">new</span> <span class="nf">Thread</span><span class="o">(</span><span class="k">new</span> <span class="nc">Runnable</span><span class="o">()</span> <span class="o">{</span>
			<span class="nd">@Override</span>
			<span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
				<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"多线程任务执行！"</span><span class="o">);</span>
			<span class="o">}</span>
		<span class="o">}).</span><span class="na">start</span><span class="o">();</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h4 id="匿名内部类的好处与弊端">匿名内部类的好处与弊端</h4> <p>一方面，匿名内部类可以帮我们<strong>省去实现类的定义</strong>；另一方面，匿名内部类的语法——<strong>确实太复杂了！</strong></p> <h4 id="语义分析">语义分析</h4> <p>仔细分析该代码中的语义，<code class="language-plaintext highlighter-rouge">Runnable</code>接口只有一个<code class="language-plaintext highlighter-rouge">run</code>方法的定义：</p> <ul> <li><code class="language-plaintext highlighter-rouge">public abstract void run();</code></li> </ul> <p>即制定了一种做事情的方案（其实就是一个函数）：</p> <ul> <li><strong>无参数</strong>：不需要任何条件即可执行该方案。</li> <li><strong>无返回值</strong>：该方案不产生任何结果。</li> <li><strong>代码块</strong>（方法体）：该方案的具体执行步骤。</li> </ul> <p>同样的语义体现在<code class="language-plaintext highlighter-rouge">Lambda</code>语法中，要更加简单：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">()</span> <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"多线程任务执行！"</span><span class="o">)</span>
</code></pre></div></div> <ul> <li>前面的一对小括号即<code class="language-plaintext highlighter-rouge">run</code>方法的参数（无），代表不需要任何条件；</li> <li>中间的一个箭头代表将前面的参数传递给后面的代码；</li> <li>后面的输出语句即业务逻辑代码。</li> </ul> <h3 id="106-lambda标准格式">10.6 Lambda标准格式</h3> <p>Lambda省去面向对象的条条框框，格式由<strong>3个部分</strong>组成：</p> <ul> <li>一些参数</li> <li>一个箭头</li> <li>一段代码</li> </ul> <p>Lambda表达式的<strong>标准格式</strong>为：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(参数类型 参数名称) -&gt; { 代码语句 }
</code></pre></div></div> <p>格式说明：</p> <ul> <li>小括号内的语法与传统方法参数列表一致：无参数则留空；多个参数则用逗号分隔。</li> <li><code class="language-plaintext highlighter-rouge">-&gt;</code>是新引入的语法格式，代表指向动作。</li> <li>大括号内的语法与传统方法体要求基本一致。</li> </ul> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
    创建Runnable接口的实现类,重写run方法,设置线程任务
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RunnableImpl</span> <span class="kd">implements</span> <span class="nc">Runnable</span><span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()+</span><span class="s">" 新线程创建了"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
    Lambda表达式的标准格式:
        由三部分组成:
            a.一些参数
            b.一个箭头
            c.一段代码
        格式:
            (参数列表) -&gt; {一些重写方法的代码};
        解释说明格式:
            ():接口中抽象方法的参数列表,没有参数,就空着;有参数就写出参数,多个参数使用逗号分隔
            -&gt;:传递的意思,把参数传递给方法体{}
            {}:重写接口的抽象方法的方法体
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo02Lambda</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//使用匿名内部类的方式,实现多线程</span>
        <span class="k">new</span> <span class="nf">Thread</span><span class="o">(</span><span class="k">new</span> <span class="nc">Runnable</span><span class="o">(){</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()+</span><span class="s">" 新线程创建了"</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}).</span><span class="na">start</span><span class="o">();</span>

        <span class="c1">//使用Lambda表达式,实现多线程</span>
        <span class="k">new</span> <span class="nf">Thread</span><span class="o">(()-&gt;{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()+</span><span class="s">" 新线程创建了"</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">).</span><span class="na">start</span><span class="o">();</span>

        <span class="c1">//优化省略Lambda</span>
        <span class="k">new</span> <span class="nf">Thread</span><span class="o">(()-&gt;</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()+</span><span class="s">" 新线程创建了"</span><span class="o">)).</span><span class="na">start</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h3 id="107-练习使用lambda标准格式无参无返回">10.7 练习：使用Lambda标准格式（无参无返回）</h3> <h4 id="题目">题目</h4> <p>给定一个厨子<code class="language-plaintext highlighter-rouge">Cook</code>接口，内含唯一的抽象方法<code class="language-plaintext highlighter-rouge">makeFood</code>，且无参数、无返回值。如下：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Cook</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">makeFood</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div> <p>在下面的代码中，请使用Lambda的<strong>标准格式</strong>调用<code class="language-plaintext highlighter-rouge">invokeCook</code>方法，打印输出“吃饭啦！”字样：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo05InvokeCook</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// TODO 请在此使用Lambda【标准格式】调用invokeCook方法</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">invokeCook</span><span class="o">(</span><span class="nc">Cook</span> <span class="n">cook</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">cook</span><span class="o">.</span><span class="na">makeFood</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h4 id="解答">解答</h4> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">invokeCook</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
      	<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"吃饭啦！"</span><span class="o">);</span>
    <span class="o">});</span>
<span class="o">}</span>
</code></pre></div></div> <blockquote> <p>备注：小括号代表<code class="language-plaintext highlighter-rouge">Cook</code>接口<code class="language-plaintext highlighter-rouge">makeFood</code>抽象方法的参数为空，大括号代表<code class="language-plaintext highlighter-rouge">makeFood</code>的方法体。</p> </blockquote> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
    定一个厨子Cook接口，内含唯一的抽象方法makeFood
 */</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Cook</span> <span class="o">{</span>
    <span class="c1">//定义无参数无返回值的方法makeFood</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">makeFood</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
    需求:
        给定一个厨子Cook接口，内含唯一的抽象方法makeFood，且无参数、无返回值。
        使用Lambda的标准格式调用invokeCook方法，打印输出“吃饭啦！”字样
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo01Cook</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//调用invokeCook方法,参数是Cook接口,传递Cook接口的匿名内部类对象</span>
        <span class="n">invokeCook</span><span class="o">(</span><span class="k">new</span> <span class="nc">Cook</span><span class="o">()</span> <span class="o">{</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">makeFood</span><span class="o">()</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"吃饭了"</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">});</span>

        <span class="c1">//使用Lambda表达式,简化匿名内部类的书写</span>
        <span class="n">invokeCook</span><span class="o">(()-&gt;{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"吃饭了"</span><span class="o">);</span>
        <span class="o">});</span>

        <span class="c1">//优化省略Lambda</span>
        <span class="n">invokeCook</span><span class="o">(()-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"吃饭了"</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="c1">//定义一个方法,参数传递Cook接口,方法内部调用Cook接口中的方法makeFood</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">invokeCook</span><span class="o">(</span><span class="nc">Cook</span> <span class="n">cook</span><span class="o">){</span>
        <span class="n">cook</span><span class="o">.</span><span class="na">makeFood</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div> <h3 id="108-lambda的参数和返回值">10.8 Lambda的参数和返回值</h3> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>需求:
    使用数组存储多个Person对象
    对数组中的Person对象使用Arrays的sort方法通过年龄进行升序排序
</code></pre></div></div> <p>下面举例演示<code class="language-plaintext highlighter-rouge">java.util.Comparator&lt;T&gt;</code>接口的使用场景代码，其中的抽象方法定义为：</p> <ul> <li><code class="language-plaintext highlighter-rouge">public abstract int compare(T o1, T o2);</code></li> </ul> <p>当需要对一个对象数组进行排序时，<code class="language-plaintext highlighter-rouge">Arrays.sort</code>方法需要一个<code class="language-plaintext highlighter-rouge">Comparator</code>接口实例来指定排序的规则。假设有一个<code class="language-plaintext highlighter-rouge">Person</code>类，含有<code class="language-plaintext highlighter-rouge">String name</code>和<code class="language-plaintext highlighter-rouge">int age</code>两个成员变量：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span> 
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>
    
    <span class="c1">// 省略构造器、toString方法与Getter Setter </span>
<span class="o">}</span>
</code></pre></div></div> <h4 id="传统写法-1">传统写法</h4> <p>如果使用传统的代码对<code class="language-plaintext highlighter-rouge">Person[]</code>数组进行排序，写法如下：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Comparator</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo06Comparator</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
      	<span class="c1">// 本来年龄乱序的对象数组</span>
        <span class="nc">Person</span><span class="o">[]</span> <span class="n">array</span> <span class="o">=</span> <span class="o">{</span>
        	<span class="k">new</span> <span class="nf">Person</span><span class="o">(</span><span class="s">"古力娜扎"</span><span class="o">,</span> <span class="mi">19</span><span class="o">),</span>
        	<span class="k">new</span> <span class="nf">Person</span><span class="o">(</span><span class="s">"迪丽热巴"</span><span class="o">,</span> <span class="mi">18</span><span class="o">),</span>
       		<span class="k">new</span> <span class="nf">Person</span><span class="o">(</span><span class="s">"马尔扎哈"</span><span class="o">,</span> <span class="mi">20</span><span class="o">)</span> <span class="o">};</span>

      	<span class="c1">// 匿名内部类</span>
        <span class="nc">Comparator</span><span class="o">&lt;</span><span class="nc">Person</span><span class="o">&gt;</span> <span class="n">comp</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Comparator</span><span class="o">&lt;</span><span class="nc">Person</span><span class="o">&gt;()</span> <span class="o">{</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="nc">Person</span> <span class="n">o1</span><span class="o">,</span> <span class="nc">Person</span> <span class="n">o2</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">o1</span><span class="o">.</span><span class="na">getAge</span><span class="o">()</span> <span class="o">-</span> <span class="n">o2</span><span class="o">.</span><span class="na">getAge</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">};</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">array</span><span class="o">,</span> <span class="n">comp</span><span class="o">);</span> <span class="c1">// 第二个参数为排序规则，即Comparator接口实例</span>

        <span class="k">for</span> <span class="o">(</span><span class="nc">Person</span> <span class="n">person</span> <span class="o">:</span> <span class="n">array</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">person</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>这种做法在面向对象的思想中，似乎也是“理所当然”的。其中<code class="language-plaintext highlighter-rouge">Comparator</code>接口的实例（使用了匿名内部类）代表了“按照年龄从小到大”的排序规则。</p> <h4 id="代码分析-1">代码分析</h4> <p>下面我们来搞清楚上述代码真正要做什么事情。</p> <ul> <li>为了排序，<code class="language-plaintext highlighter-rouge">Arrays.sort</code>方法需要排序规则，即<code class="language-plaintext highlighter-rouge">Comparator</code>接口的实例，抽象方法<code class="language-plaintext highlighter-rouge">compare</code>是关键；</li> <li>为了指定<code class="language-plaintext highlighter-rouge">compare</code>的方法体，<strong>不得不</strong>需要<code class="language-plaintext highlighter-rouge">Comparator</code>接口的实现类；</li> <li>为了省去定义一个<code class="language-plaintext highlighter-rouge">ComparatorImpl</code>实现类的麻烦，<strong>不得不</strong>使用匿名内部类；</li> <li>必须覆盖重写抽象<code class="language-plaintext highlighter-rouge">compare</code>方法，所以方法名称、方法参数、方法返回值<strong>不得不</strong>再写一遍，且不能写错；</li> <li>实际上，<strong>只有参数和方法体才是关键</strong>。</li> </ul> <h4 id="lambda写法">Lambda写法</h4> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo07ComparatorLambda</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Person</span><span class="o">[]</span> <span class="n">array</span> <span class="o">=</span> <span class="o">{</span>
          	<span class="k">new</span> <span class="nf">Person</span><span class="o">(</span><span class="s">"古力娜扎"</span><span class="o">,</span> <span class="mi">19</span><span class="o">),</span>
          	<span class="k">new</span> <span class="nf">Person</span><span class="o">(</span><span class="s">"迪丽热巴"</span><span class="o">,</span> <span class="mi">18</span><span class="o">),</span>
          	<span class="k">new</span> <span class="nf">Person</span><span class="o">(</span><span class="s">"马尔扎哈"</span><span class="o">,</span> <span class="mi">20</span><span class="o">)</span> <span class="o">};</span>

        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">array</span><span class="o">,</span> <span class="o">(</span><span class="nc">Person</span> <span class="n">a</span><span class="o">,</span> <span class="nc">Person</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
          	<span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="na">getAge</span><span class="o">()</span> <span class="o">-</span> <span class="n">b</span><span class="o">.</span><span class="na">getAge</span><span class="o">();</span>
        <span class="o">});</span>

        <span class="k">for</span> <span class="o">(</span><span class="nc">Person</span> <span class="n">person</span> <span class="o">:</span> <span class="n">array</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">person</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h3 id="109-练习使用lambda标准格式有参有返回">10.9 练习：使用Lambda标准格式（有参有返回）</h3> <h4 id="题目-1">题目</h4> <p>给定一个计算器<code class="language-plaintext highlighter-rouge">Calculator</code>接口，内含抽象方法<code class="language-plaintext highlighter-rouge">calc</code>可以将两个int数字相加得到和值：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Calculator</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="nf">calc</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">b</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div> <p>在下面的代码中，请使用Lambda的<strong>标准格式</strong>调用<code class="language-plaintext highlighter-rouge">invokeCalc</code>方法，完成120和130的相加计算：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo08InvokeCalc</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// TODO 请在此使用Lambda【标准格式】调用invokeCalc方法来计算120+130的结果ß</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">invokeCalc</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">b</span><span class="o">,</span> <span class="nc">Calculator</span> <span class="n">calculator</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">calculator</span><span class="o">.</span><span class="na">calc</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"结果是："</span> <span class="o">+</span> <span class="n">result</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h4 id="解答-1">解答</h4> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">invokeCalc</span><span class="o">(</span><span class="mi">120</span><span class="o">,</span> <span class="mi">130</span><span class="o">,</span> <span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
      	<span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">;</span>
    <span class="o">});</span>
<span class="o">}</span>
</code></pre></div></div> <blockquote> <p>备注：小括号代表<code class="language-plaintext highlighter-rouge">Calculator</code>接口<code class="language-plaintext highlighter-rouge">calc</code>抽象方法的参数，大括号代表<code class="language-plaintext highlighter-rouge">calc</code>的方法体。</p> </blockquote> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Person</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nf">Person</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">int</span> <span class="n">age</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="n">age</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"Person{"</span> <span class="o">+</span>
                <span class="s">"name='"</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="sc">'\''</span> <span class="o">+</span>
                <span class="s">", age="</span> <span class="o">+</span> <span class="n">age</span> <span class="o">+</span>
                <span class="sc">'}'</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getName</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setName</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getAge</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">age</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setAge</span><span class="o">(</span><span class="kt">int</span> <span class="n">age</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="n">age</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="cm">/*
    Lambda表达式有参数有返回值的练习
    需求:
        使用数组存储多个Person对象
        对数组中的Person对象使用Arrays的sort方法通过年龄进行升序排序
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo01Arrays</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//使用数组存储多个Person对象</span>
        <span class="nc">Person</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="o">{</span>
                <span class="k">new</span> <span class="nf">Person</span><span class="o">(</span><span class="s">"柳岩"</span><span class="o">,</span><span class="mi">38</span><span class="o">),</span>
                <span class="k">new</span> <span class="nf">Person</span><span class="o">(</span><span class="s">"迪丽热巴"</span><span class="o">,</span><span class="mi">18</span><span class="o">),</span>
                <span class="k">new</span> <span class="nf">Person</span><span class="o">(</span><span class="s">"古力娜扎"</span><span class="o">,</span><span class="mi">19</span><span class="o">)</span>
        <span class="o">};</span>

        <span class="c1">//对数组中的Person对象使用Arrays的sort方法通过年龄进行升序(前边-后边)排序</span>
        <span class="cm">/*Arrays.sort(arr, new Comparator&lt;Person&gt;() {
            @Override
            public int compare(Person o1, Person o2) {
                return o1.getAge()-o2.getAge();
            }
        });*/</span>

        <span class="c1">//使用Lambda表达式,简化匿名内部类</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">arr</span><span class="o">,(</span><span class="nc">Person</span> <span class="n">o1</span><span class="o">,</span> <span class="nc">Person</span> <span class="n">o2</span><span class="o">)-&gt;{</span>
            <span class="k">return</span> <span class="n">o1</span><span class="o">.</span><span class="na">getAge</span><span class="o">()-</span><span class="n">o2</span><span class="o">.</span><span class="na">getAge</span><span class="o">();</span>
        <span class="o">});</span>

        <span class="c1">//优化省略Lambda</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">arr</span><span class="o">,(</span><span class="n">o1</span><span class="o">,</span> <span class="n">o2</span><span class="o">)-&gt;</span><span class="n">o1</span><span class="o">.</span><span class="na">getAge</span><span class="o">()-</span><span class="n">o2</span><span class="o">.</span><span class="na">getAge</span><span class="o">());</span>

        <span class="c1">//遍历数组</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">Person</span> <span class="n">p</span> <span class="o">:</span> <span class="n">arr</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">p</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h3 id="1010-lambda省略格式">10.10 Lambda省略格式</h3> <h4 id="可推导即可省略">可推导即可省略</h4> <p>Lambda强调的是“做什么”而不是“怎么做”，所以凡是可以根据上下文推导得知的信息，都可以省略。例如上例还可以使用Lambda的省略写法：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
  	<span class="n">invokeCalc</span><span class="o">(</span><span class="mi">120</span><span class="o">,</span> <span class="mi">130</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div> <h4 id="省略规则">省略规则</h4> <p>在Lambda标准格式的基础上，使用省略写法的规则为：</p> <ol> <li>小括号内参数的类型可以省略；</li> <li>如果小括号内<strong>有且仅有一个参</strong>，则小括号可以省略；</li> <li>如果大括号内<strong>有且仅有一个语句</strong>，则无论是否有返回值，都可以省略大括号、return关键字及语句分号。</li> </ol> <blockquote> <p>备注：掌握这些省略规则后，请对应地回顾本章开头的多线程案例。</p> </blockquote> <h3 id="1011-练习使用lambda省略格式">10.11 练习：使用Lambda省略格式</h3> <h4 id="题目-2">题目</h4> <p>仍然使用前文含有唯一<code class="language-plaintext highlighter-rouge">makeFood</code>抽象方法的厨子<code class="language-plaintext highlighter-rouge">Cook</code>接口，在下面的代码中，请使用Lambda的<strong>省略格式</strong>调用<code class="language-plaintext highlighter-rouge">invokeCook</code>方法，打印输出“吃饭啦！”字样：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo09InvokeCook</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// TODO 请在此使用Lambda【省略格式】调用invokeCook方法</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">invokeCook</span><span class="o">(</span><span class="nc">Cook</span> <span class="n">cook</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">cook</span><span class="o">.</span><span class="na">makeFood</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h4 id="解答-2">解答</h4> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
  	<span class="n">invokeCook</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"吃饭啦！"</span><span class="o">));</span>
<span class="o">}</span>
</code></pre></div></div> <h3 id="1012-lambda的使用前提">10.12 Lambda的使用前提</h3> <p>Lambda的语法非常简洁，完全没有面向对象复杂的束缚。但是使用时有几个问题需要特别注意：</p> <ol> <li>使用Lambda必须具有接口，且要求<strong>接口中有且仅有一个抽象方法</strong>。 无论是JDK内置的<code class="language-plaintext highlighter-rouge">Runnable</code>、<code class="language-plaintext highlighter-rouge">Comparator</code>接口还是自定义的接口，只有当接口中的抽象方法存在且唯一时，才可以使用Lambda。</li> <li>使用Lambda必须具有<strong>上下文推断</strong>。 也就是方法的参数或局部变量类型必须为Lambda对应的接口类型，才能使用Lambda作为该接口的实例。</li> </ol> <blockquote> <p>备注：有且仅有一个抽象方法的接口，称为“<strong>函数式接口</strong>”。</p> </blockquote> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
    给定一个计算器Calculator接口，内含抽象方法calc可以将两个int数字相加得到和值
 */</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Calculator</span> <span class="o">{</span>
    <span class="c1">//定义一个计算两个int整数和的方法并返回结果</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">int</span> <span class="nf">calc</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span><span class="kt">int</span> <span class="n">b</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
    Lambda表达式有参数有返回值的练习
    需求:
        给定一个计算器Calculator接口，内含抽象方法calc可以将两个int数字相加得到和值
        使用Lambda的标准格式调用invokeCalc方法，完成120和130的相加计算
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo01Calculator</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//调用invokeCalc方法,方法的参数是一个接口,可以使用匿名内部类</span>
        <span class="n">invokeCalc</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="mi">20</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Calculator</span><span class="o">()</span> <span class="o">{</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">int</span> <span class="nf">calc</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">});</span>

        <span class="c1">//使用Lambda表达式简化匿名内部类的书写</span>
        <span class="n">invokeCalc</span><span class="o">(</span><span class="mi">120</span><span class="o">,</span><span class="mi">130</span><span class="o">,(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span><span class="kt">int</span> <span class="n">b</span><span class="o">)-&gt;{</span>
            <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">;</span>
        <span class="o">});</span>

        <span class="c1">//优化省略Lambda</span>
        <span class="n">invokeCalc</span><span class="o">(</span><span class="mi">120</span><span class="o">,</span><span class="mi">130</span><span class="o">,(</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">)-&gt;</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="cm">/*
        定义一个方法
        参数传递两个int类型的整数
        参数传递Calculator接口
        方法内部调用Calculator中的方法calc计算两个整数的和
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">invokeCalc</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span><span class="kt">int</span> <span class="n">b</span><span class="o">,</span><span class="nc">Calculator</span> <span class="n">c</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="na">calc</span><span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">sum</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>

<span class="cm">/*
    Lambda表达式:是可推导,可以省略
    凡是根据上下文推导出来的内容,都可以省略书写
    可以省略的内容:
        1.(参数列表):括号中参数列表的数据类型,可以省略不写
        2.(参数列表):括号中的参数如果只有一个,那么类型和()都可以省略
        3.{一些代码}:如果{}中的代码只有一行,无论是否有返回值,都可以省略({},return,分号)
            注意:要省略{},return,分号必须一起省略
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo01ArrayList</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//JDK1.7版本之前,创建集合对象必须把前后的泛型都写上</span>
        <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">list01</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;();</span>

        <span class="c1">//JDK1.7版本之后,=号后边的泛型可以省略,后边的泛型可以根据前边的泛型推导出来</span>
        <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">list02</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <div style="margin-top:2em;padding:0 1.5em;border:1px solid #d3d3d3;background-color:#deebf7"> <h3>文档信息</h3> <ul> <li>本文作者：<a href="https://blog.slienceme.cn" target="_blank">slience_me</a></li> <li>本文链接：<a href="https://blog.slienceme.cn/2021/01/26/Java%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7-%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86-%E5%BC%82%E5%B8%B8%E5%A4%9A%E7%BA%BF%E7%A8%8B/" target="_blank">https://blog.slienceme.cn/2021/01/26/Java%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7-%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86-%E5%BC%82%E5%B8%B8%E5%A4%9A%E7%BA%BF%E7%A8%8B/</a></li> <li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank">创意共享3.0许可证</a>）</li> </ul> </div> </article> <div class="share"> <div class="share-component" data-disabled='qq,facebook'></div> </div> <div class="comment"> <script src="https://giscus.app/client.js" data-repo="slience-me/blog-comments" data-repo-id="R_kgDOKr27jA" data-category="Announcements" data-category-id="DIC_kwDOKr27jM4CnWMe" data-mapping="title" data-strict="1" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="light" data-lang="zh-CN" data-loading="lazy" crossorigin="anonymous" async> </script> </div> </div> <div class="column one-fourth"> <h3>Search</h3> <div id="site_search"> <input style="width:96%" type="text" id="search_box" placeholder="Search"> </div> <ul id="search_results" style="font-size:14px;list-style-type:none;padding-top:10px;padding-left:10px;"></ul> <script src="https://blog.slienceme.cn/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: 'https://blog.slienceme.cn/assets/search_data.json?v=1740641696', searchResultTemplate: '<li><a href="{url}" title="{title}">{title}</a></li>', noResultsText: 'No results found', limit: 10, fuzzy: false, exclude: ['Welcome'] }) </script> <h3 class="post-directory-title mobile-hidden">Table of Contents</h3> <div id="post-directory-module" class="mobile-hidden"> <section class="post-directory"> <dl></dl> </section> </div> <script src="https://blog.slienceme.cn/assets/js/jquery.toc.js"></script> </div> </div> </section> <footer class="container"> <div class="site-footer" role="contentinfo"> <div class="copyright left mobile-block"> Copyright@ 2019-2025 slience_me 版权所有&emsp; <img src="/images/logo/logo.png" class="w-full" style="width: 12px;"> <a href="https://beian.mps.gov.cn/#/query/webSearch?code=13102202000626" rel="noreferrer" target="_blank">冀公网安备13102202000626</a>&emsp; <a href="https://beian.miit.gov.cn/#/Integrated/index" target="_blank" rel="noreferrer">津ICP备2024026565号-1</a> <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a> </div> <ul class="site-footer-links right mobile-hidden"> <li> <a href="javascript:window.scrollTo(0,0)" >TOP</a> </li> </ul> <br/> <script defer src="https://vercount.one/js"></script> <div class="mobile-hidden" style="margin-top:8px"> <span id="busuanzi_container_site_pv" style="display:none"> 本站访问量<span id="busuanzi_value_site_pv"></span>次 </span> <span id="busuanzi_container_site_uv" style="display:none"> / 本站访客数<span id="busuanzi_value_site_uv"></span>人 </span> <span id="busuanzi_container_page_pv" style="display:none"> / 本页访问量<span id="busuanzi_value_page_pv"></span>次 / 统计始于2024-12-01 </span> </div> </div> </footer> <div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a> </div> <script src="https://blog.slienceme.cn/assets/vendor/share.js/dist/js/share.min.js"></script> <script src="https://blog.slienceme.cn/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function($) { $('.geopattern').each(function(){ $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script> </body> </html>
