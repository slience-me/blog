<!DOCTYPE html> <html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"> <head> <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /> <title>Java｜Java语言高级（第四部分）File类与IO流 &mdash; Slience_me的博客</title> <link rel="stylesheet" href="https://blog.slienceme.cn/assets/vendor/primer-css/css/primer.css"> <link rel="stylesheet" href="https://blog.slienceme.cn/assets/css/components/collection.css"> <link rel="stylesheet" href="https://blog.slienceme.cn/assets/css/components/repo-card.css"> <link rel="stylesheet" href="https://blog.slienceme.cn/assets/css/sections/repo-list.css"> <link rel="stylesheet" href="https://blog.slienceme.cn/assets/css/components/boxed-group.css"> <link rel="stylesheet" href="https://blog.slienceme.cn/assets/css/globals/common.css"> <link rel="stylesheet" href="https://blog.slienceme.cn/assets/css/globals/responsive.css"> <link rel="stylesheet" href="https://blog.slienceme.cn/assets/css/posts/index.css"> <link rel="stylesheet" href="https://blog.slienceme.cn/assets/vendor/octicons/octicons/octicons.css"> <link rel="stylesheet" href=" https://cdn.jsdelivr.net/npm/@docsearch/css@3 "/> <link rel="stylesheet" href="https://mazhuang.org/rouge-themes/dist/github.css"> <link rel="stylesheet" href="https://blog.slienceme.cn/assets/vendor/share.js/dist/css/share.min.css"> <link rel="canonical" href="https://blog.slienceme.cn/2021/01/27/Java%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7-%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86-File%E7%B1%BB%E4%B8%8EIO%E6%B5%81/"> <link rel="alternate" type="application/atom+xml" title="Slience_me的博客" href="https://blog.slienceme.cn/feed.xml"> <link rel="shortcut icon" href="https://blog.slienceme.cn/favicon.ico"> <meta property="og:title" content="Java｜Java语言高级（第四部分）File类与IO流"> <meta name="keywords" content="编程语言, Java"> <meta name="og:keywords" content="编程语言, Java"> <meta name="description" content=""> <meta name="og:description" content=""> <meta property="og:url" content="https://blog.slienceme.cn/2021/01/27/Java%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7-%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86-File%E7%B1%BB%E4%B8%8EIO%E6%B5%81/"> <meta property="og:site_name" content="Slience_me的博客"> <meta property="og:type" content="article"> <meta property="og:locale" content="zh_CN" /> <meta property="article:published_time" content="2021-01-27"> <meta name="google-site-verification" content="2feHjT1GNs1Yi2JQfOtdYx7d048naG_-cMwZaDAopIA" /> <script src="https://blog.slienceme.cn/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="https://blog.slienceme.cn/assets/js/main.js"></script> </head> <body class="" data-mz=""> <header class="site-header"> <div class="container"> <h1><a href="https://blog.slienceme.cn/" title="Slience_me的博客"><span class="octicon octicon-mark-github"></span> Slience_me的博客</a></h1> <button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button> <nav class="site-header-nav" role="navigation"> <a href="https://blog.slienceme.cn/" class="site-header-nav-item" target="" title="首页">首页</a> <a href="https://blog.slienceme.cn/categories/" class="site-header-nav-item" target="" title="分类">分类</a> <a href="https://blog.slienceme.cn/archives/" class="mobile-hidden site-header-nav-item" target="" title="归档">归档</a> <a href="https://blog.slienceme.cn/open-source/" class="mobile-hidden site-header-nav-item" target="" title="开源">开源</a> <a href="https://blog.slienceme.cn/fragments/" class="site-header-nav-item" target="" title="片段">片段</a> <a href="https://blog.slienceme.cn/wiki/" class="site-header-nav-item" target="" title="维基">维基</a> <a href="https://blog.slienceme.cn/links/" class="mobile-hidden site-header-nav-item" target="" title="链接">链接</a> <a href="https://blog.slienceme.cn/about/" class="site-header-nav-item" target="" title="关于">关于</a> <a class="mobile-hidden" href="https://blog.slienceme.cn/feed.xml"><span class="octicon octicon-rss" style="color:orange;"></span></a> </nav> </div> </header> <section class="collection-head small geopattern" data-pattern-id="Java｜Java语言高级（第"> <div class="container"> <div class="columns"> <div class="column three-fourths"> <div class="collection-title"> <h1 class="collection-header">Java｜Java语言高级（第四部分）File类与IO流</h1> <div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2021/01/27 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="https://blog.slienceme.cn/categories/#Java" title="Java">Java</a> </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 86447 字，约 247 分钟 </span> </div> </div> </div> <div class="column one-fourth mobile-hidden"> <div class="collection-title"> </div> </div> </div> </div> </section> <section class="container content"> <div class="columns"> <div class="column three-fourths" > <article class="article-content markdown-body"> <p><img src="https://blog.slienceme.cn/images/posts/logo_slienceme3.png" alt="img" /></p> <p>本文作者： <a href="https://slienceme.cn/">slience_me</a></p> <hr /> <h1 id="java语言高级第四部分file类与io流">Java语言高级（第四部分）File类与IO流</h1> <h1 id="第六章-file类与io流">第六章 File类与IO流</h1> <h2 id="1-file类">1. File类</h2> <h3 id="11-概述">1.1 概述</h3> <p><code class="language-plaintext highlighter-rouge">java.io.File</code> 类是文件和目录路径名的抽象表示，主要用于文件和目录的创建、查找和删除等操作。</p> <h3 id="12-构造方法">1.2 构造方法</h3> <ul> <li><code class="language-plaintext highlighter-rouge">public File(String pathname) </code> ：通过将给定的<strong>路径名字符串</strong>转换为抽象路径名来创建新的 File实例。</li> <li><code class="language-plaintext highlighter-rouge">public File(String parent, String child) </code> ：从<strong>父路径名字符串和子路径名字符串</strong>创建新的 File实例。</li> <li> <p><code class="language-plaintext highlighter-rouge">public File(File parent, String child)</code> ：从<strong>父抽象路径名和子路径名字符串</strong>创建新的 File实例。</p> </li> <li>构造举例，代码如下：</li> </ul> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 文件路径名</span>
<span class="nc">String</span> <span class="n">pathname</span> <span class="o">=</span> <span class="s">"D:\\aaa.txt"</span><span class="o">;</span>
<span class="nc">File</span> <span class="n">file1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="n">pathname</span><span class="o">);</span> 

<span class="c1">// 文件路径名</span>
<span class="nc">String</span> <span class="n">pathname2</span> <span class="o">=</span> <span class="s">"D:\\aaa\\bbb.txt"</span><span class="o">;</span>
<span class="nc">File</span> <span class="n">file2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="n">pathname2</span><span class="o">);</span> 

<span class="c1">// 通过父路径和子路径字符串</span>
 <span class="nc">String</span> <span class="n">parent</span> <span class="o">=</span> <span class="s">"d:\\aaa"</span><span class="o">;</span>
 <span class="nc">String</span> <span class="n">child</span> <span class="o">=</span> <span class="s">"bbb.txt"</span><span class="o">;</span>
 <span class="nc">File</span> <span class="n">file3</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="n">parent</span><span class="o">,</span> <span class="n">child</span><span class="o">);</span>

<span class="c1">// 通过父级File对象和子路径字符串</span>
<span class="nc">File</span> <span class="n">parentDir</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"d:\\aaa"</span><span class="o">);</span>
<span class="nc">String</span> <span class="n">child</span> <span class="o">=</span> <span class="s">"bbb.txt"</span><span class="o">;</span>
<span class="nc">File</span> <span class="n">file4</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="n">parentDir</span><span class="o">,</span> <span class="n">child</span><span class="o">);</span>
</code></pre></div></div> <blockquote> <p>小贴士：</p> <ol> <li>一个File对象代表硬盘中实际存在的一个文件或者目录。</li> <li>无论该路径下是否存在文件或者目录，都不影响File对象的创建。 ```java import java.io.File;</li> </ol> </blockquote> <p>/* java.io.File类 文件和目录路径名的抽象表示形式。 java把电脑中的文件和文件夹(目录)封装为了一个File类,我们可以使用File类对文件和文件夹进行操作 我们可以使用File类的方法 创建一个文件/文件夹 删除文件/文件夹 获取文件/文件夹 判断文件/文件夹是否存在 对文件夹进行遍历 获取文件的大小 File类是一个与系统无关的类,任何的操作系统都可以使用这个类中的方法</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>重点:记住这三个单词
    file:文件
    directory:文件夹/目录
    path:路径  */ public class Demo01File {
public static void main(String[] args) {
    /*
        static String pathSeparator 与系统有关的路径分隔符，为了方便，它被表示为一个字符串。
        static char pathSeparatorChar 与系统有关的路径分隔符。

        static String separator 与系统有关的默认名称分隔符，为了方便，它被表示为一个字符串。
        static char separatorChar 与系统有关的默认名称分隔符。

        操作路径:路径不能写死了
        C:\develop\a\a.txt  windows
        C:/develop/a/a.txt  linux
        "C:"+File.separator+"develop"+File.separator+"a"+File.separator+"a.txt"
     */
    String pathSeparator = File.pathSeparator;
    System.out.println(pathSeparator);//路径分隔符 windows:分号;  linux:冒号:

    String separator = File.separator;
    System.out.println(separator);// 文件名称分隔符 windows:反斜杠\  linux:正斜杠/
}
</code></pre></div></div> <p>}</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
```java
import java.io.File;

/*
    路径:
        绝对路径:是一个完整的路径
            以盘符(c:,D:)开始的路径
                c:\\a.txt
                C:\\Users\itdemo\\IdeaProjects\\ittest\\123.txt
                D:\\demo\\b.txt
        相对路径:是一个简化的路径
            相对指的是相对于当前项目的根目录(C:\\Users\itdemo\\IdeaProjects\\ittest)
            如果使用当前项目的根目录,路径可以简化书写
            C:\\Users\itdemo\\IdeaProjects\\ittest\\123.txt--&gt;简化为: 123.txt(可以省略项目的根目录)
        注意:
            1.路径是不区分大小写
            2.路径中的文件名称分隔符windows使用反斜杠,反斜杠是转义字符,两个反斜杠代表一个普通的反斜杠
 */
public class Demo02File {
    public static void main(String[] args) {
        /*
            File类的构造方法
         */
        //show02("c:\\","a.txt");//c:\a.txt
        //show02("d:\\","a.txt");//d:\a.txt
        show03();

        File f = new File("C:\\Users\\itdemo\\IdeaProjects\\ittest");
        long length = f.length();
        System.out.println(length);
    }

    /*
        File(File parent, String child) 根据 parent 抽象路径名和 child 路径名字符串创建一个新 File 实例。
        参数:把路径分成了两部分
            File parent:父路径
            String child:子路径
        好处:
             父路径和子路径,可以单独书写,使用起来非常灵活;父路径和子路径都可以变化
             父路径是File类型,可以使用File的方法对路径进行一些操作,再使用路径创建对象
     */
    private static void show03() {
        File parent = new File("c:\\");
        File file = new File(parent,"hello.java");
        System.out.println(file);//c:\hello.java
    }

    /*
        File(String parent, String child) 根据 parent 路径名字符串和 child 路径名字符串创建一个新 File 实例。
        参数:把路径分成了两部分
            String parent:父路径
            String child:子路径
        好处:
            父路径和子路径,可以单独书写,使用起来非常灵活;父路径和子路径都可以变化
     */
    private static void show02(String parent, String child) {
        File file = new File(parent,child);
        System.out.println(file);//c:\a.txt
    }

    /*
        File(String pathname) 通过将给定路径名字符串转换为抽象路径名来创建一个新 File 实例。
        参数:
            String pathname:字符串的路径名称
            路径可以是以文件结尾,也可以是以文件夹结尾
            路径可以是相对路径,也可以是绝对路径
            路径可以是存在,也可以是不存在
            创建File对象,只是把字符串路径封装为File对象,不考虑路径的真假情况
     */
    private static void show01() {
        File f1 = new File("C:\\Users\\itdemo\\IdeaProjects\\ittest\\a.txt");
        System.out.println(f1);//重写了Object类的toString方法 C:\Users\itdemo\IdeaProjects\ittest\a.txt

        File f2 = new File("C:\\Users\\itdemo\\IdeaProjects\\ittest");
        System.out.println(f2);//C:\Users\itdemo\IdeaProjects\ittest

        File f3 = new File("b.txt");
        System.out.println(f3);//b.txt
    }
}
</code></pre></div></div> <h3 id="13-常用方法">1.3 常用方法</h3> <h4 id="获取功能的方法">获取功能的方法</h4> <ul> <li> <p><code class="language-plaintext highlighter-rouge">public String getAbsolutePath() </code> ：返回此File的绝对路径名字符串。</p> </li> <li> <p>` public String getPath() ` ：将此File转换为路径名字符串。</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">public String getName()</code> ：返回由此File表示的文件或目录的名称。</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">public long length()</code> ：返回由此File表示的文件的长度。</p> <p>方法演示，代码如下：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FileGet</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">File</span> <span class="n">f</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"d:/aaa/bbb.java"</span><span class="o">);</span>     
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"文件绝对路径:"</span><span class="o">+</span><span class="n">f</span><span class="o">.</span><span class="na">getAbsolutePath</span><span class="o">());</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"文件构造路径:"</span><span class="o">+</span><span class="n">f</span><span class="o">.</span><span class="na">getPath</span><span class="o">());</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"文件名称:"</span><span class="o">+</span><span class="n">f</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"文件长度:"</span><span class="o">+</span><span class="n">f</span><span class="o">.</span><span class="na">length</span><span class="o">()+</span><span class="s">"字节"</span><span class="o">);</span>

        <span class="nc">File</span> <span class="n">f2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"d:/aaa"</span><span class="o">);</span>     
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"目录绝对路径:"</span><span class="o">+</span><span class="n">f2</span><span class="o">.</span><span class="na">getAbsolutePath</span><span class="o">());</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"目录构造路径:"</span><span class="o">+</span><span class="n">f2</span><span class="o">.</span><span class="na">getPath</span><span class="o">());</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"目录名称:"</span><span class="o">+</span><span class="n">f2</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"目录长度:"</span><span class="o">+</span><span class="n">f2</span><span class="o">.</span><span class="na">length</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="n">输出结果</span><span class="err">：</span>
<span class="nl">文件绝对路径:d:</span><span class="err">\</span><span class="n">aaa</span><span class="err">\</span><span class="n">bbb</span><span class="o">.</span><span class="na">java</span>
<span class="nl">文件构造路径:d:</span><span class="err">\</span><span class="n">aaa</span><span class="err">\</span><span class="n">bbb</span><span class="o">.</span><span class="na">java</span>
<span class="nl">文件名称:</span><span class="n">bbb</span><span class="o">.</span><span class="na">java</span>
<span class="nl">文件长度:</span><span class="mi">636</span><span class="n">字节</span>

<span class="nl">目录绝对路径:d:</span><span class="err">\</span><span class="n">aaa</span>
<span class="nl">目录构造路径:d:</span><span class="err">\</span><span class="n">aaa</span>
<span class="nl">目录名称:</span><span class="n">aaa</span>
<span class="nl">目录长度:</span><span class="mi">4096</span>
</code></pre></div> </div> </li> </ul> <blockquote> <p>API中说明：length()，表示文件的长度。但是File对象表示目录，则返回值未指定。</p> </blockquote> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.io.File</span><span class="o">;</span>

<span class="cm">/*
    File类获取功能的方法
        - public String getAbsolutePath() ：返回此File的绝对路径名字符串。
        - public String getPath() ：将此File转换为路径名字符串。
        - public String getName()  ：返回由此File表示的文件或目录的名称。
        - public long length()  ：返回由此File表示的文件的长度。
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo03File</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">show04</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="cm">/*
        public long length()  ：返回由此File表示的文件的长度。
        获取的是构造方法指定的文件的大小,以字节为单位
        注意:
            文件夹是没有大小概念的,不能获取文件夹的大小
            如果构造方法中给出的路径不存在,那么length方法返回0
     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">show04</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">File</span> <span class="n">f1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"C:\\develop\\a\\1.jpg"</span><span class="o">);</span>
        <span class="kt">long</span> <span class="n">l1</span> <span class="o">=</span> <span class="n">f1</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">l1</span><span class="o">);</span><span class="c1">//780831字节</span>

        <span class="nc">File</span> <span class="n">f2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"C:\\develop\\a\\2.jpg"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">f2</span><span class="o">.</span><span class="na">length</span><span class="o">());</span><span class="c1">//0</span>

        <span class="nc">File</span> <span class="n">f3</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"C:\\develop\\a"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">f3</span><span class="o">.</span><span class="na">length</span><span class="o">());</span><span class="c1">//0 文件夹没有大小概念的</span>
    <span class="o">}</span>

    <span class="cm">/*
        public String getName()  ：返回由此File表示的文件或目录的名称。
        获取的就是构造方法传递路径的结尾部分(文件/文件夹)
     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">show03</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">File</span> <span class="n">f1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"C:\\Users\\itdemo\\IdeaProjects\\ittest\\a.txt"</span><span class="o">);</span>
        <span class="nc">String</span> <span class="n">name1</span> <span class="o">=</span> <span class="n">f1</span><span class="o">.</span><span class="na">getName</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">name1</span><span class="o">);</span><span class="c1">//a.txt</span>

        <span class="nc">File</span> <span class="n">f2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"C:\\Users\\itdemo\\IdeaProjects\\ittest"</span><span class="o">);</span>
        <span class="nc">String</span> <span class="n">name2</span> <span class="o">=</span> <span class="n">f2</span><span class="o">.</span><span class="na">getName</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">name2</span><span class="o">);</span><span class="c1">//ittest</span>
    <span class="o">}</span>

    <span class="cm">/*
        public String getPath() ：将此File转换为路径名字符串。
        获取的构造方法中传递的路径

        toString方法调用的就是getPath方法
        源码:
            public String toString() {
                return getPath();
            }
     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">show02</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">File</span> <span class="n">f1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"C:\\Users\\itdemo\\IdeaProjects\\ittest\\a.txt"</span><span class="o">);</span>
        <span class="nc">File</span> <span class="n">f2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"a.txt"</span><span class="o">);</span>
        <span class="nc">String</span> <span class="n">path1</span> <span class="o">=</span> <span class="n">f1</span><span class="o">.</span><span class="na">getPath</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">path1</span><span class="o">);</span><span class="c1">//C:\Users\itdemo\IdeaProjects\ittest\a.txt</span>
        <span class="nc">String</span> <span class="n">path2</span> <span class="o">=</span> <span class="n">f2</span><span class="o">.</span><span class="na">getPath</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">path2</span><span class="o">);</span><span class="c1">//a.txt</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">f1</span><span class="o">);</span><span class="c1">//C:\Users\itdemo\IdeaProjects\ittest\a.txt</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">f1</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span><span class="c1">//C:\Users\itdemo\IdeaProjects\ittest\a.txt</span>
    <span class="o">}</span>

    <span class="cm">/*
        public String getAbsolutePath() ：返回此File的绝对路径名字符串。
        获取的构造方法中传递的路径
        无论路径是绝对的还是相对的,getAbsolutePath方法返回的都是绝对路径
     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">show01</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">File</span> <span class="n">f1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"C:\\Users\\itdemo\\IdeaProjects\\ittest\\a.txt"</span><span class="o">);</span>
        <span class="nc">String</span> <span class="n">absolutePath1</span> <span class="o">=</span> <span class="n">f1</span><span class="o">.</span><span class="na">getAbsolutePath</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">absolutePath1</span><span class="o">);</span><span class="c1">//C:\Users\itdemo\IdeaProjects\ittest\a.txt</span>

        <span class="nc">File</span> <span class="n">f2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"a.txt"</span><span class="o">);</span>
        <span class="nc">String</span> <span class="n">absolutePath2</span> <span class="o">=</span> <span class="n">f2</span><span class="o">.</span><span class="na">getAbsolutePath</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">absolutePath2</span><span class="o">);</span><span class="c1">//C:\Users\itdemo\IdeaProjects\ittest\a.txt</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h4 id="绝对路径和相对路径">绝对路径和相对路径</h4> <ul> <li><strong>绝对路径</strong>：从盘符开始的路径，这是一个完整的路径。</li> <li><strong>相对路径</strong>：相对于项目目录的路径，这是一个便捷的路径，开发中经常使用。</li> </ul> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FilePath</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
      	<span class="c1">// D盘下的bbb.java文件</span>
        <span class="nc">File</span> <span class="n">f</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"D:\\bbb.java"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">f</span><span class="o">.</span><span class="na">getAbsolutePath</span><span class="o">());</span>
      	
		<span class="c1">// 项目下的bbb.java文件</span>
        <span class="nc">File</span> <span class="n">f2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"bbb.java"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">f2</span><span class="o">.</span><span class="na">getAbsolutePath</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="n">输出结果</span><span class="err">：</span>
<span class="nl">D:</span><span class="err">\</span><span class="n">bbb</span><span class="o">.</span><span class="na">java</span>
<span class="nl">D:</span><span class="err">\</span><span class="n">idea_project_test4</span><span class="err">\</span><span class="n">bbb</span><span class="o">.</span><span class="na">java</span>
</code></pre></div></div> <h4 id="判断功能的方法">判断功能的方法</h4> <ul> <li><code class="language-plaintext highlighter-rouge">public boolean exists()</code> ：此File表示的文件或目录是否实际存在。</li> <li><code class="language-plaintext highlighter-rouge">public boolean isDirectory()</code> ：此File表示的是否为目录。</li> <li><code class="language-plaintext highlighter-rouge">public boolean isFile()</code> ：此File表示的是否为文件。</li> </ul> <p>方法演示，代码如下：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FileIs</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">File</span> <span class="n">f</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"d:\\aaa\\bbb.java"</span><span class="o">);</span>
        <span class="nc">File</span> <span class="n">f2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"d:\\aaa"</span><span class="o">);</span>
      	<span class="c1">// 判断是否存在</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"d:\\aaa\\bbb.java 是否存在:"</span><span class="o">+</span><span class="n">f</span><span class="o">.</span><span class="na">exists</span><span class="o">());</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"d:\\aaa 是否存在:"</span><span class="o">+</span><span class="n">f2</span><span class="o">.</span><span class="na">exists</span><span class="o">());</span>
      	<span class="c1">// 判断是文件还是目录</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"d:\\aaa 文件?:"</span><span class="o">+</span><span class="n">f2</span><span class="o">.</span><span class="na">isFile</span><span class="o">());</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"d:\\aaa 目录?:"</span><span class="o">+</span><span class="n">f2</span><span class="o">.</span><span class="na">isDirectory</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="n">输出结果</span><span class="err">：</span>
<span class="nl">d:</span><span class="err">\</span><span class="n">aaa</span><span class="err">\</span><span class="n">bbb</span><span class="o">.</span><span class="na">java</span> <span class="nl">是否存在:</span><span class="kc">true</span>
<span class="nl">d:</span><span class="err">\</span><span class="n">aaa</span> <span class="nl">是否存在:</span><span class="kc">true</span>
<span class="nl">d:</span><span class="err">\</span><span class="n">aaa</span> <span class="n">文件</span><span class="o">?:</span><span class="kc">false</span>
<span class="nl">d:</span><span class="err">\</span><span class="n">aaa</span> <span class="n">目录</span><span class="o">?:</span><span class="kc">true</span>
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.io.File</span><span class="o">;</span>

<span class="cm">/*
    File类判断功能的方法
        - public boolean exists() ：此File表示的文件或目录是否实际存在。
        - public boolean isDirectory() ：此File表示的是否为目录。
        - public boolean isFile() ：此File表示的是否为文件。
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo04File</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">show02</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="cm">/*
        public boolean isDirectory() ：此File表示的是否为目录。
            用于判断构造方法中给定的路径是否以文件夹结尾
                是:true
                否:false
        public boolean isFile() ：此File表示的是否为文件。
            用于判断构造方法中给定的路径是否以文件结尾
                是:true
                否:false
        注意:
            电脑的硬盘中只有文件/文件夹,两个方法是互斥
            这两个方法使用前提,路径必须是存在的,否则都返回false
     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">show02</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">File</span> <span class="n">f1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"C:\\Users\\itdemo\\IdeaProjects\\shung"</span><span class="o">);</span>

        <span class="c1">//不存在,就没有必要获取</span>
        <span class="k">if</span><span class="o">(</span><span class="n">f1</span><span class="o">.</span><span class="na">exists</span><span class="o">()){</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">f1</span><span class="o">.</span><span class="na">isDirectory</span><span class="o">());</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">f1</span><span class="o">.</span><span class="na">isFile</span><span class="o">());</span>
        <span class="o">}</span>

        <span class="nc">File</span> <span class="n">f2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"C:\\Users\\itdemo\\IdeaProjects\\ittest"</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">f2</span><span class="o">.</span><span class="na">exists</span><span class="o">()){</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">f2</span><span class="o">.</span><span class="na">isDirectory</span><span class="o">());</span><span class="c1">//true</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">f2</span><span class="o">.</span><span class="na">isFile</span><span class="o">());</span><span class="c1">//false</span>
        <span class="o">}</span>

        <span class="nc">File</span> <span class="n">f3</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"C:\\Users\\itdemo\\IdeaProjects\\ittest\\ittest.iml"</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">f3</span><span class="o">.</span><span class="na">exists</span><span class="o">()){</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">f3</span><span class="o">.</span><span class="na">isDirectory</span><span class="o">());</span><span class="c1">//false</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">f3</span><span class="o">.</span><span class="na">isFile</span><span class="o">());</span><span class="c1">//true</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="cm">/*
        public boolean exists() ：此File表示的文件或目录是否实际存在。
        用于判断构造方法中的路径是否存在
            存在:true
            不存在:false
     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">show01</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">File</span> <span class="n">f1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"C:\\Users\\itdemo\\IdeaProjects\\ittest"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">f1</span><span class="o">.</span><span class="na">exists</span><span class="o">());</span><span class="c1">//true</span>

        <span class="nc">File</span> <span class="n">f2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"C:\\Users\\itdemo\\IdeaProjects\\shung"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">f2</span><span class="o">.</span><span class="na">exists</span><span class="o">());</span><span class="c1">//false</span>

        <span class="nc">File</span> <span class="n">f3</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"ittest.iml"</span><span class="o">);</span><span class="c1">//相对路径 C:\Users\itdemo\IdeaProjects\ittest\ittest.iml</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">f3</span><span class="o">.</span><span class="na">exists</span><span class="o">());</span><span class="c1">//true</span>

        <span class="nc">File</span> <span class="n">f4</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"a.txt"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">f4</span><span class="o">.</span><span class="na">exists</span><span class="o">());</span><span class="c1">//false</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div> <h4 id="创建删除功能的方法">创建删除功能的方法</h4> <ul> <li><code class="language-plaintext highlighter-rouge">public boolean createNewFile()</code> ：当且仅当具有该名称的文件尚不存在时，创建一个新的空文件。</li> <li><code class="language-plaintext highlighter-rouge">public boolean delete()</code> ：删除由此File表示的文件或目录。</li> <li><code class="language-plaintext highlighter-rouge">public boolean mkdir()</code> ：创建由此File表示的目录。</li> <li><code class="language-plaintext highlighter-rouge">public boolean mkdirs()</code> ：创建由此File表示的目录，包括任何必需但不存在的父目录。</li> </ul> <p>方法演示，代码如下：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FileCreateDelete</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="c1">// 文件的创建</span>
        <span class="nc">File</span> <span class="n">f</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"aaa.txt"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"是否存在:"</span><span class="o">+</span><span class="n">f</span><span class="o">.</span><span class="na">exists</span><span class="o">());</span> <span class="c1">// false</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"是否创建:"</span><span class="o">+</span><span class="n">f</span><span class="o">.</span><span class="na">createNewFile</span><span class="o">());</span> <span class="c1">// true</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"是否存在:"</span><span class="o">+</span><span class="n">f</span><span class="o">.</span><span class="na">exists</span><span class="o">());</span> <span class="c1">// true</span>
		
     	<span class="c1">// 目录的创建</span>
      	<span class="nc">File</span> <span class="n">f2</span><span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"newDir"</span><span class="o">);</span>	
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"是否存在:"</span><span class="o">+</span><span class="n">f2</span><span class="o">.</span><span class="na">exists</span><span class="o">());</span><span class="c1">// false</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"是否创建:"</span><span class="o">+</span><span class="n">f2</span><span class="o">.</span><span class="na">mkdir</span><span class="o">());</span>	<span class="c1">// true</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"是否存在:"</span><span class="o">+</span><span class="n">f2</span><span class="o">.</span><span class="na">exists</span><span class="o">());</span><span class="c1">// true</span>

		<span class="c1">// 创建多级目录</span>
      	<span class="nc">File</span> <span class="n">f3</span><span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"newDira\\newDirb"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">f3</span><span class="o">.</span><span class="na">mkdir</span><span class="o">());</span><span class="c1">// false</span>
        <span class="nc">File</span> <span class="n">f4</span><span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"newDira\\newDirb"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">f4</span><span class="o">.</span><span class="na">mkdirs</span><span class="o">());</span><span class="c1">// true</span>
      
      	<span class="c1">// 文件的删除</span>
       	<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">f</span><span class="o">.</span><span class="na">delete</span><span class="o">());</span><span class="c1">// true</span>
      
      	<span class="c1">// 目录的删除</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">f2</span><span class="o">.</span><span class="na">delete</span><span class="o">());</span><span class="c1">// true</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">f4</span><span class="o">.</span><span class="na">delete</span><span class="o">());</span><span class="c1">// false</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <blockquote> <p>API中说明：delete方法，如果此File表示目录，则目录必须为空才能删除。</p> </blockquote> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.io.File</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>

<span class="cm">/*
    File类创建删除功能的方法
        - public boolean createNewFile() ：当且仅当具有该名称的文件尚不存在时，创建一个新的空文件。
        - public boolean delete() ：删除由此File表示的文件或目录。
        - public boolean mkdir() ：创建由此File表示的目录。
        - public boolean mkdirs() ：创建由此File表示的目录，包括任何必需但不存在的父目录。
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo05File</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="n">show03</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="cm">/*
        public boolean delete() ：删除由此File表示的文件或目录。
        此方法,可以删除构造方法路径中给出的文件/文件夹
        返回值:布尔值
            true:文件/文件夹删除成功,返回true
            false:文件夹中有内容,不会删除返回false;构造方法中路径不存在false
        注意:
            delete方法是直接在硬盘删除文件/文件夹,不走回收站,删除要谨慎
     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">show03</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">File</span> <span class="n">f1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"08_FileAndRecursion\\新建文件夹"</span><span class="o">);</span>
        <span class="kt">boolean</span> <span class="n">b1</span> <span class="o">=</span> <span class="n">f1</span><span class="o">.</span><span class="na">delete</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"b1:"</span><span class="o">+</span><span class="n">b1</span><span class="o">);</span>

        <span class="nc">File</span> <span class="n">f2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"08_FileAndRecursion\\abc.txt"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">f2</span><span class="o">.</span><span class="na">delete</span><span class="o">());</span>
    <span class="o">}</span>

    <span class="cm">/*
       public boolean mkdir() ：创建单级空文件夹
       public boolean mkdirs() ：既可以创建单级空文件夹,也可以创建多级文件夹
       创建文件夹的路径和名称在构造方法中给出(构造方法的参数)
        返回值:布尔值
            true:文件夹不存在,创建文件夹,返回true
            false:文件夹存在,不会创建,返回false;构造方法中给出的路径不存在返回false
        注意:
            1.此方法只能创建文件夹,不能创建文件
     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">show02</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">File</span> <span class="n">f1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"08_FileAndRecursion\\aaa"</span><span class="o">);</span>
        <span class="kt">boolean</span> <span class="n">b1</span> <span class="o">=</span> <span class="n">f1</span><span class="o">.</span><span class="na">mkdir</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"b1:"</span><span class="o">+</span><span class="n">b1</span><span class="o">);</span>

        <span class="nc">File</span> <span class="n">f2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"08_FileAndRecursion\\111\\222\\333\\444"</span><span class="o">);</span>
        <span class="kt">boolean</span> <span class="n">b2</span> <span class="o">=</span> <span class="n">f2</span><span class="o">.</span><span class="na">mkdirs</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"b2:"</span><span class="o">+</span><span class="n">b2</span><span class="o">);</span>

        <span class="nc">File</span> <span class="n">f3</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"08_FileAndRecursion\\abc.txt"</span><span class="o">);</span>
        <span class="kt">boolean</span> <span class="n">b3</span> <span class="o">=</span> <span class="n">f3</span><span class="o">.</span><span class="na">mkdirs</span><span class="o">();</span><span class="c1">//看类型,是一个文件</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"b3:"</span><span class="o">+</span><span class="n">b3</span><span class="o">);</span>

        <span class="nc">File</span> <span class="n">f4</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"08_F\\ccc"</span><span class="o">);</span>
        <span class="kt">boolean</span> <span class="n">b4</span> <span class="o">=</span> <span class="n">f4</span><span class="o">.</span><span class="na">mkdirs</span><span class="o">();</span><span class="c1">//不会抛出异常,路径不存在,不会创建</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"b4:"</span><span class="o">+</span><span class="n">b4</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="cm">/*
        public boolean createNewFile() ：当且仅当具有该名称的文件尚不存在时，创建一个新的空文件。
        创建文件的路径和名称在构造方法中给出(构造方法的参数)
        返回值:布尔值
            true:文件不存在,创建文件,返回true
            false:文件存在,不会创建,返回false
        注意:
            1.此方法只能创建文件,不能创建文件夹
            2.创建文件的路径必须存在,否则会抛出异常

        public boolean createNewFile() throws IOException
        createNewFile声明抛出了IOException,我们调用这个方法,就必须的处理这个异常,要么throws,要么trycatch
     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">show01</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="nc">File</span> <span class="n">f1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"C:\\Users\\itdemo\\IdeaProjects\\ittest\\08_FileAndRecursion\\1.txt"</span><span class="o">);</span>
        <span class="kt">boolean</span> <span class="n">b1</span> <span class="o">=</span> <span class="n">f1</span><span class="o">.</span><span class="na">createNewFile</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"b1:"</span><span class="o">+</span><span class="n">b1</span><span class="o">);</span>

        <span class="nc">File</span> <span class="n">f2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"08_FileAndRecursion\\2.txt"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">f2</span><span class="o">.</span><span class="na">createNewFile</span><span class="o">());</span>

        <span class="nc">File</span> <span class="n">f3</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"08_FileAndRecursion\\新建文件夹"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">f3</span><span class="o">.</span><span class="na">createNewFile</span><span class="o">());</span><span class="c1">//不要被名称迷糊,要看类型</span>

        <span class="nc">File</span> <span class="n">f4</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"08_FileAndRecursi\\3.txt"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">f4</span><span class="o">.</span><span class="na">createNewFile</span><span class="o">());</span><span class="c1">//路径不存在,抛出IOException</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h3 id="14-目录的遍历">1.4 目录的遍历</h3> <ul> <li> <p><code class="language-plaintext highlighter-rouge">public String[] list()</code> ：返回一个String数组，表示该File目录中的所有子文件或目录。</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">public File[] listFiles()</code> ：返回一个File数组，表示该File目录中的所有的子文件或目录。</p> </li> </ul> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FileFor</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">File</span> <span class="n">dir</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"d:\\java_code"</span><span class="o">);</span>
      
      	<span class="c1">//获取当前目录下的文件以及文件夹的名称。</span>
		<span class="nc">String</span><span class="o">[]</span> <span class="n">names</span> <span class="o">=</span> <span class="n">dir</span><span class="o">.</span><span class="na">list</span><span class="o">();</span>
		<span class="k">for</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span> <span class="o">:</span> <span class="n">names</span><span class="o">){</span>
			<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
		<span class="o">}</span>
        <span class="c1">//获取当前目录下的文件以及文件夹对象，只要拿到了文件对象，那么就可以获取更多信息</span>
        <span class="nc">File</span><span class="o">[]</span> <span class="n">files</span> <span class="o">=</span> <span class="n">dir</span><span class="o">.</span><span class="na">listFiles</span><span class="o">();</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">File</span> <span class="n">file</span> <span class="o">:</span> <span class="n">files</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">file</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <blockquote> <p>小贴士：</p> <p>调用listFiles方法的File对象，表示的必须是实际存在的目录，否则返回null，无法进行遍历。</p> </blockquote> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.io.File</span><span class="o">;</span>

<span class="cm">/*
    File类遍历(文件夹)目录功能
        - public String[] list() ：返回一个String数组，表示该File目录中的所有子文件或目录。
        - public File[] listFiles() ：返回一个File数组，表示该File目录中的所有的子文件或目录。

    注意:
        list方法和listFiles方法遍历的是构造方法中给出的目录
        如果构造方法中给出的目录的路径不存在,会抛出空指针异常
        如果构造方法中给出的路径不是一个目录,也会抛出空指针异常
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo06File</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">show02</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="cm">/*
        public File[] listFiles() ：返回一个File数组，表示该File目录中的所有的子文件或目录。
        遍历构造方法中给出的目录,会获取目录中所有的文件/文件夹,把文件/文件夹封装为File对象,多个File对象存储到File数组中
     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">show02</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">File</span> <span class="n">file</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"C:\\Users\\itdemo\\IdeaProjects\\ittest\\08_FileAndRecursion"</span><span class="o">);</span>
        <span class="nc">File</span><span class="o">[]</span> <span class="n">files</span> <span class="o">=</span> <span class="n">file</span><span class="o">.</span><span class="na">listFiles</span><span class="o">();</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">File</span> <span class="n">f</span> <span class="o">:</span> <span class="n">files</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">f</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="cm">/*
        public String[] list() ：返回一个String数组，表示该File目录中的所有子文件或目录。
        遍历构造方法中给出的目录,会获取目录中所有文件/文件夹的名称,把获取到的多个名称存储到一个String类型的数组中
     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">show01</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">//File file = new File("C:\\Users\\itdemo\\IdeaProjects\\ittest\\08_FileAndRecursion\\1.txt");//NullPointerException</span>
        <span class="c1">//File file = new File("C:\\Users\\itdemo\\IdeaProjects\\ittest\\08_Fi");//NullPointerException</span>
        <span class="nc">File</span> <span class="n">file</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"C:\\Users\\itdemo\\IdeaProjects\\ittest\\08_FileAndRecursion"</span><span class="o">);</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="n">file</span><span class="o">.</span><span class="na">list</span><span class="o">();</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">fileName</span> <span class="o">:</span> <span class="n">arr</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">fileName</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h2 id="2-递归">2. 递归</h2> <h3 id="21-概述">2.1 概述</h3> <ul> <li> <p><strong>递归</strong>：指在当前方法内调用自己的这种现象。</p> </li> <li><strong>递归的分类:</strong> <ul> <li>递归分为两种，直接递归和间接递归。</li> <li>直接递归称为方法自身调用自己。</li> <li>间接递归可以A方法调用B方法，B方法调用C方法，C方法调用A方法。</li> </ul> </li> <li><strong>注意事项</strong>： <ul> <li>递归一定要有条件限定，保证递归能够停止下来，否则会发生栈内存溢出。</li> <li>在递归中虽然有限定条件，但是递归次数不能太多。否则也会发生栈内存溢出。</li> <li>构造方法,禁止递归</li> </ul> </li> </ul> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo01DiGui</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
		<span class="c1">// a();</span>
		<span class="n">b</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
	<span class="o">}</span>
	
	<span class="cm">/*
	 * 3.构造方法,禁止递归
	 * 编译报错:构造方法是创建对象使用的,不能让对象一直创建下去
	 */</span>
	<span class="kd">public</span> <span class="nf">Demo01DiGui</span><span class="o">()</span> <span class="o">{</span>
		<span class="c1">//Demo01DiGui();</span>
	<span class="o">}</span>


	<span class="cm">/*
	 * 2.在递归中虽然有限定条件，但是递归次数不能太多。否则也会发生栈内存溢出。
	 * 4993
	 * 	Exception in thread "main" java.lang.StackOverflowError
	 */</span>
	<span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">b</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
		<span class="c1">//添加一个递归结束的条件,i==5000的时候结束</span>
		<span class="k">if</span><span class="o">(</span><span class="n">i</span><span class="o">==</span><span class="mi">5000</span><span class="o">){</span>
			<span class="k">return</span><span class="o">;</span><span class="c1">//结束方法</span>
		<span class="o">}</span>
		<span class="n">b</span><span class="o">(++</span><span class="n">i</span><span class="o">);</span>
	<span class="o">}</span>

	<span class="cm">/*
	 * 1.递归一定要有条件限定，保证递归能够停止下来，否则会发生栈内存溢出。 Exception in thread "main"
	 * java.lang.StackOverflowError
	 */</span>
	<span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">a</span><span class="o">()</span> <span class="o">{</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"a方法"</span><span class="o">);</span>
		<span class="n">a</span><span class="o">();</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
    递归:方法自己调用自己
    - 递归的分类:
      - 递归分为两种，直接递归和间接递归。
      - 直接递归称为方法自身调用自己。
      - 间接递归可以A方法调用B方法，B方法调用C方法，C方法调用A方法。
    - 注意事项：
      - 递归一定要有条件限定，保证递归能够停止下来，否则会发生栈内存溢出。
      - 在递归中虽然有限定条件，但是递归次数不能太多。否则也会发生栈内存溢出。
      - 构造方法,禁止递归
    递归的使用前提:
        当调用方法的时候,方法的主体不变,每次调用方法的参数不同,可以使用递归
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo01Recurison</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//a();</span>
        <span class="n">b</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="cm">/*
        构造方法,禁止递归
            编译报错:构造方法是创建对象使用的,一直递归会导致内存中有无数多个对象,直接编译报错
     */</span>
    <span class="kd">public</span> <span class="nf">Demo01Recurison</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">//Demo01Recurison();</span>
    <span class="o">}</span>

    <span class="cm">/*
            在递归中虽然有限定条件，但是递归次数不能太多。否则也会发生栈内存溢出。
            11157
                Exception in thread "main" java.lang.StackOverflowError
         */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">b</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">i</span><span class="o">==</span><span class="mi">20000</span><span class="o">){</span>
            <span class="k">return</span><span class="o">;</span> <span class="c1">//结束方法</span>
        <span class="o">}</span>
        <span class="n">b</span><span class="o">(++</span><span class="n">i</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="cm">/*
        递归一定要有条件限定，保证递归能够停止下来，否则会发生栈内存溢出。
        Exception in thread "main" java.lang.StackOverflowError
     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">a</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"a方法!"</span><span class="o">);</span>
        <span class="n">a</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p><img src="https://blog.slienceme.cn/images/posts/20210127104804615.bmp.jpg" alt="Alt Text" /></p> <h3 id="22-递归累加求和">2.2 递归累加求和</h3> <h4 id="计算1--n的和">计算1 ~ n的和</h4> <p><strong>分析</strong>：num的累和 = num + (num-1)的累和，所以可以把累和的操作定义成一个方法，递归调用。</p> <p><strong>实现代码</strong>：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DiGuiDemo</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
		<span class="c1">//计算1~num的和，使用递归完成</span>
		<span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">5</span><span class="o">;</span>
      	<span class="c1">// 调用求和的方法</span>
		<span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">getSum</span><span class="o">(</span><span class="n">num</span><span class="o">);</span>
      	<span class="c1">// 输出结果</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">sum</span><span class="o">);</span>
		
	<span class="o">}</span>
  	<span class="cm">/*
  	  通过递归算法实现.
  	  参数列表:int 
  	  返回值类型: int 
  	*/</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">getSum</span><span class="o">(</span><span class="kt">int</span> <span class="n">num</span><span class="o">)</span> <span class="o">{</span>
      	<span class="cm">/* 
      	   num为1时,方法返回1,
      	   相当于是方法的出口,num总有是1的情况
      	*/</span>
		<span class="k">if</span><span class="o">(</span><span class="n">num</span> <span class="o">==</span> <span class="mi">1</span><span class="o">){</span>
			<span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
		<span class="o">}</span>
      	<span class="cm">/*
          num不为1时,方法返回 num +(num-1)的累和
          递归调用getSum方法
        */</span>
		<span class="k">return</span> <span class="n">num</span> <span class="o">+</span> <span class="n">getSum</span><span class="o">(</span><span class="n">num</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h4 id="代码执行图解">代码执行图解</h4> <p><img src="https://blog.slienceme.cn/images/posts/2021012609570098.jpg" alt="Alt Text" /></p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
    练习:
        使用递归计算1-n之间的和
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo02Recurison</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="n">sum</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="cm">/*
        定义一个方法,使用递归计算1-n之间的和
        1+2+3+...+n
        n+(n-1)+(n-2)+...+1
        已知:
            最大值:n
            最小值:1
        使用递归必须明确:
            1.递归的结束条件
                获取到1的时候结束
            2.递归的目的
                获取下一个被加的数字(n-1)
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">sum</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">){</span>
        <span class="c1">//获取到1的时候结束</span>
        <span class="k">if</span><span class="o">(</span><span class="n">n</span><span class="o">==</span><span class="mi">1</span><span class="o">){</span>
            <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">//获取下一个被加的数字(n-1)</span>
        <span class="k">return</span> <span class="n">n</span> <span class="o">+</span> <span class="n">sum</span><span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p><img src="https://blog.slienceme.cn/images/posts/20210127104923528.bmp.jpg" alt="Alt Text" /></p> <blockquote> <p>小贴士：递归一定要有条件限定，保证递归能够停止下来，次数不要太多，否则会发生栈内存溢出。</p> </blockquote> <h3 id="23-递归求阶乘">2.3 递归求阶乘</h3> <ul> <li><strong>阶乘</strong>：所有小于及等于该数的正整数的积。</li> </ul> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">n的阶乘</span><span class="err">：</span><span class="n">n</span><span class="o">!</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">*...*</span> <span class="mi">3</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">1</span> 
</code></pre></div></div> <p><strong>分析</strong>：这与累和类似,只不过换成了乘法运算，学员可以自己练习，需要注意阶乘值符合int类型的范围。</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>推理得出：n! = n * (n-1)!
</code></pre></div></div> <p><strong>代码实现</strong>：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DiGuiDemo</span> <span class="o">{</span>
  	<span class="c1">//计算n的阶乘，使用递归完成</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
      	<span class="c1">// 调用求阶乘的方法</span>
        <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">getValue</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>
      	<span class="c1">// 输出结果</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"阶乘为:"</span><span class="o">+</span> <span class="n">value</span><span class="o">);</span>
    <span class="o">}</span>
	<span class="cm">/*
  	  通过递归算法实现.
  	  参数列表:int 
  	  返回值类型: int 
  	*/</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">getValue</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
      	<span class="c1">// 1的阶乘为1</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
      	<span class="cm">/*
      	  n不为1时,方法返回 n! = n*(n-1)!
          递归调用getValue方法
      	*/</span>
        <span class="k">return</span> <span class="n">n</span> <span class="o">*</span> <span class="n">getValue</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <hr /> <hr /> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
    练习:
        使用递归计算阶乘
        n的阶乘：n! = n * (n-1) *...* 3 * 2 * 1

 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo03Recurison</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">jiecheng</span> <span class="o">=</span> <span class="n">jc</span><span class="o">(</span><span class="mi">5</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">jiecheng</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="cm">/*
        定义方法使用递归计算阶乘
        5的阶乘: 5! = 5*(5-1)*(5-2)*(5-3)*(5-4)=5*4*3*2*1
        递归结束的条件
            获取到1的时候结束
        递归的目的
            获取下一个被乘的数字(n-1)
        方法的参数发生变化
            5,4,3,2,1
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">jc</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">){</span>
        <span class="c1">//获取到1的时候结束</span>
        <span class="k">if</span><span class="o">(</span><span class="n">n</span><span class="o">==</span><span class="mi">1</span><span class="o">){</span>
            <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">//获取下一个被乘的数字(n-1)</span>
        <span class="k">return</span> <span class="n">n</span> <span class="o">*</span> <span class="n">jc</span><span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div> <h3 id="24-递归打印多级目录">2.4 递归打印多级目录</h3> <p><strong>分析</strong>：多级目录的打印，就是当目录的嵌套。遍历之前，无从知道到底有多少级目录，所以我们还是要使用递归实现。</p> <p><strong>代码实现</strong>：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DiGuiDemo2</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
      	<span class="c1">// 创建File对象</span>
        <span class="nc">File</span> <span class="n">dir</span>  <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"D:\\aaa"</span><span class="o">);</span>
      	<span class="c1">// 调用打印目录方法</span>
        <span class="n">printDir</span><span class="o">(</span><span class="n">dir</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span>  <span class="nf">printDir</span><span class="o">(</span><span class="nc">File</span> <span class="n">dir</span><span class="o">)</span> <span class="o">{</span>
      	<span class="c1">// 获取子文件和目录</span>
        <span class="nc">File</span><span class="o">[]</span> <span class="n">files</span> <span class="o">=</span> <span class="n">dir</span><span class="o">.</span><span class="na">listFiles</span><span class="o">();</span>
      	<span class="c1">// 循环打印</span>
      	<span class="cm">/*
      	  判断:
      	  当是文件时,打印绝对路径.
      	  当是目录时,继续调用打印目录的方法,形成递归调用.
      	*/</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">File</span> <span class="n">file</span> <span class="o">:</span> <span class="n">files</span><span class="o">)</span> <span class="o">{</span>
    		<span class="c1">// 判断</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">file</span><span class="o">.</span><span class="na">isFile</span><span class="o">())</span> <span class="o">{</span>
              	<span class="c1">// 是文件,输出文件绝对路径</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"文件名:"</span><span class="o">+</span> <span class="n">file</span><span class="o">.</span><span class="na">getAbsolutePath</span><span class="o">());</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
              	<span class="c1">// 是目录,输出目录绝对路径</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"目录:"</span><span class="o">+</span><span class="n">file</span><span class="o">.</span><span class="na">getAbsolutePath</span><span class="o">());</span>
              	<span class="c1">// 继续遍历,调用printDir,形成递归</span>
                <span class="n">printDir</span><span class="o">(</span><span class="n">file</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p><img src="https://blog.slienceme.cn/images/posts/2021012711073186.bmp.jpg" alt="Alt Text" /></p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.io.File</span><span class="o">;</span>

<span class="cm">/*
    练习:
        递归打印多级目录
    需求:
        遍历c:\\abc文件夹,及abc文件夹的子文件夹
        c:\\abc
        c:\\abc\\abc.txt
        c:\\abc\\abc.java
        c:\\abc\\a
        c:\\abc\\a\\a.jpg
        c:\\abc\\a\\a.java
        c:\\abc\\b
        c:\\abc\\b\\b.java
        c:\\abc\\b\\b.txt
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo04Recurison</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">File</span> <span class="n">file</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"c:\\abc"</span><span class="o">);</span>
        <span class="n">getAllFile</span><span class="o">(</span><span class="n">file</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="cm">/*
        定义一个方法,参数传递File类型的目录
        方法中对目录进行遍历
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">getAllFile</span><span class="o">(</span><span class="nc">File</span> <span class="n">dir</span><span class="o">){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">dir</span><span class="o">);</span><span class="c1">//打印被遍历的目录名称</span>
        <span class="nc">File</span><span class="o">[]</span> <span class="n">files</span> <span class="o">=</span> <span class="n">dir</span><span class="o">.</span><span class="na">listFiles</span><span class="o">();</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">File</span> <span class="n">f</span> <span class="o">:</span> <span class="n">files</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">//对遍历得到的File对象f进行判断,判断是否是文件夹</span>
            <span class="k">if</span><span class="o">(</span><span class="n">f</span><span class="o">.</span><span class="na">isDirectory</span><span class="o">()){</span>
                <span class="c1">//f是一个文件夹,则继续遍历这个文件夹</span>
                <span class="c1">//我们发现getAllFile方法就是传递文件夹,遍历文件夹的方法</span>
                <span class="c1">//所以直接调用getAllFile方法即可:递归(自己调用自己)</span>
                <span class="n">getAllFile</span><span class="o">(</span><span class="n">f</span><span class="o">);</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="c1">//f是一个文件,直接打印即可</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">f</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h2 id="3-综合案例">3. 综合案例</h2> <h3 id="31-文件搜索">3.1 文件搜索</h3> <p>搜索<code class="language-plaintext highlighter-rouge">D:\aaa</code> 目录中的<code class="language-plaintext highlighter-rouge">.java</code> 文件。</p> <p><strong>分析</strong>：</p> <ol> <li>目录搜索，无法判断多少级目录，所以使用递归，遍历所有目录。</li> <li>遍历目录时，获取的子文件，通过文件名称，判断是否符合条件。</li> </ol> <p><strong>代码实现</strong>：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DiGuiDemo3</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 创建File对象</span>
        <span class="nc">File</span> <span class="n">dir</span>  <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"D:\\aaa"</span><span class="o">);</span>
      	<span class="c1">// 调用打印目录方法</span>
        <span class="n">printDir</span><span class="o">(</span><span class="n">dir</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">printDir</span><span class="o">(</span><span class="nc">File</span> <span class="n">dir</span><span class="o">)</span> <span class="o">{</span>
      	<span class="c1">// 获取子文件和目录</span>
        <span class="nc">File</span><span class="o">[]</span> <span class="n">files</span> <span class="o">=</span> <span class="n">dir</span><span class="o">.</span><span class="na">listFiles</span><span class="o">();</span>
      	
      	<span class="c1">// 循环打印</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">File</span> <span class="n">file</span> <span class="o">:</span> <span class="n">files</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">file</span><span class="o">.</span><span class="na">isFile</span><span class="o">())</span> <span class="o">{</span>
              	<span class="c1">// 是文件，判断文件名并输出文件绝对路径</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">file</span><span class="o">.</span><span class="na">getName</span><span class="o">().</span><span class="na">endsWith</span><span class="o">(</span><span class="s">".java"</span><span class="o">))</span> <span class="o">{</span>
                    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"文件名:"</span> <span class="o">+</span> <span class="n">file</span><span class="o">.</span><span class="na">getAbsolutePath</span><span class="o">());</span>
                <span class="o">}</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// 是目录，继续遍历,形成递归</span>
                <span class="n">printDir</span><span class="o">(</span><span class="n">file</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.io.File</span><span class="o">;</span>

<span class="cm">/*
    练习:
        递归打印多级目录
    需求:
        遍历c:\\abc文件夹,及abc文件夹的子文件夹
        只要.java结尾的文件
        c:\\abc
        c:\\abc\\abc.txt
        c:\\abc\\abc.java
        c:\\abc\\a
        c:\\abc\\a\\a.jpg
        c:\\abc\\a\\a.java
        c:\\abc\\b
        c:\\abc\\b\\b.java
        c:\\abc\\b\\b.txt
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo05Recurison</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">File</span> <span class="n">file</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"c:\\abc"</span><span class="o">);</span>
        <span class="n">getAllFile</span><span class="o">(</span><span class="n">file</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="cm">/*
        定义一个方法,参数传递File类型的目录
        方法中对目录进行遍历
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">getAllFile</span><span class="o">(</span><span class="nc">File</span> <span class="n">dir</span><span class="o">){</span>
        <span class="c1">//System.out.println(dir);//打印被遍历的目录名称</span>
        <span class="nc">File</span><span class="o">[]</span> <span class="n">files</span> <span class="o">=</span> <span class="n">dir</span><span class="o">.</span><span class="na">listFiles</span><span class="o">();</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">File</span> <span class="n">f</span> <span class="o">:</span> <span class="n">files</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">//对遍历得到的File对象f进行判断,判断是否是文件夹</span>
            <span class="k">if</span><span class="o">(</span><span class="n">f</span><span class="o">.</span><span class="na">isDirectory</span><span class="o">()){</span>
                <span class="c1">//f是一个文件夹,则继续遍历这个文件夹</span>
                <span class="c1">//我们发现getAllFile方法就是传递文件夹,遍历文件夹的方法</span>
                <span class="c1">//所以直接调用getAllFile方法即可:递归(自己调用自己)</span>
                <span class="n">getAllFile</span><span class="o">(</span><span class="n">f</span><span class="o">);</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="c1">//f是一个文件,直接打印即可</span>
                <span class="cm">/*
                    c:\\abc\\abc.java
                    只要.java结尾的文件
                    1.把File对象f,转为字符串对象
                 */</span>
                <span class="c1">//String name = f.getName();//abc.java</span>
                <span class="c1">//String path = f.getPath();//c:\\abc\\abc.java</span>
                <span class="c1">//String s = f.toString();//c:\\abc\\abc.java</span>

                <span class="c1">//把字符串,转换为小写</span>
                <span class="c1">//s = s.toLowerCase();</span>

                <span class="c1">//2.调用String类中的方法endsWith判断字符串是否是以.java结尾</span>
                <span class="c1">//boolean b = s.endsWith(".java");</span>

                <span class="c1">//3.如果是以.java结尾的文件,则输出</span>
                <span class="cm">/*if(b){
                    System.out.println(f);
                }*/</span>

                <span class="k">if</span><span class="o">(</span><span class="n">f</span><span class="o">.</span><span class="na">getName</span><span class="o">().</span><span class="na">toLowerCase</span><span class="o">().</span><span class="na">endsWith</span><span class="o">(</span><span class="s">".java"</span><span class="o">)){</span>
                    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">f</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h3 id="32-文件过滤器优化">3.2 文件过滤器优化</h3> <p><code class="language-plaintext highlighter-rouge">java.io.FileFilter</code>是一个接口，是File的过滤器。 该接口的对象可以传递给File类的<code class="language-plaintext highlighter-rouge">listFiles(FileFilter)</code> 作为参数， 接口中只有一个方法。</p> <p><code class="language-plaintext highlighter-rouge">boolean accept(File pathname) </code> ：测试pathname是否应该包含在当前File目录中，符合则返回true。</p> <p><strong>分析</strong>：</p> <ol> <li>接口作为参数，需要传递子类对象，重写其中方法。我们选择匿名内部类方式，比较简单。</li> <li><code class="language-plaintext highlighter-rouge">accept</code>方法，参数为File，表示当前File下所有的子文件和子目录。保留住则返回true，过滤掉则返回false。保留规则： <ol> <li>要么是.java文件。</li> <li>要么是目录，用于继续遍历。</li> </ol> </li> <li>通过过滤器的作用，<code class="language-plaintext highlighter-rouge">listFiles(FileFilter)</code>返回的数组元素中，子文件对象都是符合条件的，可以直接打印。</li> </ol> <p><strong>代码实现：</strong></p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DiGuiDemo4</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">File</span> <span class="n">dir</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"D:\\aaa"</span><span class="o">);</span>
        <span class="n">printDir2</span><span class="o">(</span><span class="n">dir</span><span class="o">);</span>
    <span class="o">}</span>
  
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">printDir2</span><span class="o">(</span><span class="nc">File</span> <span class="n">dir</span><span class="o">)</span> <span class="o">{</span>
      	<span class="c1">// 匿名内部类方式,创建过滤器子类对象</span>
        <span class="nc">File</span><span class="o">[]</span> <span class="n">files</span> <span class="o">=</span> <span class="n">dir</span><span class="o">.</span><span class="na">listFiles</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileFilter</span><span class="o">()</span> <span class="o">{</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">accept</span><span class="o">(</span><span class="nc">File</span> <span class="n">pathname</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">pathname</span><span class="o">.</span><span class="na">getName</span><span class="o">().</span><span class="na">endsWith</span><span class="o">(</span><span class="s">".java"</span><span class="o">)||</span><span class="n">pathname</span><span class="o">.</span><span class="na">isDirectory</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">});</span>
      	<span class="c1">// 循环打印</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">File</span> <span class="n">file</span> <span class="o">:</span> <span class="n">files</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">file</span><span class="o">.</span><span class="na">isFile</span><span class="o">())</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"文件名:"</span> <span class="o">+</span> <span class="n">file</span><span class="o">.</span><span class="na">getAbsolutePath</span><span class="o">());</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">printDir2</span><span class="o">(</span><span class="n">file</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>      
</code></pre></div></div> <p><img src="https://blog.slienceme.cn/images/posts/20210127111002104.bmp.jpg" alt="Alt Text" /></p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.io.File</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.FileFilter</span><span class="o">;</span>

<span class="cm">/*
    创建过滤器FileFilter的实现类,重写过滤方法accept,定义过滤规则
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">FileFilterImpl</span> <span class="kd">implements</span> <span class="nc">FileFilter</span><span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">accept</span><span class="o">(</span><span class="nc">File</span> <span class="n">pathname</span><span class="o">)</span> <span class="o">{</span>
        <span class="cm">/*
            过滤的规则:
            在accept方法中,判断File对象是否是以.java结尾
            是就返回true
            不是就返回false
         */</span>
        <span class="c1">//如果pathname是一个文件夹,返回true,继续遍历这个文件夹</span>
        <span class="k">if</span><span class="o">(</span><span class="n">pathname</span><span class="o">.</span><span class="na">isDirectory</span><span class="o">()){</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">pathname</span><span class="o">.</span><span class="na">getName</span><span class="o">().</span><span class="na">toLowerCase</span><span class="o">().</span><span class="na">endsWith</span><span class="o">(</span><span class="s">".java"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.io.File</span><span class="o">;</span>

<span class="cm">/*
    需求:
        遍历c:\\abc文件夹,及abc文件夹的子文件夹
        只要.java结尾的文件
        c:\\abc
        c:\\abc\\abc.txt
        c:\\abc\\abc.java
        c:\\abc\\a
        c:\\abc\\a\\a.jpg
        c:\\abc\\a\\a.java
        c:\\abc\\b
        c:\\abc\\b\\b.java
        c:\\abc\\b\\b.txt
    我们可以使用过滤器来实现
    在File类中有两个和ListFiles重载的方法,方法的参数传递的就是过滤器
    File[] listFiles(FileFilter filter)
    java.io.FileFilter接口:用于抽象路径名(File对象)的过滤器。
        作用:用来过滤文件(File对象)
        抽象方法:用来过滤文件的方法
            boolean accept(File pathname) 测试指定抽象路径名是否应该包含在某个路径名列表中。
            参数:
                File pathname:使用ListFiles方法遍历目录,得到的每一个文件对象
    File[] listFiles(FilenameFilter filter)
    java.io.FilenameFilter接口:实现此接口的类实例可用于过滤器文件名。
        作用:用于过滤文件名称
        抽象方法:用来过滤文件的方法
            boolean accept(File dir, String name) 测试指定文件是否应该包含在某一文件列表中。
            参数:
                File dir:构造方法中传递的被遍历的目录
                String name:使用ListFiles方法遍历目录,获取的每一个文件/文件夹的名称
    注意:
        两个过滤器接口是没有实现类的,需要我们自己写实现类,重写过滤的方法accept,在方法中自己定义过滤的规则
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo01Filter</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">File</span> <span class="n">file</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"c:\\abc"</span><span class="o">);</span>
        <span class="n">getAllFile</span><span class="o">(</span><span class="n">file</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="cm">/*
        定义一个方法,参数传递File类型的目录
        方法中对目录进行遍历
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">getAllFile</span><span class="o">(</span><span class="nc">File</span> <span class="n">dir</span><span class="o">){</span>
        <span class="nc">File</span><span class="o">[]</span> <span class="n">files</span> <span class="o">=</span> <span class="n">dir</span><span class="o">.</span><span class="na">listFiles</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileFilterImpl</span><span class="o">());</span><span class="c1">//传递过滤器对象</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">File</span> <span class="n">f</span> <span class="o">:</span> <span class="n">files</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">//对遍历得到的File对象f进行判断,判断是否是文件夹</span>
            <span class="k">if</span><span class="o">(</span><span class="n">f</span><span class="o">.</span><span class="na">isDirectory</span><span class="o">()){</span>
                <span class="c1">//f是一个文件夹,则继续遍历这个文件夹</span>
                <span class="c1">//我们发现getAllFile方法就是传递文件夹,遍历文件夹的方法</span>
                <span class="c1">//所以直接调用getAllFile方法即可:递归(自己调用自己)</span>
                <span class="n">getAllFile</span><span class="o">(</span><span class="n">f</span><span class="o">);</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="c1">//f是一个文件,直接打印即可</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">f</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h3 id="33-lambda优化">3.3 Lambda优化</h3> <p><strong>分析：</strong><code class="language-plaintext highlighter-rouge">FileFilter</code>是只有一个方法的接口，因此可以用lambda表达式简写。</p> <p>lambda格式：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">()-&gt;{</span> <span class="o">}</span>
</code></pre></div></div> <p><strong>代码实现：</strong></p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">printDir3</span><span class="o">(</span><span class="nc">File</span> <span class="n">dir</span><span class="o">)</span> <span class="o">{</span>
  	<span class="c1">// lambda的改写</span>
    <span class="nc">File</span><span class="o">[]</span> <span class="n">files</span> <span class="o">=</span> <span class="n">dir</span><span class="o">.</span><span class="na">listFiles</span><span class="o">(</span><span class="n">f</span> <span class="o">-&gt;{</span> 
      	<span class="k">return</span> <span class="n">f</span><span class="o">.</span><span class="na">getName</span><span class="o">().</span><span class="na">endsWith</span><span class="o">(</span><span class="s">".java"</span><span class="o">)</span> <span class="o">||</span> <span class="n">f</span><span class="o">.</span><span class="na">isDirectory</span><span class="o">();</span> 
    <span class="o">});</span>
  	
	<span class="c1">// 循环打印</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">File</span> <span class="n">file</span> <span class="o">:</span> <span class="n">files</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">file</span><span class="o">.</span><span class="na">isFile</span><span class="o">())</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"文件名:"</span> <span class="o">+</span> <span class="n">file</span><span class="o">.</span><span class="na">getAbsolutePath</span><span class="o">());</span>
      	<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        	<span class="n">printDir3</span><span class="o">(</span><span class="n">file</span><span class="o">);</span>
      	<span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.io.File</span><span class="o">;</span>

<span class="cm">/*
    需求:
        遍历c:\\abc文件夹,及abc文件夹的子文件夹
        只要.java结尾的文件
        c:\\abc
        c:\\abc\\abc.txt
        c:\\abc\\abc.java
        c:\\abc\\a
        c:\\abc\\a\\a.jpg
        c:\\abc\\a\\a.java
        c:\\abc\\b
        c:\\abc\\b\\b.java
        c:\\abc\\b\\b.txt
    我们可以使用过滤器来实现
    在File类中有两个和ListFiles重载的方法,方法的参数传递的就是过滤器
    File[] listFiles(FileFilter filter)
    java.io.FileFilter接口:用于抽象路径名(File对象)的过滤器。
        作用:用来过滤文件(File对象)
        抽象方法:用来过滤文件的方法
            boolean accept(File pathname) 测试指定抽象路径名是否应该包含在某个路径名列表中。
            参数:
                File pathname:使用ListFiles方法遍历目录,得到的每一个文件对象
    File[] listFiles(FilenameFilter filter)
    java.io.FilenameFilter接口:实现此接口的类实例可用于过滤器文件名。
        作用:用于过滤文件名称
        抽象方法:用来过滤文件的方法
            boolean accept(File dir, String name) 测试指定文件是否应该包含在某一文件列表中。
            参数:
                File dir:构造方法中传递的被遍历的目录
                String name:使用ListFiles方法遍历目录,获取的每一个文件/文件夹的名称
    注意:
        两个过滤器接口是没有实现类的,需要我们自己写实现类,重写过滤的方法accept,在方法中自己定义过滤的规则
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo02Filter</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">File</span> <span class="n">file</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"c:\\abc"</span><span class="o">);</span>
        <span class="n">getAllFile</span><span class="o">(</span><span class="n">file</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="cm">/*
        定义一个方法,参数传递File类型的目录
        方法中对目录进行遍历
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">getAllFile</span><span class="o">(</span><span class="nc">File</span> <span class="n">dir</span><span class="o">){</span>
        <span class="c1">//传递过滤器对象 使用匿名内部类</span>
        <span class="cm">/*File[] files = dir.listFiles(new FileFilter() {
            @Override
            public boolean accept(File pathname) {
                //过滤规则,pathname是文件夹或者是.java结尾的文件返回true
                return pathname.isDirectory() || pathname.getName().toLowerCase().endsWith(".java");
            }
        });*/</span>

        <span class="c1">//使用Lambda表达式优化匿名内部类(接口中只有一个抽象方法)</span>
        <span class="cm">/*File[] files = dir.listFiles((File pathname)-&gt;{
            return pathname.isDirectory() || pathname.getName().toLowerCase().endsWith(".java");
        });*/</span>

        <span class="nc">File</span><span class="o">[]</span> <span class="n">files</span> <span class="o">=</span> <span class="n">dir</span><span class="o">.</span><span class="na">listFiles</span><span class="o">(</span><span class="n">pathname</span><span class="o">-&gt;</span><span class="n">pathname</span><span class="o">.</span><span class="na">isDirectory</span><span class="o">()</span> <span class="o">||</span> <span class="n">pathname</span><span class="o">.</span><span class="na">getName</span><span class="o">().</span><span class="na">toLowerCase</span><span class="o">().</span><span class="na">endsWith</span><span class="o">(</span><span class="s">".java"</span><span class="o">));</span>

        <span class="cm">/*File[] files = dir.listFiles(new FilenameFilter() {
            @Override
            public boolean accept(File dir, String name) {
                //过滤规则,pathname是文件夹或者是.java结尾的文件返回true
                return new File(dir,name).isDirectory() || name.toLowerCase().endsWith(".java");
            }
        });*/</span>

        <span class="c1">//使用Lambda表达式优化匿名内部类(接口中只有一个抽象方法)</span>
        <span class="cm">/*File[] files = dir.listFiles((File d, String name)-&gt;{
            //过滤规则,pathname是文件夹或者是.java结尾的文件返回true
            return new File(d,name).isDirectory() || name.toLowerCase().endsWith(".java");
        });*/</span>

        <span class="c1">//File[] files = dir.listFiles((d,name)-&gt;new File(d,name).isDirectory() || name.toLowerCase().endsWith(".java"));</span>

        <span class="k">for</span> <span class="o">(</span><span class="nc">File</span> <span class="n">f</span> <span class="o">:</span> <span class="n">files</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">//对遍历得到的File对象f进行判断,判断是否是文件夹</span>
            <span class="k">if</span><span class="o">(</span><span class="n">f</span><span class="o">.</span><span class="na">isDirectory</span><span class="o">()){</span>
                <span class="c1">//f是一个文件夹,则继续遍历这个文件夹</span>
                <span class="c1">//我们发现getAllFile方法就是传递文件夹,遍历文件夹的方法</span>
                <span class="c1">//所以直接调用getAllFile方法即可:递归(自己调用自己)</span>
                <span class="n">getAllFile</span><span class="o">(</span><span class="n">f</span><span class="o">);</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="c1">//f是一个文件,直接打印即可</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">f</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h2 id="4-io概述">4. IO概述</h2> <p><img src="https://blog.slienceme.cn/images/posts/20210127113040233.bmp.jpg" alt="Alt Text" /></p> <h3 id="41-什么是io">4.1 什么是IO</h3> <p>生活中，你肯定经历过这样的场景。当你编辑一个文本文件，忘记了<code class="language-plaintext highlighter-rouge">ctrl+s</code> ，可能文件就白白编辑了。当你电脑上插入一个U盘，可以把一个视频，拷贝到你的电脑硬盘里。那么数据都是在哪些设备上的呢？键盘、内存、硬盘、外接设备等等。</p> <p>我们把这种数据的传输，可以看做是一种数据的流动，按照流动的方向，以内存为基准，分为<code class="language-plaintext highlighter-rouge">输入input</code> 和<code class="language-plaintext highlighter-rouge">输出output</code> ，即流向内存是输入流，流出内存的输出流。</p> <p>Java中I/O操作主要是指使用<code class="language-plaintext highlighter-rouge">java.io</code>包下的内容，进行输入、输出操作。<strong>输入</strong>也叫做<strong>读取</strong>数据，<strong>输出</strong>也叫做作<strong>写出</strong>数据。</p> <h3 id="42-io的分类">4.2 IO的分类</h3> <p>根据数据的流向分为：<strong>输入流</strong>和<strong>输出流</strong>。</p> <ul> <li><strong>输入流</strong> ：把数据从<code class="language-plaintext highlighter-rouge">其他设备</code>上读取到<code class="language-plaintext highlighter-rouge">内存</code>中的流。</li> <li><strong>输出流</strong> ：把数据从<code class="language-plaintext highlighter-rouge">内存</code> 中写出到<code class="language-plaintext highlighter-rouge">其他设备</code>上的流。</li> </ul> <p>格局数据的类型分为：<strong>字节流</strong>和<strong>字符流</strong>。</p> <ul> <li><strong>字节流</strong> ：以字节为单位，读写数据的流。</li> <li><strong>字符流</strong> ：以字符为单位，读写数据的流。</li> </ul> <h3 id="43-io的流向说明图解">4.3 IO的流向说明图解</h3> <p><img src="https://blog.slienceme.cn/images/posts/20210126095722618.jpg" alt="Alt Text" /></p> <h3 id="44-顶级父类们">4.4 顶级父类们</h3> <table> <thead> <tr> <th style="text-align: center"> </th> <th style="text-align: center"><strong>输入流</strong></th> <th style="text-align: center">输出流</th> </tr> </thead> <tbody> <tr> <td style="text-align: center"><strong>字节流</strong></td> <td style="text-align: center">字节输入流<br /><strong>InputStream</strong></td> <td style="text-align: center">字节输出流<br /><strong>OutputStream</strong></td> </tr> <tr> <td style="text-align: center"><strong>字符流</strong></td> <td style="text-align: center">字符输入流<br /><strong>Reader</strong></td> <td style="text-align: center">字符输出流<br /><strong>Writer</strong></td> </tr> </tbody> </table> <h2 id="5-字节流">5. 字节流</h2> <h3 id="51-一切皆为字节">5.1 一切皆为字节</h3> <p>一切文件数据(文本、图片、视频等)在存储时，都是以二进制数字的形式保存，都一个一个的字节，那么传输时一样如此。所以，字节流可以传输任意文件数据。在操作流的时候，我们要时刻明确，无论使用什么样的流对象，底层传输的始终为二进制数据。</p> <h3 id="52-字节输出流outputstream">5.2 字节输出流【OutputStream】</h3> <p><code class="language-plaintext highlighter-rouge">java.io.OutputStream </code>抽象类是表示字节输出流的所有类的超类，将指定的字节信息写出到目的地。它定义了字节输出流的基本共性功能方法。</p> <ul> <li><code class="language-plaintext highlighter-rouge">public void close()</code> ：关闭此输出流并释放与此流相关联的任何系统资源。</li> <li><code class="language-plaintext highlighter-rouge">public void flush() </code> ：刷新此输出流并强制任何缓冲的输出字节被写出。</li> <li><code class="language-plaintext highlighter-rouge">public void write(byte[] b)</code>：将 b.length字节从指定的字节数组写入此输出流。</li> <li><code class="language-plaintext highlighter-rouge">public void write(byte[] b, int off, int len)</code> ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。</li> <li><code class="language-plaintext highlighter-rouge">public abstract void write(int b)</code> ：将指定的字节输出流。</li> </ul> <blockquote> <p>小贴士：</p> <p>close方法，当完成流的操作时，必须调用此方法，释放系统资源。</p> </blockquote> <h3 id="53-fileoutputstream类">5.3 FileOutputStream类</h3> <p><code class="language-plaintext highlighter-rouge">OutputStream</code>有很多子类，我们从最简单的一个子类开始。</p> <p><code class="language-plaintext highlighter-rouge">java.io.FileOutputStream </code>类是文件输出流，用于将数据写出到文件。</p> <h4 id="构造方法">构造方法</h4> <ul> <li><code class="language-plaintext highlighter-rouge">public FileOutputStream(File file)</code>：创建文件输出流以写入由指定的 File对象表示的文件。</li> <li><code class="language-plaintext highlighter-rouge">public FileOutputStream(String name)</code>： 创建文件输出流以指定的名称写入文件。</li> </ul> <p>当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有这个文件，会创建该文件。如果有这个文件，会清空这个文件的数据。</p> <ul> <li>构造举例，代码如下：</li> </ul> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FileOutputStreamConstructor</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
   	 	<span class="c1">// 使用File对象创建流对象</span>
        <span class="nc">File</span> <span class="n">file</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"a.txt"</span><span class="o">);</span>
        <span class="nc">FileOutputStream</span> <span class="n">fos</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="n">file</span><span class="o">);</span>
      
        <span class="c1">// 使用文件名称创建流对象</span>
        <span class="nc">FileOutputStream</span> <span class="n">fos</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"b.txt"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.io.FileOutputStream</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>

<span class="cm">/*
    java.io.OutputStream:字节输出流
        此抽象类是表示输出字节流的所有类的超类。

    定义了一些子类共性的成员方法:
        - public void close() ：关闭此输出流并释放与此流相关联的任何系统资源。
        - public void flush() ：刷新此输出流并强制任何缓冲的输出字节被写出。
        - public void write(byte[] b)：将 b.length字节从指定的字节数组写入此输出流。
        - public void write(byte[] b, int off, int len) ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。
        - public abstract void write(int b) ：将指定的字节输出流。

    java.io.FileOutputStream extends OutputStream
    FileOutputStream:文件字节输出流
    作用:把内存中的数据写入到硬盘的文件中

    构造方法:
        FileOutputStream(String name)创建一个向具有指定名称的文件中写入数据的输出文件流。
        FileOutputStream(File file) 创建一个向指定 File 对象表示的文件中写入数据的文件输出流。
        参数:写入数据的目的
            String name:目的地是一个文件的路径
            File file:目的地是一个文件
        构造方法的作用:
            1.创建一个FileOutputStream对象
            2.会根据构造方法中传递的文件/文件路径,创建一个空的文件
            3.会把FileOutputStream对象指向创建好的文件

    写入数据的原理(内存--&gt;硬盘)
        java程序--&gt;JVM(java虚拟机)--&gt;OS(操作系统)--&gt;OS调用写数据的方法--&gt;把数据写入到文件中

    字节输出流的使用步骤(重点):
        1.创建一个FileOutputStream对象,构造方法中传递写入数据的目的地
        2.调用FileOutputStream对象中的方法write,把数据写入到文件中
        3.释放资源(流使用会占用一定的内存,使用完毕要把内存清空,提供程序的效率)
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo01OutputStream</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="c1">//1.创建一个FileOutputStream对象,构造方法中传递写入数据的目的地</span>
        <span class="nc">FileOutputStream</span> <span class="n">fos</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"09_IOAndProperties\\a.txt"</span><span class="o">);</span>
        <span class="c1">//2.调用FileOutputStream对象中的方法write,把数据写入到文件中</span>
        <span class="c1">//public abstract void write(int b) ：将指定的字节输出流。</span>
        <span class="n">fos</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="mi">97</span><span class="o">);</span>
        <span class="c1">//3.释放资源(流使用会占用一定的内存,使用完毕要把内存清空,提供程序的效率)</span>
        <span class="c1">//fos.close();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p><img src="https://blog.slienceme.cn/images/posts/20210127114315337.bmp.jpg" alt="Alt Text" /></p> <h4 id="写出字节数据">写出字节数据</h4> <ol> <li><strong>写出字节</strong>：<code class="language-plaintext highlighter-rouge">write(int b)</code> 方法，每次可以写出一个字节数据，代码使用演示：</li> </ol> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FOSWrite</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="c1">// 使用文件名称创建流对象</span>
        <span class="nc">FileOutputStream</span> <span class="n">fos</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"fos.txt"</span><span class="o">);</span>     
      	<span class="c1">// 写出数据</span>
      	<span class="n">fos</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="mi">97</span><span class="o">);</span> <span class="c1">// 写出第1个字节</span>
      	<span class="n">fos</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="mi">98</span><span class="o">);</span> <span class="c1">// 写出第2个字节</span>
      	<span class="n">fos</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="mi">99</span><span class="o">);</span> <span class="c1">// 写出第3个字节</span>
      	<span class="c1">// 关闭资源</span>
        <span class="n">fos</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="n">输出结果</span><span class="err">：</span>
<span class="n">abc</span>
</code></pre></div></div> <blockquote> <p>小贴士：</p> <ol> <li>虽然参数为int类型四个字节，但是只会保留一个字节的信息写出。</li> <li>流操作完毕后，必须释放系统资源，调用close方法，千万记得。</li> </ol> </blockquote> <ol> <li><strong>写出字节数组</strong>：<code class="language-plaintext highlighter-rouge">write(byte[] b)</code>，每次可以写出数组中的数据，代码使用演示：</li> </ol> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FOSWrite</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="c1">// 使用文件名称创建流对象</span>
        <span class="nc">FileOutputStream</span> <span class="n">fos</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"fos.txt"</span><span class="o">);</span>     
      	<span class="c1">// 字符串转换为字节数组</span>
      	<span class="kt">byte</span><span class="o">[]</span> <span class="n">b</span> <span class="o">=</span> <span class="s">"程序员"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">();</span>
      	<span class="c1">// 写出字节数组数据</span>
      	<span class="n">fos</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">b</span><span class="o">);</span>
      	<span class="c1">// 关闭资源</span>
        <span class="n">fos</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="n">输出结果</span><span class="err">：</span>
<span class="n">程序员</span>
</code></pre></div></div> <ol> <li><strong>写出指定长度字节数组</strong>：<code class="language-plaintext highlighter-rouge">write(byte[] b, int off, int len)</code> ,每次写出从off索引开始，len个字节，代码使用演示：</li> </ol> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FOSWrite</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="c1">// 使用文件名称创建流对象</span>
        <span class="nc">FileOutputStream</span> <span class="n">fos</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"fos.txt"</span><span class="o">);</span>     
      	<span class="c1">// 字符串转换为字节数组</span>
      	<span class="kt">byte</span><span class="o">[]</span> <span class="n">b</span> <span class="o">=</span> <span class="s">"abcde"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">();</span>
		<span class="c1">// 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。</span>
        <span class="n">fos</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">b</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">);</span>
      	<span class="c1">// 关闭资源</span>
        <span class="n">fos</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="n">输出结果</span><span class="err">：</span>
<span class="n">cd</span>
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.io.File</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.FileOutputStream</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="cm">/*
    一次写多个字节的方法:
        - public void write(byte[] b)：将 b.length字节从指定的字节数组写入此输出流。
        - public void write(byte[] b, int off, int len) ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo02OutputStream</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="c1">//创建FileOutputStream对象,构造方法中绑定要写入数据的目的地</span>
        <span class="nc">FileOutputStream</span> <span class="n">fos</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"09_IOAndProperties\\b.txt"</span><span class="o">));</span>
        <span class="c1">//调用FileOutputStream对象中的方法write,把数据写入到文件中</span>
        <span class="c1">//在文件中显示100,写个字节</span>
        <span class="n">fos</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="mi">49</span><span class="o">);</span>
        <span class="n">fos</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="mi">48</span><span class="o">);</span>
        <span class="n">fos</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="mi">48</span><span class="o">);</span>

        <span class="cm">/*
            public void write(byte[] b)：将 b.length字节从指定的字节数组写入此输出流。
            一次写多个字节:
                如果写的第一个字节是正数(0-127),那么显示的时候会查询ASCII表
                如果写的第一个字节是负数,那第一个字节会和第二个字节,两个字节组成一个中文显示,查询系统默认码表(GBK)
         */</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">bytes</span> <span class="o">=</span> <span class="o">{</span><span class="mi">65</span><span class="o">,</span><span class="mi">66</span><span class="o">,</span><span class="mi">67</span><span class="o">,</span><span class="mi">68</span><span class="o">,</span><span class="mi">69</span><span class="o">};</span><span class="c1">//ABCDE</span>
        <span class="c1">//byte[] bytes = {-65,-66,-67,68,69};//烤紻E</span>
        <span class="n">fos</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">bytes</span><span class="o">);</span>

        <span class="cm">/*
            public void write(byte[] b, int off, int len) ：把字节数组的一部分写入到文件中
                int off:数组的开始索引
                int len:写几个字节
         */</span>
        <span class="n">fos</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">bytes</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">);</span><span class="c1">//BC</span>

        <span class="cm">/*
            写入字符的方法:可以使用String类中的方法把字符串,转换为字节数组
                byte[] getBytes()  把字符串转换为字节数组
         */</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">bytes2</span> <span class="o">=</span> <span class="s">"你好"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">bytes2</span><span class="o">));</span><span class="c1">//[-28, -67, -96, -27, -91, -67]</span>
        <span class="n">fos</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">bytes2</span><span class="o">);</span>

        <span class="c1">//释放资源</span>
        <span class="n">fos</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h4 id="数据追加续写">数据追加续写</h4> <p>经过以上的演示，每次程序运行，创建输出流对象，都会清空目标文件中的数据。如何保留目标文件中数据，还能继续添加新数据呢？</p> <ul> <li><code class="language-plaintext highlighter-rouge">public FileOutputStream(File file, boolean append)</code>： 创建文件输出流以写入由指定的 File对象表示的文件。</li> <li><code class="language-plaintext highlighter-rouge">public FileOutputStream(String name, boolean append)</code>： 创建文件输出流以指定的名称写入文件。</li> </ul> <p>这两个构造方法，参数中都需要传入一个boolean类型的值，<code class="language-plaintext highlighter-rouge">true</code> 表示追加数据，<code class="language-plaintext highlighter-rouge">false</code> 表示清空原有数据。这样创建的输出流对象，就可以指定是否追加续写了，代码使用演示：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FOSWrite</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="c1">// 使用文件名称创建流对象</span>
        <span class="nc">FileOutputStream</span> <span class="n">fos</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"fos.txt"</span><span class="err">，</span><span class="kc">true</span><span class="o">);</span>     
      	<span class="c1">// 字符串转换为字节数组</span>
      	<span class="kt">byte</span><span class="o">[]</span> <span class="n">b</span> <span class="o">=</span> <span class="s">"abcde"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">();</span>
		<span class="c1">// 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。</span>
        <span class="n">fos</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">b</span><span class="o">);</span>
      	<span class="c1">// 关闭资源</span>
        <span class="n">fos</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="n">文件操作前</span><span class="err">：</span><span class="n">cd</span>
<span class="n">文件操作后</span><span class="err">：</span><span class="n">cdabcde</span>
</code></pre></div></div> <h4 id="写出换行">写出换行</h4> <p>Windows系统里，换行符号是<code class="language-plaintext highlighter-rouge">\r\n</code> 。把</p> <p>以指定是否追加续写了，代码使用演示：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FOSWrite</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="c1">// 使用文件名称创建流对象</span>
        <span class="nc">FileOutputStream</span> <span class="n">fos</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"fos.txt"</span><span class="o">);</span>  
      	<span class="c1">// 定义字节数组</span>
      	<span class="kt">byte</span><span class="o">[]</span> <span class="n">words</span> <span class="o">=</span> <span class="o">{</span><span class="mi">97</span><span class="o">,</span><span class="mi">98</span><span class="o">,</span><span class="mi">99</span><span class="o">,</span><span class="mi">100</span><span class="o">,</span><span class="mi">101</span><span class="o">};</span>
      	<span class="c1">// 遍历数组</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">words</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
          	<span class="c1">// 写出一个字节</span>
            <span class="n">fos</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">words</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
          	<span class="c1">// 写出一个换行, 换行符号转成数组写出</span>
            <span class="n">fos</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"\r\n"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">());</span>
        <span class="o">}</span>
      	<span class="c1">// 关闭资源</span>
        <span class="n">fos</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="n">输出结果</span><span class="err">：</span>
<span class="n">a</span>
<span class="n">b</span>
<span class="n">c</span>
<span class="n">d</span>
<span class="n">e</span>
</code></pre></div></div> <blockquote> <ul> <li>回车符<code class="language-plaintext highlighter-rouge">\r</code>和换行符<code class="language-plaintext highlighter-rouge">\n</code> ： <ul> <li>回车符：回到一行的开头（return）。</li> <li>换行符：下一行（newline）。</li> </ul> </li> <li>系统中的换行： <ul> <li>Windows系统里，每行结尾是 <code class="language-plaintext highlighter-rouge">回车+换行</code> ，即<code class="language-plaintext highlighter-rouge">\r\n</code>；</li> <li>Unix系统里，每行结尾只有 <code class="language-plaintext highlighter-rouge">换行</code> ，即<code class="language-plaintext highlighter-rouge">\n</code>；</li> <li>Mac系统里，每行结尾是 <code class="language-plaintext highlighter-rouge">回车</code> ，即<code class="language-plaintext highlighter-rouge">\r</code>。从 Mac OS X开始与Linux统一。</li> </ul> </li> </ul> </blockquote> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.io.FileOutputStream</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>

<span class="cm">/*
    追加写/续写:使用两个参数的构造方法
        FileOutputStream(String name, boolean append)创建一个向具有指定 name 的文件中写入数据的输出文件流。
        FileOutputStream(File file, boolean append) 创建一个向指定 File 对象表示的文件中写入数据的文件输出流。
        参数:
           String name,File file:写入数据的目的地
           boolean append:追加写开关
            true:创建对象不会覆盖源文件,继续在文件的末尾追加写数据
            false:创建一个新文件,覆盖源文件
    写换行:写换行符号
        windows:\r\n
        linux:/n
        mac:/r
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo03OutputStream</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="nc">FileOutputStream</span> <span class="n">fos</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"09_IOAndProperties\\c.txt"</span><span class="o">,</span><span class="kc">true</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span><span class="mi">10</span> <span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">fos</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"你好"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">());</span>
            <span class="n">fos</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"\r\n"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">());</span>
        <span class="o">}</span>

        <span class="n">fos</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h3 id="54-字节输入流inputstream">5.4 字节输入流【InputStream】</h3> <p><code class="language-plaintext highlighter-rouge">java.io.InputStream </code>抽象类是表示字节输入流的所有类的超类，可以读取字节信息到内存中。它定义了字节输入流的基本共性功能方法。</p> <ul> <li><code class="language-plaintext highlighter-rouge">public void close()</code> ：关闭此输入流并释放与此流相关联的任何系统资源。</li> <li><code class="language-plaintext highlighter-rouge">public abstract int read()</code>： 从输入流读取数据的下一个字节。</li> <li><code class="language-plaintext highlighter-rouge">public int read(byte[] b)</code>： 从输入流中读取一些字节数，并将它们存储到字节数组 b中 。</li> </ul> <blockquote> <p>小贴士：</p> <p>close方法，当完成流的操作时，必须调用此方法，释放系统资源。</p> </blockquote> <h3 id="55-fileinputstream类">5.5 FileInputStream类</h3> <p><code class="language-plaintext highlighter-rouge">java.io.FileInputStream </code>类是文件输入流，从文件中读取字节。</p> <h4 id="构造方法-1">构造方法</h4> <ul> <li><code class="language-plaintext highlighter-rouge">FileInputStream(File file)</code>： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的 File对象 file命名。</li> <li><code class="language-plaintext highlighter-rouge">FileInputStream(String name)</code>： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名 name命名。</li> </ul> <p>当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有该文件,会抛出<code class="language-plaintext highlighter-rouge">FileNotFoundException</code> 。</p> <ul> <li>构造举例，代码如下：</li> </ul> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FileInputStreamConstructor</span> <span class="kd">throws</span> <span class="nc">IOException</span><span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
   	 	<span class="c1">// 使用File对象创建流对象</span>
        <span class="nc">File</span> <span class="n">file</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"a.txt"</span><span class="o">);</span>
        <span class="nc">FileInputStream</span> <span class="n">fos</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="n">file</span><span class="o">);</span>
      
        <span class="c1">// 使用文件名称创建流对象</span>
        <span class="nc">FileInputStream</span> <span class="n">fos</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"b.txt"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <hr /> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kn">import</span> <span class="nn">java.io.FileInputStream</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>

<span class="cm">/*
    java.io.InputStream:字节输入流
    此抽象类是表示字节输入流的所有类的超类。

    定义了所有子类共性的方法:
         int read()从输入流中读取数据的下一个字节。
         int read(byte[] b) 从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b 中。
         void close() 关闭此输入流并释放与该流关联的所有系统资源。

    java.io.FileInputStream extends InputStream
    FileInputStream:文件字节输入流
    作用:把硬盘文件中的数据,读取到内存中使用

    构造方法:
        FileInputStream(String name)
        FileInputStream(File file)
        参数:读取文件的数据源
            String name:文件的路径
            File file:文件
        构造方法的作用:
            1.会创建一个FileInputStream对象
            2.会把FileInputStream对象指定构造方法中要读取的文件

    读取数据的原理(硬盘--&gt;内存)
        java程序--&gt;JVM--&gt;OS--&gt;OS读取数据的方法--&gt;读取文件

    字节输入流的使用步骤(重点):
        1.创建FileInputStream对象,构造方法中绑定要读取的数据源
        2.使用FileInputStream对象中的方法read,读取文件
        3.释放资源
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo01InputStream</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="c1">//1.创建FileInputStream对象,构造方法中绑定要读取的数据源</span>
        <span class="nc">FileInputStream</span> <span class="n">fis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"09_IOAndProperties\\c.txt"</span><span class="o">);</span>
        <span class="c1">//2.使用FileInputStream对象中的方法read,读取文件</span>
        <span class="c1">//int read()读取文件中的一个字节并返回,读取到文件的末尾返回-1</span>
        <span class="cm">/*int len = fis.read();
        System.out.println(len);//97 a

        len = fis.read();
        System.out.println(len);// 98 b

        len = fis.read();
        System.out.println(len);//99 c

        len = fis.read();
        System.out.println(len);//-1

        len = fis.read();
        System.out.println(len);//-1*/</span>

        <span class="cm">/*
            发现以上读取文件是一个重复的过程,所以可以使用循环优化
            不知道文件中有多少字节,使用while循环
            while循环结束条件,读取到-1的时候结束

            布尔表达式(len = fis.read())!=-1
                1.fis.read():读取一个字节
                2.len = fis.read():把读取到的字节赋值给变量len
                3.(len = fis.read())!=-1:判断变量len是否不等于-1
         */</span>
        <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">//记录读取到的字节</span>
        <span class="k">while</span><span class="o">((</span><span class="n">len</span> <span class="o">=</span> <span class="n">fis</span><span class="o">.</span><span class="na">read</span><span class="o">())!=-</span><span class="mi">1</span><span class="o">){</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">len</span><span class="o">);</span><span class="c1">//abc</span>
            <span class="c1">//System.out.print((char)len);</span>
        <span class="o">}</span>

        <span class="c1">//3.释放资源</span>
        <span class="n">fis</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p><img src="https://blog.slienceme.cn/images/posts/20210127120220129.bmp.jpg" alt="Alt Text" /></p> <h4 id="读取字节数据">读取字节数据</h4> <ol> <li><strong>读取字节</strong>：<code class="language-plaintext highlighter-rouge">read</code>方法，每次可以读取一个字节的数据，提升为int类型，读取到文件末尾，返回<code class="language-plaintext highlighter-rouge">-1</code>，代码使用演示：</li> </ol> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FISRead</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span><span class="o">{</span>
      	<span class="c1">// 使用文件名称创建流对象</span>
       	<span class="nc">FileInputStream</span> <span class="n">fis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"read.txt"</span><span class="o">);</span>
      	<span class="c1">// 读取数据，返回一个字节</span>
        <span class="kt">int</span> <span class="n">read</span> <span class="o">=</span> <span class="n">fis</span><span class="o">.</span><span class="na">read</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">((</span><span class="kt">char</span><span class="o">)</span> <span class="n">read</span><span class="o">);</span>
        <span class="n">read</span> <span class="o">=</span> <span class="n">fis</span><span class="o">.</span><span class="na">read</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">((</span><span class="kt">char</span><span class="o">)</span> <span class="n">read</span><span class="o">);</span>
        <span class="n">read</span> <span class="o">=</span> <span class="n">fis</span><span class="o">.</span><span class="na">read</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">((</span><span class="kt">char</span><span class="o">)</span> <span class="n">read</span><span class="o">);</span>
        <span class="n">read</span> <span class="o">=</span> <span class="n">fis</span><span class="o">.</span><span class="na">read</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">((</span><span class="kt">char</span><span class="o">)</span> <span class="n">read</span><span class="o">);</span>
        <span class="n">read</span> <span class="o">=</span> <span class="n">fis</span><span class="o">.</span><span class="na">read</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">((</span><span class="kt">char</span><span class="o">)</span> <span class="n">read</span><span class="o">);</span>
      	<span class="c1">// 读取到末尾,返回-1</span>
       	<span class="n">read</span> <span class="o">=</span> <span class="n">fis</span><span class="o">.</span><span class="na">read</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span> <span class="n">read</span><span class="o">);</span>
		<span class="c1">// 关闭资源</span>
        <span class="n">fis</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="n">输出结果</span><span class="err">：</span>
<span class="n">a</span>
<span class="n">b</span>
<span class="n">c</span>
<span class="n">d</span>
<span class="n">e</span>
<span class="o">-</span><span class="mi">1</span>
</code></pre></div></div> <p>循环改进读取方式，代码使用演示：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FISRead</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span><span class="o">{</span>
      	<span class="c1">// 使用文件名称创建流对象</span>
       	<span class="nc">FileInputStream</span> <span class="n">fis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"read.txt"</span><span class="o">);</span>
      	<span class="c1">// 定义变量，保存数据</span>
        <span class="kt">int</span> <span class="n">b</span> <span class="err">；</span>
        <span class="c1">// 循环读取</span>
        <span class="k">while</span> <span class="o">((</span><span class="n">b</span> <span class="o">=</span> <span class="n">fis</span><span class="o">.</span><span class="na">read</span><span class="o">())!=-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">((</span><span class="kt">char</span><span class="o">)</span><span class="n">b</span><span class="o">);</span>
        <span class="o">}</span>
		<span class="c1">// 关闭资源</span>
        <span class="n">fis</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="n">输出结果</span><span class="err">：</span>
<span class="n">a</span>
<span class="n">b</span>
<span class="n">c</span>
<span class="n">d</span>
<span class="n">e</span>
</code></pre></div></div> <blockquote> <p>小贴士：</p> <ol> <li>虽然读取了一个字节，但是会自动提升为int类型。</li> <li>流操作完毕后，必须释放系统资源，调用close方法，千万记得。</li> </ol> </blockquote> <ol> <li><strong>使用字节数组读取</strong>：<code class="language-plaintext highlighter-rouge">read(byte[] b)</code>，每次读取b的长度个字节到数组中，返回读取到的有效字节个数，读取到末尾时，返回<code class="language-plaintext highlighter-rouge">-1</code> ，代码使用演示：</li> </ol> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FISRead</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span><span class="o">{</span>
      	<span class="c1">// 使用文件名称创建流对象.</span>
       	<span class="nc">FileInputStream</span> <span class="n">fis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"read.txt"</span><span class="o">);</span> <span class="c1">// 文件中为abcde</span>
      	<span class="c1">// 定义变量，作为有效个数</span>
        <span class="kt">int</span> <span class="n">len</span> <span class="err">；</span>
        <span class="c1">// 定义字节数组，作为装字节数据的容器   </span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">b</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>
        <span class="c1">// 循环读取</span>
        <span class="k">while</span> <span class="o">((</span> <span class="n">len</span><span class="o">=</span> <span class="n">fis</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">b</span><span class="o">))!=-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
           	<span class="c1">// 每次读取后,把数组变成字符串打印</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">b</span><span class="o">));</span>
        <span class="o">}</span>
		<span class="c1">// 关闭资源</span>
        <span class="n">fis</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="n">输出结果</span><span class="err">：</span>
<span class="n">ab</span>
<span class="n">cd</span>
<span class="n">ed</span>
</code></pre></div></div> <p>错误数据<code class="language-plaintext highlighter-rouge">d</code>，是由于最后一次读取时，只读取一个字节<code class="language-plaintext highlighter-rouge">e</code>，数组中，上次读取的数据没有被完全替换，所以要通过<code class="language-plaintext highlighter-rouge">len</code> ，获取有效的字节，代码使用演示：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FISRead</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span><span class="o">{</span>
      	<span class="c1">// 使用文件名称创建流对象.</span>
       	<span class="nc">FileInputStream</span> <span class="n">fis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"read.txt"</span><span class="o">);</span> <span class="c1">// 文件中为abcde</span>
      	<span class="c1">// 定义变量，作为有效个数</span>
        <span class="kt">int</span> <span class="n">len</span> <span class="err">；</span>
        <span class="c1">// 定义字节数组，作为装字节数据的容器   </span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">b</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>
        <span class="c1">// 循环读取</span>
        <span class="k">while</span> <span class="o">((</span> <span class="n">len</span><span class="o">=</span> <span class="n">fis</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">b</span><span class="o">))!=-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
           	<span class="c1">// 每次读取后,把数组的有效字节部分，变成字符串打印</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">b</span><span class="err">，</span><span class="mi">0</span><span class="err">，</span><span class="n">len</span><span class="o">));</span><span class="c1">//  len 每次读取的有效字节个数</span>
        <span class="o">}</span>
		<span class="c1">// 关闭资源</span>
        <span class="n">fis</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="n">输出结果</span><span class="err">：</span>
<span class="n">ab</span>
<span class="n">cd</span>
<span class="n">e</span>
</code></pre></div></div> <blockquote> <p>小贴士：</p> <p>使用数组读取，每次读取多个字节，减少了系统间的IO操作次数，从而提高了读写的效率，建议开发中使用。</p> </blockquote> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.io.FileInputStream</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>

<span class="cm">/*
    字节输入流一次读取多个字节的方法:
        int read(byte[] b) 从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b 中。
    明确两件事情:
        1.方法的参数byte[]的作用?
            起到缓冲作用,存储每次读取到的多个字节
            数组的长度一把定义为1024(1kb)或者1024的整数倍
        2.方法的返回值int是什么?
            每次读取的有效字节个数

    String类的构造方法
        String(byte[] bytes) :把字节数组转换为字符串
        String(byte[] bytes, int offset, int length) 把字节数组的一部分转换为字符串 offset:数组的开始索引 length:转换的字节个数
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo02InputStream</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="c1">//创建FileInputStream对象,构造方法中绑定要读取的数据源</span>
        <span class="nc">FileInputStream</span> <span class="n">fis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"09_IOAndProperties\\b.txt"</span><span class="o">);</span>
        <span class="c1">//使用FileInputStream对象中的方法read读取文件</span>
        <span class="c1">//int read(byte[] b) 从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b 中。</span>
        <span class="cm">/*byte[] bytes = new byte[2];
        int len = fis.read(bytes);
        System.out.println(len);//2
        //System.out.println(Arrays.toString(bytes));//[65, 66]
        System.out.println(new String(bytes));//AB

        len = fis.read(bytes);
        System.out.println(len);//2
        System.out.println(new String(bytes));//CD

        len = fis.read(bytes);
        System.out.println(len);//1
        System.out.println(new String(bytes));//ED

        len = fis.read(bytes);
        System.out.println(len);//-1
        System.out.println(new String(bytes));//ED*/</span>

        <span class="cm">/*
            发现以上读取时一个重复的过程,可以使用循环优化
            不知道文件中有多少字节,所以使用while循环
            while循环结束的条件,读取到-1结束
         */</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">bytes</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="mi">1024</span><span class="o">];</span><span class="c1">//存储读取到的多个字节</span>
        <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">//记录每次读取的有效字节个数</span>
        <span class="k">while</span><span class="o">((</span><span class="n">len</span> <span class="o">=</span> <span class="n">fis</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">bytes</span><span class="o">))!=-</span><span class="mi">1</span><span class="o">){</span>
            <span class="c1">//String(byte[] bytes, int offset, int length) 把字节数组的一部分转换为字符串 offset:数组的开始索引 length:转换的字节个数</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">bytes</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="n">len</span><span class="o">));</span>
        <span class="o">}</span>

        <span class="c1">//释放资源</span>
        <span class="n">fis</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div> <h3 id="56-字节流练习图片复制">5.6 字节流练习：图片复制</h3> <h4 id="复制原理图解">复制原理图解</h4> <p><img src="https://blog.slienceme.cn/images/posts/20210126095732482.jpg" alt="Alt Text" /> <img src="https://blog.slienceme.cn/images/posts/20210127121135809.bmp.jpg" alt="Alt Text" /></p> <h4 id="案例实现">案例实现</h4> <p>复制图片文件，代码使用演示：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Copy</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="c1">// 1.创建流对象</span>
        <span class="c1">// 1.1 指定数据源</span>
        <span class="nc">FileInputStream</span> <span class="n">fis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"D:\\test.jpg"</span><span class="o">);</span>
        <span class="c1">// 1.2 指定目的地</span>
        <span class="nc">FileOutputStream</span> <span class="n">fos</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"test_copy.jpg"</span><span class="o">);</span>

        <span class="c1">// 2.读写数据</span>
        <span class="c1">// 2.1 定义数组</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">b</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="mi">1024</span><span class="o">];</span>
        <span class="c1">// 2.2 定义长度</span>
        <span class="kt">int</span> <span class="n">len</span><span class="o">;</span>
        <span class="c1">// 2.3 循环读取</span>
        <span class="k">while</span> <span class="o">((</span><span class="n">len</span> <span class="o">=</span> <span class="n">fis</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">b</span><span class="o">))!=-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 2.4 写出数据</span>
            <span class="n">fos</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="mi">0</span> <span class="o">,</span> <span class="n">len</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// 3.关闭资源</span>
        <span class="n">fos</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="n">fis</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <blockquote> <p>小贴士：</p> <p>流的关闭原则：先开后关，后开先关。</p> </blockquote> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.io.FileInputStream</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.FileOutputStream</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>

<span class="cm">/*
    文件复制练习:一读一写

    明确:
        数据源: c:\\1.jpg
        数据的目的地: d:\\1.jpg

    文件复制的步骤:
        1.创建一个字节输入流对象,构造方法中绑定要读取的数据源
        2.创建一个字节输出流对象,构造方法中绑定要写入的目的地
        3.使用字节输入流对象中的方法read读取文件
        4.使用字节输出流中的方法write,把读取到的字节写入到目的地的文件中
        5.释放资源
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo01CopyFile</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="kt">long</span> <span class="n">s</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>
        <span class="c1">//1.创建一个字节输入流对象,构造方法中绑定要读取的数据源</span>
        <span class="nc">FileInputStream</span> <span class="n">fis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"c:\\1.jpg"</span><span class="o">);</span>
        <span class="c1">//2.创建一个字节输出流对象,构造方法中绑定要写入的目的地</span>
        <span class="nc">FileOutputStream</span> <span class="n">fos</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"d:\\1.jpg"</span><span class="o">);</span>
        <span class="c1">//一次读取一个字节写入一个字节的方式</span>
        <span class="c1">//3.使用字节输入流对象中的方法read读取文件</span>
        <span class="cm">/*int len = 0;
        while((len = fis.read())!=-1){
            //4.使用字节输出流中的方法write,把读取到的字节写入到目的地的文件中
            fos.write(len);
        }*/</span>

        <span class="c1">//使用数组缓冲读取多个字节,写入多个字节</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">bytes</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="mi">1024</span><span class="o">];</span>
        <span class="c1">//3.使用字节输入流对象中的方法read读取文件</span>
        <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span><span class="c1">//每次读取的有效字节个数</span>
        <span class="k">while</span><span class="o">((</span><span class="n">len</span> <span class="o">=</span> <span class="n">fis</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">bytes</span><span class="o">))!=-</span><span class="mi">1</span><span class="o">){</span>
            <span class="c1">//4.使用字节输出流中的方法write,把读取到的字节写入到目的地的文件中</span>
            <span class="n">fos</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">bytes</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="n">len</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">//5.释放资源(先关写的,后关闭读的;如果写完了,肯定读取完毕了)</span>
        <span class="n">fos</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="n">fis</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="kt">long</span> <span class="n">e</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"复制文件共耗时:"</span><span class="o">+(</span><span class="n">e</span><span class="o">-</span><span class="n">s</span><span class="o">)+</span><span class="s">"毫秒"</span><span class="o">);</span>
    <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.io.FileInputStream</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>

<span class="cm">/*
    使用字节流读取中文文件
    1个中文
        GBK:占用两个字节
        UTF-8:占用3个字节
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo01InputStream</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="nc">FileInputStream</span> <span class="n">fis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"09_IOAndProperties\\c.txt"</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span><span class="o">((</span><span class="n">len</span> <span class="o">=</span> <span class="n">fis</span><span class="o">.</span><span class="na">read</span><span class="o">())!=-</span><span class="mi">1</span><span class="o">){</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">((</span><span class="kt">char</span><span class="o">)</span><span class="n">len</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">fis</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h2 id="6-字符流">6. 字符流</h2> <p>当使用字节流读取文本文件时，可能会有一个小问题。就是遇到中文字符时，可能不会显示完整的字符，那是因为一个中文字符可能占用多个字节存储。所以Java提供一些字符流类，以字符为单位读写数据，专门用于处理文本文件。</p> <h3 id="61-字符输入流reader">6.1 字符输入流【Reader】</h3> <p><code class="language-plaintext highlighter-rouge">java.io.Reader</code>抽象类是表示用于读取字符流的所有类的超类，可以读取字符信息到内存中。它定义了字符输入流的基本共性功能方法。</p> <ul> <li><code class="language-plaintext highlighter-rouge">public void close()</code> ：关闭此流并释放与此流相关联的任何系统资源。</li> <li><code class="language-plaintext highlighter-rouge">public int read()</code>： 从输入流读取一个字符。</li> <li><code class="language-plaintext highlighter-rouge">public int read(char[] cbuf)</code>： 从输入流中读取一些字符，并将它们存储到字符数组 cbuf中 。</li> </ul> <h3 id="62-filereader类">6.2 FileReader类</h3> <p><code class="language-plaintext highlighter-rouge">java.io.FileReader </code>类是读取字符文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。</p> <blockquote> <p>小贴士：</p> <ol> <li> <p>字符编码：字节与字符的对应规则。Windows系统的中文编码默认是GBK编码表。</p> <p>idea中UTF-8</p> </li> <li> <p>字节缓冲区：一个字节数组，用来临时存储字节数据。</p> </li> </ol> </blockquote> <h4 id="构造方法-2">构造方法</h4> <ul> <li><code class="language-plaintext highlighter-rouge">FileReader(File file)</code>： 创建一个新的 FileReader ，给定要读取的File对象。</li> <li><code class="language-plaintext highlighter-rouge">FileReader(String fileName)</code>： 创建一个新的 FileReader ，给定要读取的文件的名称。</li> </ul> <p>当你创建一个流对象时，必须传入一个文件路径。类似于FileInputStream 。</p> <ul> <li>构造举例，代码如下：</li> </ul> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FileReaderConstructor</span> <span class="kd">throws</span> <span class="nc">IOException</span><span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
   	 	<span class="c1">// 使用File对象创建流对象</span>
        <span class="nc">File</span> <span class="n">file</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"a.txt"</span><span class="o">);</span>
        <span class="nc">FileReader</span> <span class="n">fr</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileReader</span><span class="o">(</span><span class="n">file</span><span class="o">);</span>
      
        <span class="c1">// 使用文件名称创建流对象</span>
        <span class="nc">FileReader</span> <span class="n">fr</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileReader</span><span class="o">(</span><span class="s">"b.txt"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.io.FileReader</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>

<span class="cm">/*
    java.io.Reader:字符输入流,是字符输入流的最顶层的父类,定义了一些共性的成员方法,是一个抽象类

    共性的成员方法:
        int read() 读取单个字符并返回。
        int read(char[] cbuf)一次读取多个字符,将字符读入数组。
        void close() 关闭该流并释放与之关联的所有资源。

    java.io.FileReader extends InputStreamReader extends Reader
    FileReader:文件字符输入流
    作用:把硬盘文件中的数据以字符的方式读取到内存中

    构造方法:
        FileReader(String fileName)
        FileReader(File file)
        参数:读取文件的数据源
            String fileName:文件的路径
            File file:一个文件
        FileReader构造方法的作用:
            1.创建一个FileReader对象
            2.会把FileReader对象指向要读取的文件
    字符输入流的使用步骤:
        1.创建FileReader对象,构造方法中绑定要读取的数据源
        2.使用FileReader对象中的方法read读取文件
        3.释放资源
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo02Reader</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="c1">//1.创建FileReader对象,构造方法中绑定要读取的数据源</span>
        <span class="nc">FileReader</span> <span class="n">fr</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileReader</span><span class="o">(</span><span class="s">"09_IOAndProperties\\c.txt"</span><span class="o">);</span>
        <span class="c1">//2.使用FileReader对象中的方法read读取文件</span>
        <span class="c1">//int read() 读取单个字符并返回。</span>
        <span class="cm">/*int len = 0;
        while((len = fr.read())!=-1){
            System.out.print((char)len);
        }*/</span>

        <span class="c1">//int read(char[] cbuf)一次读取多个字符,将字符读入数组。</span>
        <span class="kt">char</span><span class="o">[]</span> <span class="n">cs</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="o">[</span><span class="mi">1024</span><span class="o">];</span><span class="c1">//存储读取到的多个字符</span>
        <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span><span class="c1">//记录的是每次读取的有效字符个数</span>
        <span class="k">while</span><span class="o">((</span><span class="n">len</span> <span class="o">=</span> <span class="n">fr</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">cs</span><span class="o">))!=-</span><span class="mi">1</span><span class="o">){</span>
            <span class="cm">/*
                String类的构造方法
                String(char[] value) 把字符数组转换为字符串
                String(char[] value, int offset, int count) 把字符数组的一部分转换为字符串 offset数组的开始索引 count转换的个数
             */</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">cs</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="n">len</span><span class="o">));</span>
        <span class="o">}</span>

        <span class="c1">//3.释放资源</span>
        <span class="n">fr</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.io.FileWriter</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>

<span class="cm">/*
    java.io.Writer:字符输出流,是所有字符输出流的最顶层的父类,是一个抽象类

    共性的成员方法:
        - void write(int c) 写入单个字符。
        - void write(char[] cbuf)写入字符数组。
        - abstract  void write(char[] cbuf, int off, int len)写入字符数组的某一部分,off数组的开始索引,len写的字符个数。
        - void write(String str)写入字符串。
        - void write(String str, int off, int len) 写入字符串的某一部分,off字符串的开始索引,len写的字符个数。
        - void flush()刷新该流的缓冲。
        - void close() 关闭此流，但要先刷新它。

    java.io.FileWriter extends OutputStreamWriter extends Writer
    FileWriter:文件字符输出流
    作用:把内存中字符数据写入到文件中

    构造方法:
        FileWriter(File file)根据给定的 File 对象构造一个 FileWriter 对象。
        FileWriter(String fileName) 根据给定的文件名构造一个 FileWriter 对象。
        参数:写入数据的目的地
            String fileName:文件的路径
            File file:是一个文件
        构造方法的作用:
            1.会创建一个FileWriter对象
            2.会根据构造方法中传递的文件/文件的路径,创建文件
            3.会把FileWriter对象指向创建好的文件

    字符输出流的使用步骤(重点):
        1.创建FileWriter对象,构造方法中绑定要写入数据的目的地
        2.使用FileWriter中的方法write,把数据写入到内存缓冲区中(字符转换为字节的过程)
        3.使用FileWriter中的方法flush,把内存缓冲区中的数据,刷新到文件中
        4.释放资源(会先把内存缓冲区中的数据刷新到文件中)
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo01Writer</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="c1">//1.创建FileWriter对象,构造方法中绑定要写入数据的目的地</span>
        <span class="nc">FileWriter</span> <span class="n">fw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileWriter</span><span class="o">(</span><span class="s">"09_IOAndProperties\\d.txt"</span><span class="o">);</span>
        <span class="c1">//2.使用FileWriter中的方法write,把数据写入到内存缓冲区中(字符转换为字节的过程)</span>
        <span class="c1">//void write(int c) 写入单个字符。</span>
        <span class="n">fw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="mi">97</span><span class="o">);</span>
        <span class="c1">//3.使用FileWriter中的方法flush,把内存缓冲区中的数据,刷新到文件中</span>
        <span class="c1">//fw.flush();</span>
        <span class="c1">//4.释放资源(会先把内存缓冲区中的数据刷新到文件中)</span>
        <span class="n">fw</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h4 id="读取字符数据">读取字符数据</h4> <ol> <li><strong>读取字符</strong>：<code class="language-plaintext highlighter-rouge">read</code>方法，每次可以读取一个字符的数据，提升为int类型，读取到文件末尾，返回<code class="language-plaintext highlighter-rouge">-1</code>，循环读取，代码使用演示：</li> </ol> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FRRead</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
      	<span class="c1">// 使用文件名称创建流对象</span>
       	<span class="nc">FileReader</span> <span class="n">fr</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileReader</span><span class="o">(</span><span class="s">"read.txt"</span><span class="o">);</span>
      	<span class="c1">// 定义变量，保存数据</span>
        <span class="kt">int</span> <span class="n">b</span> <span class="err">；</span>
        <span class="c1">// 循环读取</span>
        <span class="k">while</span> <span class="o">((</span><span class="n">b</span> <span class="o">=</span> <span class="n">fr</span><span class="o">.</span><span class="na">read</span><span class="o">())!=-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">((</span><span class="kt">char</span><span class="o">)</span><span class="n">b</span><span class="o">);</span>
        <span class="o">}</span>
		<span class="c1">// 关闭资源</span>
        <span class="n">fr</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="n">输出结果</span><span class="err">：</span>
<span class="n">我</span>
<span class="n">是</span>
<span class="n">程</span>
<span class="n">序</span>
<span class="n">员</span>
</code></pre></div></div> <blockquote> <p>小贴士：虽然读取了一个字符，但是会自动提升为int类型。</p> </blockquote> <ol> <li><strong>使用字符数组读取</strong>：<code class="language-plaintext highlighter-rouge">read(char[] cbuf)</code>，每次读取b的长度个字符到数组中，返回读取到的有效字符个数，读取到末尾时，返回<code class="language-plaintext highlighter-rouge">-1</code> ，代码使用演示：</li> </ol> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FRRead</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
      	<span class="c1">// 使用文件名称创建流对象</span>
       	<span class="nc">FileReader</span> <span class="n">fr</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileReader</span><span class="o">(</span><span class="s">"read.txt"</span><span class="o">);</span>
      	<span class="c1">// 定义变量，保存有效字符个数</span>
        <span class="kt">int</span> <span class="n">len</span> <span class="err">；</span>
        <span class="c1">// 定义字符数组，作为装字符数据的容器</span>
         <span class="kt">char</span><span class="o">[]</span> <span class="n">cbuf</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>
        <span class="c1">// 循环读取</span>
        <span class="k">while</span> <span class="o">((</span><span class="n">len</span> <span class="o">=</span> <span class="n">fr</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">cbuf</span><span class="o">))!=-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">cbuf</span><span class="o">));</span>
        <span class="o">}</span>
		<span class="c1">// 关闭资源</span>
        <span class="n">fr</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="n">输出结果</span><span class="err">：</span>
<span class="n">我是</span>
<span class="n">程序</span>
<span class="n">员序</span>
</code></pre></div></div> <p>获取有效的字符改进，代码使用演示：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FISRead</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
      	<span class="c1">// 使用文件名称创建流对象</span>
       	<span class="nc">FileReader</span> <span class="n">fr</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileReader</span><span class="o">(</span><span class="s">"read.txt"</span><span class="o">);</span>
      	<span class="c1">// 定义变量，保存有效字符个数</span>
        <span class="kt">int</span> <span class="n">len</span> <span class="err">；</span>
        <span class="c1">// 定义字符数组，作为装字符数据的容器</span>
        <span class="kt">char</span><span class="o">[]</span> <span class="n">cbuf</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>
        <span class="c1">// 循环读取</span>
        <span class="k">while</span> <span class="o">((</span><span class="n">len</span> <span class="o">=</span> <span class="n">fr</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">cbuf</span><span class="o">))!=-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">cbuf</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="n">len</span><span class="o">));</span>
        <span class="o">}</span>
    	<span class="c1">// 关闭资源</span>
        <span class="n">fr</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="n">输出结果</span><span class="err">：</span>
<span class="n">我是</span>
<span class="n">程序</span>
<span class="n">员</span>
</code></pre></div></div> <h3 id="63-字符输出流writer">6.3 字符输出流【Writer】</h3> <p><code class="language-plaintext highlighter-rouge">java.io.Writer </code>抽象类是表示用于写出字符流的所有类的超类，将指定的字符信息写出到目的地。它定义了字节输出流的基本共性功能方法。</p> <ul> <li><code class="language-plaintext highlighter-rouge">void write(int c)</code> 写入单个字符。</li> <li><code class="language-plaintext highlighter-rouge">void write(char[] cbuf) </code>写入字符数组。</li> <li><code class="language-plaintext highlighter-rouge">abstract void write(char[] cbuf, int off, int len) </code>写入字符数组的某一部分,off数组的开始索引,len写的字符个数。</li> <li><code class="language-plaintext highlighter-rouge">void write(String str) </code>写入字符串。</li> <li><code class="language-plaintext highlighter-rouge">void write(String str, int off, int len)</code> 写入字符串的某一部分,off字符串的开始索引,len写的字符个数。</li> <li><code class="language-plaintext highlighter-rouge">void flush() </code>刷新该流的缓冲。</li> <li><code class="language-plaintext highlighter-rouge">void close()</code> 关闭此流，但要先刷新它。</li> </ul> <h3 id="64-filewriter类">6.4 FileWriter类</h3> <p><code class="language-plaintext highlighter-rouge">java.io.FileWriter </code>类是写出字符到文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。</p> <h4 id="构造方法-3">构造方法</h4> <ul> <li><code class="language-plaintext highlighter-rouge">FileWriter(File file)</code>： 创建一个新的 FileWriter，给定要读取的File对象。</li> <li><code class="language-plaintext highlighter-rouge">FileWriter(String fileName)</code>： 创建一个新的 FileWriter，给定要读取的文件的名称。</li> </ul> <p>当你创建一个流对象时，必须传入一个文件路径，类似于FileOutputStream。</p> <ul> <li>构造举例，代码如下：</li> </ul> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FileWriterConstructor</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
   	 	<span class="c1">// 使用File对象创建流对象</span>
        <span class="nc">File</span> <span class="n">file</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"a.txt"</span><span class="o">);</span>
        <span class="nc">FileWriter</span> <span class="n">fw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileWriter</span><span class="o">(</span><span class="n">file</span><span class="o">);</span>
      
        <span class="c1">// 使用文件名称创建流对象</span>
        <span class="nc">FileWriter</span> <span class="n">fw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileWriter</span><span class="o">(</span><span class="s">"b.txt"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h4 id="基本写出数据">基本写出数据</h4> <p><strong>写出字符</strong>：<code class="language-plaintext highlighter-rouge">write(int b)</code> 方法，每次可以写出一个字符数据，代码使用演示：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FWWrite</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="c1">// 使用文件名称创建流对象</span>
        <span class="nc">FileWriter</span> <span class="n">fw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileWriter</span><span class="o">(</span><span class="s">"fw.txt"</span><span class="o">);</span>     
      	<span class="c1">// 写出数据</span>
      	<span class="n">fw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="mi">97</span><span class="o">);</span> <span class="c1">// 写出第1个字符</span>
      	<span class="n">fw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="sc">'b'</span><span class="o">);</span> <span class="c1">// 写出第2个字符</span>
      	<span class="n">fw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="sc">'C'</span><span class="o">);</span> <span class="c1">// 写出第3个字符</span>
      	<span class="n">fw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="mi">30000</span><span class="o">);</span> <span class="c1">// 写出第4个字符，中文编码表中30000对应一个汉字。</span>
      
      	<span class="cm">/*
        【注意】关闭资源时,与FileOutputStream不同。
      	 如果不关闭,数据只是保存到缓冲区，并未保存到文件。
        */</span>
        <span class="c1">// fw.close();</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="n">输出结果</span><span class="err">：</span>
<span class="n">abC田</span>
</code></pre></div></div> <blockquote> <p>小贴士：</p> <ol> <li>虽然参数为int类型四个字节，但是只会保留一个字符的信息写出。</li> <li>未调用close方法，数据只是保存到了缓冲区，并未写出到文件中。</li> </ol> </blockquote> <h4 id="关闭和刷新">关闭和刷新</h4> <p>因为内置缓冲区的原因，如果不关闭输出流，无法写出字符到文件中。但是关闭的流对象，是无法继续写出数据的。如果我们既想写出数据，又想继续使用流，就需要<code class="language-plaintext highlighter-rouge">flush</code> 方法了。</p> <ul> <li><code class="language-plaintext highlighter-rouge">flush</code> ：刷新缓冲区，流对象可以继续使用。</li> <li><code class="language-plaintext highlighter-rouge">close </code>:先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。</li> </ul> <p>代码使用演示：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FWWrite</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="c1">// 使用文件名称创建流对象</span>
        <span class="nc">FileWriter</span> <span class="n">fw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileWriter</span><span class="o">(</span><span class="s">"fw.txt"</span><span class="o">);</span>
        <span class="c1">// 写出数据，通过flush</span>
        <span class="n">fw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="sc">'刷'</span><span class="o">);</span> <span class="c1">// 写出第1个字符</span>
        <span class="n">fw</span><span class="o">.</span><span class="na">flush</span><span class="o">();</span>
        <span class="n">fw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="sc">'新'</span><span class="o">);</span> <span class="c1">// 继续写出第2个字符，写出成功</span>
        <span class="n">fw</span><span class="o">.</span><span class="na">flush</span><span class="o">();</span>
      
      	<span class="c1">// 写出数据，通过close</span>
        <span class="n">fw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="sc">'关'</span><span class="o">);</span> <span class="c1">// 写出第1个字符</span>
        <span class="n">fw</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="n">fw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="sc">'闭'</span><span class="o">);</span> <span class="c1">// 继续写出第2个字符,【报错】java.io.IOException: Stream closed</span>
        <span class="n">fw</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <blockquote> <p>小贴士：即便是flush方法写出了数据，操作的最后还是要调用close方法，释放系统资源。 ```java import java.io.FileWriter; import java.io.IOException;</p> </blockquote> <p>/* flush方法和close方法的区别 - flush ：刷新缓冲区，流对象可以继续使用。 - close: 先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。 */ public class Demo02CloseAndFlush { public static void main(String[] args) throws IOException { //1.创建FileWriter对象,构造方法中绑定要写入数据的目的地 FileWriter fw = new FileWriter(“09_IOAndProperties\e.txt”); //2.使用FileWriter中的方法write,把数据写入到内存缓冲区中(字符转换为字节的过程) //void write(int c) 写入单个字符。 fw.write(97); //3.使用FileWriter中的方法flush,把内存缓冲区中的数据,刷新到文件中 fw.flush(); //刷新之后流可以继续使用 fw.write(98);</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    //4.释放资源(会先把内存缓冲区中的数据刷新到文件中)
    fw.close();

    //close方法之后流已经关闭了,已经从内存中消失了,流就不能再使用了
    fw.write(99);//IOException: Stream closed
} }
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#### 写出其他数据

1. **写出字符数组** ：`write(char[] cbuf)` 和 `write(char[] cbuf, int off, int len)` ，每次可以写出字符数组中的数据，用法类似FileOutputStream，代码使用演示：

```java
public class FWWrite {
    public static void main(String[] args) throws IOException {
        // 使用文件名称创建流对象
        FileWriter fw = new FileWriter("fw.txt");     
      	// 字符串转换为字节数组
      	char[] chars = "我是程序员".toCharArray();
      
      	// 写出字符数组
      	fw.write(chars); // 我是程序员
        
		// 写出从索引2开始，2个字节。索引2是'程'，两个字节，也就是'程序'。
        fw.write(b,2,2); // 程序
      
      	// 关闭资源
        fos.close();
    }
}
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.io.FileWriter</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>

<span class="cm">/*
    字符输出流写数据的其他方法
        - void write(char[] cbuf)写入字符数组。
        - abstract  void write(char[] cbuf, int off, int len)写入字符数组的某一部分,off数组的开始索引,len写的字符个数。
        - void write(String str)写入字符串。
        - void write(String str, int off, int len) 写入字符串的某一部分,off字符串的开始索引,len写的字符个数。
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo03Writer</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="nc">FileWriter</span> <span class="n">fw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileWriter</span><span class="o">(</span><span class="s">"09_IOAndProperties\\f.txt"</span><span class="o">);</span>
        <span class="kt">char</span><span class="o">[]</span> <span class="n">cs</span> <span class="o">=</span> <span class="o">{</span><span class="sc">'a'</span><span class="o">,</span><span class="sc">'b'</span><span class="o">,</span><span class="sc">'c'</span><span class="o">,</span><span class="sc">'d'</span><span class="o">,</span><span class="sc">'e'</span><span class="o">};</span>
        <span class="c1">//void write(char[] cbuf)写入字符数组。</span>
        <span class="n">fw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">cs</span><span class="o">);</span><span class="c1">//abcde</span>

        <span class="c1">//void write(char[] cbuf, int off, int len)写入字符数组的某一部分,off数组的开始索引,len写的字符个数。</span>
        <span class="n">fw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">cs</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">);</span><span class="c1">//bcd</span>

        <span class="c1">//void write(String str)写入字符串。</span>
        <span class="n">fw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"举世无双"</span><span class="o">);</span><span class="c1">//举世无双</span>

        <span class="c1">//void write(String str, int off, int len) 写入字符串的某一部分,off字符串的开始索引,len写的字符个数。</span>
        <span class="n">fw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"我是程序员"</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">);</span><span class="c1">//程序员</span>

        <span class="n">fw</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <ol> <li><strong>写出字符串</strong>：<code class="language-plaintext highlighter-rouge">write(String str)</code> 和 <code class="language-plaintext highlighter-rouge">write(String str, int off, int len)</code> ，每次可以写出字符串中的数据，更为方便，代码使用演示：</li> </ol> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FWWrite</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="c1">// 使用文件名称创建流对象</span>
        <span class="nc">FileWriter</span> <span class="n">fw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileWriter</span><span class="o">(</span><span class="s">"fw.txt"</span><span class="o">);</span>     
      	<span class="c1">// 字符串</span>
      	<span class="nc">String</span> <span class="n">msg</span> <span class="o">=</span> <span class="s">"我是程序员"</span><span class="o">;</span>
      
      	<span class="c1">// 写出字符数组</span>
      	<span class="n">fw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">msg</span><span class="o">);</span> <span class="c1">//我是程序员</span>
      
		<span class="c1">// 写出从索引2开始，2个字节。索引2是'程'，两个字节，也就是'程序'。</span>
        <span class="n">fw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">msg</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">);</span>	<span class="c1">// 程序</span>
      	
        <span class="c1">// 关闭资源</span>
        <span class="n">fos</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <ol> <li><strong>续写和换行</strong>：操作类似于FileOutputStream。</li> </ol> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FWWrite</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="c1">// 使用文件名称创建流对象，可以续写数据</span>
        <span class="nc">FileWriter</span> <span class="n">fw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileWriter</span><span class="o">(</span><span class="s">"fw.txt"</span><span class="err">，</span><span class="kc">true</span><span class="o">);</span>     
      	<span class="c1">// 写出字符串</span>
        <span class="n">fw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"我是"</span><span class="o">);</span>
      	<span class="c1">// 写出换行</span>
      	<span class="n">fw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"\r\n"</span><span class="o">);</span>
      	<span class="c1">// 写出字符串</span>
  		<span class="n">fw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"程序员"</span><span class="o">);</span>
      	<span class="c1">// 关闭资源</span>
        <span class="n">fw</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="nl">输出结果:</span>
<span class="n">我是</span>
<span class="n">程序员</span>
</code></pre></div></div> <blockquote> <p>小贴士：字符流，只能操作文本文件，不能操作图片，视频等非文本文件。</p> <p>当我们单纯读或者写文本文件时 使用字符流 其他情况使用字节流</p> </blockquote> <h2 id="7-io异常的处理">7. IO异常的处理</h2> <h4 id="jdk7前处理">JDK7前处理</h4> <p>之前的入门练习，我们一直把异常抛出，而实际开发中并不能这样处理，建议使用<code class="language-plaintext highlighter-rouge">try...catch...finally</code> 代码块，处理异常部分，代码使用演示：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">HandleException1</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
      	<span class="c1">// 声明变量</span>
        <span class="nc">FileWriter</span> <span class="n">fw</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="c1">//创建流对象</span>
            <span class="n">fw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileWriter</span><span class="o">(</span><span class="s">"fw.txt"</span><span class="o">);</span>
            <span class="c1">// 写出数据</span>
            <span class="n">fw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"我是程序员"</span><span class="o">);</span> <span class="c1">//我是程序员</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">fw</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">fw</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
                <span class="o">}</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h4 id="jdk7的处理扩展知识点了解内容">JDK7的处理(扩展知识点了解内容)</h4> <p>还可以使用JDK7优化后的<code class="language-plaintext highlighter-rouge">try-with-resource</code> 语句，该语句确保了每个资源在语句结束时关闭。所谓的资源（resource）是指在程序完成后，必须关闭的对象。</p> <p>格式：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span> <span class="o">(</span><span class="n">创建流对象语句</span><span class="err">，</span><span class="n">如果多个</span><span class="o">,</span><span class="n">使用</span><span class="sc">';'</span><span class="n">隔开</span><span class="o">)</span> <span class="o">{</span>
	<span class="c1">// 读写数据</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
	<span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div> <p>代码使用演示：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">HandleException2</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
      	<span class="c1">// 创建流对象</span>
        <span class="k">try</span> <span class="o">(</span> <span class="nc">FileWriter</span> <span class="n">fw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileWriter</span><span class="o">(</span><span class="s">"fw.txt"</span><span class="o">);</span> <span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 写出数据</span>
            <span class="n">fw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"我是程序员"</span><span class="o">);</span> <span class="c1">//我是程序员</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h4 id="jdk9的改进扩展知识点了解内容">JDK9的改进(扩展知识点了解内容)</h4> <p>JDK9中<code class="language-plaintext highlighter-rouge">try-with-resource</code> 的改进，对于<strong>引入对象</strong>的方式，支持的更加简洁。被引入的对象，同样可以自动关闭，无需手动close，我们来了解一下格式。</p> <p>改进前格式：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 被final修饰的对象</span>
<span class="kd">final</span> <span class="nc">Resource</span> <span class="n">resource1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Resource</span><span class="o">(</span><span class="s">"resource1"</span><span class="o">);</span>
<span class="c1">// 普通对象</span>
<span class="nc">Resource</span> <span class="n">resource2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Resource</span><span class="o">(</span><span class="s">"resource2"</span><span class="o">);</span>
<span class="c1">// 引入方式：创建新的变量保存</span>
<span class="k">try</span> <span class="o">(</span><span class="nc">Resource</span> <span class="n">r1</span> <span class="o">=</span> <span class="n">resource1</span><span class="o">;</span>
     <span class="nc">Resource</span> <span class="n">r2</span> <span class="o">=</span> <span class="n">resource2</span><span class="o">)</span> <span class="o">{</span>
     <span class="c1">// 使用对象</span>
<span class="o">}</span>
</code></pre></div></div> <p>改进后格式：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 被final修饰的对象</span>
<span class="kd">final</span> <span class="nc">Resource</span> <span class="n">resource1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Resource</span><span class="o">(</span><span class="s">"resource1"</span><span class="o">);</span>
<span class="c1">// 普通对象</span>
<span class="nc">Resource</span> <span class="n">resource2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Resource</span><span class="o">(</span><span class="s">"resource2"</span><span class="o">);</span>

<span class="c1">// 引入方式：直接引入</span>
<span class="k">try</span> <span class="o">(</span><span class="n">resource1</span><span class="o">;</span> <span class="n">resource2</span><span class="o">)</span> <span class="o">{</span>
     <span class="c1">// 使用对象</span>
<span class="o">}</span>
</code></pre></div></div> <p>改进后，代码使用演示：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TryDemo</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
       	<span class="c1">// 创建流对象</span>
        <span class="kd">final</span>  <span class="nc">FileReader</span> <span class="n">fr</span>  <span class="o">=</span> <span class="k">new</span> <span class="nc">FileReader</span><span class="o">(</span><span class="s">"in.txt"</span><span class="o">);</span>
        <span class="nc">FileWriter</span> <span class="n">fw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileWriter</span><span class="o">(</span><span class="s">"out.txt"</span><span class="o">);</span>
       	<span class="c1">// 引入到try中</span>
        <span class="k">try</span> <span class="o">(</span><span class="n">fr</span><span class="o">;</span> <span class="n">fw</span><span class="o">)</span> <span class="o">{</span>
          	<span class="c1">// 定义变量</span>
            <span class="kt">int</span> <span class="n">b</span><span class="o">;</span>
          	<span class="c1">// 读取数据</span>
          	<span class="k">while</span> <span class="o">((</span><span class="n">b</span> <span class="o">=</span> <span class="n">fr</span><span class="o">.</span><span class="na">read</span><span class="o">())!=-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            	<span class="c1">// 写出数据</span>
            	<span class="n">fw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">b</span><span class="o">);</span>
          	<span class="o">}</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.io.FileWriter</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>

<span class="cm">/*
    在jdk1.7之前使用try catch finally 处理流中的异常
    格式:
        try{
            可能会产出异常的代码
        }catch(异常类变量 变量名){
            异常的处理逻辑
        }finally{
            一定会指定的代码
            资源释放
        }
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo01TryCatch</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//提高变量fw的作用域,让finally可以使用</span>
        <span class="c1">//变量在定义的时候,可以没有值,但是使用的时候必须有值</span>
        <span class="c1">//fw = new FileWriter("09_IOAndProperties\\g.txt",true); 执行失败,fw没有值,fw.close会报错</span>
        <span class="nc">FileWriter</span> <span class="n">fw</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">try</span><span class="o">{</span>
            <span class="c1">//可能会产出异常的代码</span>
            <span class="n">fw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileWriter</span><span class="o">(</span><span class="s">"w:\\09_IOAndProperties\\g.txt"</span><span class="o">,</span><span class="kc">true</span><span class="o">);</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span><span class="mi">10</span> <span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">fw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"HelloWorld"</span><span class="o">+</span><span class="n">i</span><span class="o">+</span><span class="s">"\r\n"</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span><span class="k">catch</span><span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">){</span>
            <span class="c1">//异常的处理逻辑</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
        <span class="o">}</span><span class="k">finally</span> <span class="o">{</span>
            <span class="c1">//一定会指定的代码</span>
            <span class="c1">//创建对象失败了,fw的默认值就是null,null是不能调用方法的,会抛出NullPointerException,需要增加一个判断,不是null在把资源释放</span>
            <span class="k">if</span><span class="o">(</span><span class="n">fw</span><span class="o">!=</span><span class="kc">null</span><span class="o">){</span>
                <span class="k">try</span> <span class="o">{</span>
                    <span class="c1">//fw.close方法声明抛出了IOException异常对象,所以我们就的处理这个异常对象,要么throws,要么try catch</span>
                    <span class="n">fw</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
                <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
                <span class="o">}</span>
            <span class="o">}</span>

        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.io.FileInputStream</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.FileOutputStream</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>

<span class="cm">/*
    JDK7的新特性
    在try的后边可以增加一个(),在括号中可以定义流对象
    那么这个流对象的作用域就在try中有效
    try中的代码执行完毕,会自动把流对象释放,不用写finally
    格式:
        try(定义流对象;定义流对象....){
            可能会产出异常的代码
        }catch(异常类变量 变量名){
            异常的处理逻辑
        }
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo02JDK7</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">try</span><span class="o">(</span><span class="c1">//1.创建一个字节输入流对象,构造方法中绑定要读取的数据源</span>
            <span class="nc">FileInputStream</span> <span class="n">fis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"c:\\1.jpg"</span><span class="o">);</span>
            <span class="c1">//2.创建一个字节输出流对象,构造方法中绑定要写入的目的地</span>
            <span class="nc">FileOutputStream</span> <span class="n">fos</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"d:\\1.jpg"</span><span class="o">);){</span>

            <span class="c1">//可能会产出异常的代码</span>
            <span class="c1">//一次读取一个字节写入一个字节的方式</span>
            <span class="c1">//3.使用字节输入流对象中的方法read读取文件</span>
            <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="k">while</span><span class="o">((</span><span class="n">len</span> <span class="o">=</span> <span class="n">fis</span><span class="o">.</span><span class="na">read</span><span class="o">())!=-</span><span class="mi">1</span><span class="o">){</span>
                <span class="c1">//4.使用字节输出流中的方法write,把读取到的字节写入到目的地的文件中</span>
                <span class="n">fos</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">len</span><span class="o">);</span>
            <span class="o">}</span>

        <span class="o">}</span><span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">){</span>
            <span class="c1">//异常的处理逻辑</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
        <span class="o">}</span>


    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.io.FileInputStream</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.FileOutputStream</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>

<span class="cm">/*
    JDK9新特性
    try的前边可以定义流对象
    在try后边的()中可以直接引入流对象的名称(变量名)
    在try代码执行完毕之后,流对象也可以释放掉,不用写finally
    格式:
        A a = new A();
        B b = new B();
        try(a,b){
            可能会产出异常的代码
        }catch(异常类变量 变量名){
            异常的处理逻辑
        }
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo03JDK9</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="c1">//1.创建一个字节输入流对象,构造方法中绑定要读取的数据源</span>
        <span class="nc">FileInputStream</span> <span class="n">fis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"c:\\1.jpg"</span><span class="o">);</span>
        <span class="c1">//2.创建一个字节输出流对象,构造方法中绑定要写入的目的地</span>
        <span class="nc">FileOutputStream</span> <span class="n">fos</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"d:\\1.jpg"</span><span class="o">);</span>

        <span class="k">try</span><span class="o">(</span><span class="n">fis</span><span class="o">;</span><span class="n">fos</span><span class="o">){</span>
            <span class="c1">//一次读取一个字节写入一个字节的方式</span>
            <span class="c1">//3.使用字节输入流对象中的方法read读取文件</span>
            <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="k">while</span><span class="o">((</span><span class="n">len</span> <span class="o">=</span> <span class="n">fis</span><span class="o">.</span><span class="na">read</span><span class="o">())!=-</span><span class="mi">1</span><span class="o">){</span>
                <span class="c1">//4.使用字节输出流中的方法write,把读取到的字节写入到目的地的文件中</span>
                <span class="n">fos</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">len</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span><span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">){</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">//fos.write(1);//Stream Closed</span>

    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h2 id="8-属性集">8. 属性集</h2> <h3 id="81-概述">8.1 概述</h3> <p><code class="language-plaintext highlighter-rouge">java.util.Properties </code> 继承于<code class="language-plaintext highlighter-rouge"> Hashtable</code> ，来表示一个持久的属性集。它使用键值结构存储数据，每个键及其对应值都是一个字符串。该类也被许多Java类使用，比如获取系统属性时，<code class="language-plaintext highlighter-rouge">System.getProperties</code> 方法就是返回一个<code class="language-plaintext highlighter-rouge">Properties</code>对象。</p> <h3 id="82-properties类">8.2 Properties类</h3> <h4 id="构造方法-4">构造方法</h4> <ul> <li><code class="language-plaintext highlighter-rouge">public Properties()</code> :创建一个空的属性列表。</li> </ul> <h4 id="基本的存储方法">基本的存储方法</h4> <ul> <li><code class="language-plaintext highlighter-rouge">public Object setProperty(String key, String value)</code> ： 保存一对属性。</li> <li><code class="language-plaintext highlighter-rouge">public String getProperty(String key) </code> ：使用此属性列表中指定的键搜索属性值。</li> <li><code class="language-plaintext highlighter-rouge">public Set&lt;String&gt; stringPropertyNames() </code> ：所有键的名称的集合。</li> </ul> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ProDemo</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">FileNotFoundException</span> <span class="o">{</span>
        <span class="c1">// 创建属性集对象</span>
        <span class="nc">Properties</span> <span class="n">properties</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Properties</span><span class="o">();</span>
        <span class="c1">// 添加键值对元素</span>
        <span class="n">properties</span><span class="o">.</span><span class="na">setProperty</span><span class="o">(</span><span class="s">"filename"</span><span class="o">,</span> <span class="s">"a.txt"</span><span class="o">);</span>
        <span class="n">properties</span><span class="o">.</span><span class="na">setProperty</span><span class="o">(</span><span class="s">"length"</span><span class="o">,</span> <span class="s">"209385038"</span><span class="o">);</span>
        <span class="n">properties</span><span class="o">.</span><span class="na">setProperty</span><span class="o">(</span><span class="s">"location"</span><span class="o">,</span> <span class="s">"D:\\a.txt"</span><span class="o">);</span>
        <span class="c1">// 打印属性集对象</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">properties</span><span class="o">);</span>
        <span class="c1">// 通过键,获取属性值</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">properties</span><span class="o">.</span><span class="na">getProperty</span><span class="o">(</span><span class="s">"filename"</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">properties</span><span class="o">.</span><span class="na">getProperty</span><span class="o">(</span><span class="s">"length"</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">properties</span><span class="o">.</span><span class="na">getProperty</span><span class="o">(</span><span class="s">"location"</span><span class="o">));</span>

        <span class="c1">// 遍历属性集,获取所有键的集合</span>
        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">strings</span> <span class="o">=</span> <span class="n">properties</span><span class="o">.</span><span class="na">stringPropertyNames</span><span class="o">();</span>
        <span class="c1">// 打印键值对</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">key</span> <span class="o">:</span> <span class="n">strings</span> <span class="o">)</span> <span class="o">{</span>
          	<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">key</span><span class="o">+</span><span class="s">" -- "</span><span class="o">+</span><span class="n">properties</span><span class="o">.</span><span class="na">getProperty</span><span class="o">(</span><span class="n">key</span><span class="o">));</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="n">输出结果</span><span class="err">：</span>
<span class="o">{</span><span class="n">filename</span><span class="o">=</span><span class="n">a</span><span class="o">.</span><span class="na">txt</span><span class="o">,</span> <span class="n">length</span><span class="o">=</span><span class="mi">209385038</span><span class="o">,</span> <span class="n">location</span><span class="o">=</span><span class="nl">D:</span><span class="err">\</span><span class="n">a</span><span class="o">.</span><span class="na">txt</span><span class="o">}</span>
<span class="n">a</span><span class="o">.</span><span class="na">txt</span>
<span class="mi">209385038</span>
<span class="nl">D:</span><span class="err">\</span><span class="n">a</span><span class="o">.</span><span class="na">txt</span>
<span class="n">filename</span> <span class="o">--</span> <span class="n">a</span><span class="o">.</span><span class="na">txt</span>
<span class="n">length</span> <span class="o">--</span> <span class="mi">209385038</span>
<span class="n">location</span> <span class="o">--</span> <span class="nl">D:</span><span class="err">\</span><span class="n">a</span><span class="o">.</span><span class="na">txt</span>
</code></pre></div></div> <h4 id="与流相关的方法">与流相关的方法</h4> <ul> <li><code class="language-plaintext highlighter-rouge">public void load(InputStream inStream)</code>： 从字节输入流中读取键值对。</li> </ul> <p>参数中使用了字节输入流，通过流对象，可以关联到某文件上，这样就能够加载文本中的数据了。文本数据格式:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>filename=a.txt
length=209385038
location=D:\a.txt
</code></pre></div></div> <p>加载代码演示：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ProDemo2</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">FileNotFoundException</span> <span class="o">{</span>
        <span class="c1">// 创建属性集对象</span>
        <span class="nc">Properties</span> <span class="n">pro</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Properties</span><span class="o">();</span>
        <span class="c1">// 加载文本中信息到属性集</span>
        <span class="n">pro</span><span class="o">.</span><span class="na">load</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"read.txt"</span><span class="o">));</span>
        <span class="c1">// 遍历集合并打印</span>
        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">strings</span> <span class="o">=</span> <span class="n">pro</span><span class="o">.</span><span class="na">stringPropertyNames</span><span class="o">();</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">key</span> <span class="o">:</span> <span class="n">strings</span> <span class="o">)</span> <span class="o">{</span>
          	<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">key</span><span class="o">+</span><span class="s">" -- "</span><span class="o">+</span><span class="n">pro</span><span class="o">.</span><span class="na">getProperty</span><span class="o">(</span><span class="n">key</span><span class="o">));</span>
        <span class="o">}</span>
     <span class="o">}</span>
<span class="o">}</span>
<span class="n">输出结果</span><span class="err">：</span>
<span class="n">filename</span> <span class="o">--</span> <span class="n">a</span><span class="o">.</span><span class="na">txt</span>
<span class="n">length</span> <span class="o">--</span> <span class="mi">209385038</span>
<span class="n">location</span> <span class="o">--</span> <span class="nl">D:</span><span class="err">\</span><span class="n">a</span><span class="o">.</span><span class="na">txt</span>
</code></pre></div></div> <blockquote> <p>小贴士：文本中的数据，必须是键值对形式，可以使用空格、等号、冒号等符号分隔。</p> </blockquote> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.io.FileOutputStream</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.FileReader</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Properties</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Set</span><span class="o">;</span>

<span class="cm">/*
    java.util.Properties集合 extends Hashtable&lt;k,v&gt; implements Map&lt;k,v&gt;
    Properties 类表示了一个持久的属性集。Properties 可保存在流中或从流中加载。
    Properties集合是一个唯一和IO流相结合的集合
        可以使用Properties集合中的方法store,把集合中的临时数据,持久化写入到硬盘中存储
        可以使用Properties集合中的方法load,把硬盘中保存的文件(键值对),读取到集合中使用

    属性列表中每个键及其对应值都是一个字符串。
        Properties集合是一个双列集合,key和value默认都是字符串
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo01Properties</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="n">show03</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="cm">/*
        可以使用Properties集合中的方法load,把硬盘中保存的文件(键值对),读取到集合中使用
        void load(InputStream inStream)
        void load(Reader reader)
        参数:
            InputStream inStream:字节输入流,不能读取含有中文的键值对
            Reader reader:字符输入流,能读取含有中文的键值对
        使用步骤:
            1.创建Properties集合对象
            2.使用Properties集合对象中的方法load读取保存键值对的文件
            3.遍历Properties集合
        注意:
            1.存储键值对的文件中,键与值默认的连接符号可以使用=,空格(其他符号)
            2.存储键值对的文件中,可以使用#进行注释,被注释的键值对不会再被读取
            3.存储键值对的文件中,键与值默认都是字符串,不用再加引号
     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">show03</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="c1">//1.创建Properties集合对象</span>
        <span class="nc">Properties</span> <span class="n">prop</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Properties</span><span class="o">();</span>
        <span class="c1">//2.使用Properties集合对象中的方法load读取保存键值对的文件</span>
        <span class="n">prop</span><span class="o">.</span><span class="na">load</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileReader</span><span class="o">(</span><span class="s">"09_IOAndProperties\\prop.txt"</span><span class="o">));</span>
        <span class="c1">//prop.load(new FileInputStream("09_IOAndProperties\\prop.txt"));</span>
        <span class="c1">//3.遍历Properties集合</span>
        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="n">prop</span><span class="o">.</span><span class="na">stringPropertyNames</span><span class="o">();</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">key</span> <span class="o">:</span> <span class="n">set</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">String</span> <span class="n">value</span> <span class="o">=</span> <span class="n">prop</span><span class="o">.</span><span class="na">getProperty</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">key</span><span class="o">+</span><span class="s">"="</span><span class="o">+</span><span class="n">value</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="cm">/*
        可以使用Properties集合中的方法store,把集合中的临时数据,持久化写入到硬盘中存储
        void store(OutputStream out, String comments)
        void store(Writer writer, String comments)
        参数:
            OutputStream out:字节输出流,不能写入中文
            Writer writer:字符输出流,可以写中文
            String comments:注释,用来解释说明保存的文件是做什么用的
                    不能使用中文,会产生乱码,默认是Unicode编码
                    一般使用""空字符串

        使用步骤:
            1.创建Properties集合对象,添加数据
            2.创建字节输出流/字符输出流对象,构造方法中绑定要输出的目的地
            3.使用Properties集合中的方法store,把集合中的临时数据,持久化写入到硬盘中存储
            4.释放资源
     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">show02</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="c1">//1.创建Properties集合对象,添加数据</span>
        <span class="nc">Properties</span> <span class="n">prop</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Properties</span><span class="o">();</span>
        <span class="n">prop</span><span class="o">.</span><span class="na">setProperty</span><span class="o">(</span><span class="s">"赵丽颖"</span><span class="o">,</span><span class="s">"168"</span><span class="o">);</span>
        <span class="n">prop</span><span class="o">.</span><span class="na">setProperty</span><span class="o">(</span><span class="s">"迪丽热巴"</span><span class="o">,</span><span class="s">"165"</span><span class="o">);</span>
        <span class="n">prop</span><span class="o">.</span><span class="na">setProperty</span><span class="o">(</span><span class="s">"古力娜扎"</span><span class="o">,</span><span class="s">"160"</span><span class="o">);</span>

        <span class="c1">//2.创建字节输出流/字符输出流对象,构造方法中绑定要输出的目的地</span>
        <span class="c1">//FileWriter fw = new FileWriter("09_IOAndProperties\\prop.txt");</span>

        <span class="c1">//3.使用Properties集合中的方法store,把集合中的临时数据,持久化写入到硬盘中存储</span>
        <span class="c1">//prop.store(fw,"save data");</span>

        <span class="c1">//4.释放资源</span>
        <span class="c1">//fw.close();</span>

        <span class="n">prop</span><span class="o">.</span><span class="na">store</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"09_IOAndProperties\\prop2.txt"</span><span class="o">),</span><span class="s">""</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="cm">/*
        使用Properties集合存储数据,遍历取出Properties集合中的数据
        Properties集合是一个双列集合,key和value默认都是字符串
        Properties集合有一些操作字符串的特有方法
            Object setProperty(String key, String value) 调用 Hashtable 的方法 put。
            String getProperty(String key) 通过key找到value值,此方法相当于Map集合中的get(key)方法
            Set&lt;String&gt; stringPropertyNames() 返回此属性列表中的键集，其中该键及其对应值是字符串,此方法相当于Map集合中的keySet方法
     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">show01</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">//创建Properties集合对象</span>
        <span class="nc">Properties</span> <span class="n">prop</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Properties</span><span class="o">();</span>
        <span class="c1">//使用setProperty往集合中添加数据</span>
        <span class="n">prop</span><span class="o">.</span><span class="na">setProperty</span><span class="o">(</span><span class="s">"赵丽颖"</span><span class="o">,</span><span class="s">"168"</span><span class="o">);</span>
        <span class="n">prop</span><span class="o">.</span><span class="na">setProperty</span><span class="o">(</span><span class="s">"迪丽热巴"</span><span class="o">,</span><span class="s">"165"</span><span class="o">);</span>
        <span class="n">prop</span><span class="o">.</span><span class="na">setProperty</span><span class="o">(</span><span class="s">"古力娜扎"</span><span class="o">,</span><span class="s">"160"</span><span class="o">);</span>
        <span class="c1">//prop.put(1,true);</span>

        <span class="c1">//使用stringPropertyNames把Properties集合中的键取出,存储到一个Set集合中</span>
        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="n">prop</span><span class="o">.</span><span class="na">stringPropertyNames</span><span class="o">();</span>

        <span class="c1">//遍历Set集合,取出Properties集合的每一个键</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">key</span> <span class="o">:</span> <span class="n">set</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">//使用getProperty方法通过key获取value</span>
            <span class="nc">String</span> <span class="n">value</span> <span class="o">=</span> <span class="n">prop</span><span class="o">.</span><span class="na">getProperty</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">key</span><span class="o">+</span><span class="s">"="</span><span class="o">+</span><span class="n">value</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h2 id="9-缓冲流">9. 缓冲流</h2> <p>昨天学习了基本的一些流，作为IO流的入门，今天我们要见识一些更强大的流。比如能够高效读写的缓冲流，能够转换编码的转换流，能够持久化存储对象的序列化流等等。这些功能更为强大的流，都是在基本的流对象 基础之上创建而来的，就像穿上铠甲的武士一样，相当于是对基本流对象的一种增强。</p> <p><img src="https://blog.slienceme.cn/images/posts/2021012716055586.bmp.jpg" alt="Alt Text" /></p> <h3 id="91-概述">9.1 概述</h3> <p>缓冲流,也叫高效流，是对4个基本的<code class="language-plaintext highlighter-rouge">FileXxx</code> 流的增强，所以也是4个流，按照数据类型分类：</p> <ul> <li><strong>字节缓冲流</strong>：<code class="language-plaintext highlighter-rouge">BufferedInputStream</code>，<code class="language-plaintext highlighter-rouge">BufferedOutputStream</code></li> <li><strong>字符缓冲流</strong>：<code class="language-plaintext highlighter-rouge">BufferedReader</code>，<code class="language-plaintext highlighter-rouge">BufferedWriter</code></li> </ul> <p>缓冲流的基本原理，是在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写的效率。</p> <h3 id="92-字节缓冲流">9.2 字节缓冲流</h3> <h4 id="构造方法-5">构造方法</h4> <ul> <li><code class="language-plaintext highlighter-rouge">public BufferedInputStream(InputStream in)</code> ：创建一个 新的缓冲输入流。</li> <li><code class="language-plaintext highlighter-rouge">public BufferedOutputStream(OutputStream out)</code>： 创建一个新的缓冲输出流。</li> </ul> <p>构造举例，代码如下：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 创建字节缓冲输入流</span>
<span class="nc">BufferedInputStream</span> <span class="n">bis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedInputStream</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"bis.txt"</span><span class="o">));</span>
<span class="c1">// 创建字节缓冲输出流</span>
<span class="nc">BufferedOutputStream</span> <span class="n">bos</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedOutputStream</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"bos.txt"</span><span class="o">));</span>
</code></pre></div></div> <hr /> <hr /> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.io.BufferedOutputStream</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.FileOutputStream</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>

<span class="cm">/*
    java.io.BufferedOutputStream extends OutputStream
    BufferedOutputStream:字节缓冲输出流

    继承自父类的共性成员方法:
        - public void close() ：关闭此输出流并释放与此流相关联的任何系统资源。
        - public void flush() ：刷新此输出流并强制任何缓冲的输出字节被写出。
        - public void write(byte[] b)：将 b.length字节从指定的字节数组写入此输出流。
        - public void write(byte[] b, int off, int len) ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。
        - public abstract void write(int b) ：将指定的字节输出流。

     构造方法:
        BufferedOutputStream(OutputStream out)  创建一个新的缓冲输出流，以将数据写入指定的底层输出流。
        BufferedOutputStream(OutputStream out, int size)  创建一个新的缓冲输出流，以将具有指定缓冲区大小的数据写入指定的底层输出流。
        参数:
           OutputStream out:字节输出流
                我们可以传递FileOutputStream,缓冲流会给FileOutputStream增加一个缓冲区,提高FileOutputStream的写入效率
           int size:指定缓冲流内部缓冲区的大小,不指定默认
     使用步骤(重点)
        1.创建FileOutputStream对象,构造方法中绑定要输出的目的地
        2.创建BufferedOutputStream对象,构造方法中传递FileOutputStream对象对象,提高FileOutputStream对象效率
        3.使用BufferedOutputStream对象中的方法write,把数据写入到内部缓冲区中
        4.使用BufferedOutputStream对象中的方法flush,把内部缓冲区中的数据,刷新到文件中
        5.释放资源(会先调用flush方法刷新数据,第4部可以省略)
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo01BufferedOutputStream</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="c1">//1.创建FileOutputStream对象,构造方法中绑定要输出的目的地</span>
        <span class="nc">FileOutputStream</span> <span class="n">fos</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"10_IO\\a.txt"</span><span class="o">);</span>
        <span class="c1">//2.创建BufferedOutputStream对象,构造方法中传递FileOutputStream对象对象,提高FileOutputStream对象效率</span>
        <span class="nc">BufferedOutputStream</span> <span class="n">bos</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedOutputStream</span><span class="o">(</span><span class="n">fos</span><span class="o">);</span>
        <span class="c1">//3.使用BufferedOutputStream对象中的方法write,把数据写入到内部缓冲区中</span>
        <span class="n">bos</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"我把数据写入到内部缓冲区中"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">());</span>
        <span class="c1">//4.使用BufferedOutputStream对象中的方法flush,把内部缓冲区中的数据,刷新到文件中</span>
        <span class="n">bos</span><span class="o">.</span><span class="na">flush</span><span class="o">();</span>
        <span class="c1">//5.释放资源(会先调用flush方法刷新数据,第4部可以省略)</span>
        <span class="n">bos</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.io.BufferedInputStream</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.FileInputStream</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>

<span class="cm">/*
    java.io.BufferedInputStream extends InputStream
    BufferedInputStream:字节缓冲输入流

    继承自父类的成员方法:
        int read()从输入流中读取数据的下一个字节。
        int read(byte[] b) 从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b 中。
        void close() 关闭此输入流并释放与该流关联的所有系统资源。

    构造方法:
        BufferedInputStream(InputStream in) 创建一个 BufferedInputStream 并保存其参数，即输入流 in，以便将来使用。
        BufferedInputStream(InputStream in, int size) 创建具有指定缓冲区大小的 BufferedInputStream 并保存其参数，即输入流 in，以便将来使用。
        参数:
            InputStream in:字节输入流
                我们可以传递FileInputStream,缓冲流会给FileInputStream增加一个缓冲区,提高FileInputStream的读取效率
            int size:指定缓冲流内部缓冲区的大小,不指定默认

    使用步骤(重点):
        1.创建FileInputStream对象,构造方法中绑定要读取的数据源
        2.创建BufferedInputStream对象,构造方法中传递FileInputStream对象,提高FileInputStream对象的读取效率
        3.使用BufferedInputStream对象中的方法read,读取文件
        4.释放资源
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo02BufferedInputStream</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="c1">//1.创建FileInputStream对象,构造方法中绑定要读取的数据源</span>
        <span class="nc">FileInputStream</span> <span class="n">fis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"10_IO\\a.txt"</span><span class="o">);</span>
        <span class="c1">//2.创建BufferedInputStream对象,构造方法中传递FileInputStream对象,提高FileInputStream对象的读取效率</span>
        <span class="nc">BufferedInputStream</span> <span class="n">bis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedInputStream</span><span class="o">(</span><span class="n">fis</span><span class="o">);</span>
        <span class="c1">//3.使用BufferedInputStream对象中的方法read,读取文件</span>
        <span class="c1">//int read()从输入流中读取数据的下一个字节。</span>
        <span class="cm">/*int len = 0;//记录每次读取到的字节
        while((len = bis.read())!=-1){
            System.out.println(len);
        }*/</span>

        <span class="c1">//int read(byte[] b) 从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b 中。</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">bytes</span> <span class="o">=</span><span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="mi">1024</span><span class="o">];</span><span class="c1">//存储每次读取的数据</span>
        <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">//记录每次读取的有效字节个数</span>
        <span class="k">while</span><span class="o">((</span><span class="n">len</span> <span class="o">=</span> <span class="n">bis</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">bytes</span><span class="o">))!=-</span><span class="mi">1</span><span class="o">){</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">bytes</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="n">len</span><span class="o">));</span>
        <span class="o">}</span>

        <span class="c1">//4.释放资源</span>
        <span class="n">bis</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h4 id="效率测试">效率测试</h4> <p>查询API，缓冲流读写方法与基本的流是一致的，我们通过复制大文件（375MB），测试它的效率。</p> <ol> <li>基本流，代码如下：</li> </ol> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">BufferedDemo</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">FileNotFoundException</span> <span class="o">{</span>
        <span class="c1">// 记录开始时间</span>
      	<span class="kt">long</span> <span class="n">start</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>
		<span class="c1">// 创建流对象</span>
        <span class="k">try</span> <span class="o">(</span>
        	<span class="nc">FileInputStream</span> <span class="n">fis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"jdk9.exe"</span><span class="o">);</span>
        	<span class="nc">FileOutputStream</span> <span class="n">fos</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"copy.exe"</span><span class="o">)</span>
        <span class="o">){</span>
        	<span class="c1">// 读写数据</span>
            <span class="kt">int</span> <span class="n">b</span><span class="o">;</span>
            <span class="k">while</span> <span class="o">((</span><span class="n">b</span> <span class="o">=</span> <span class="n">fis</span><span class="o">.</span><span class="na">read</span><span class="o">())</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">fos</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">b</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
		<span class="c1">// 记录结束时间</span>
        <span class="kt">long</span> <span class="n">end</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"普通流复制时间:"</span><span class="o">+(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="o">)+</span><span class="s">" 毫秒"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="n">十几分钟过去了</span><span class="o">...</span>
</code></pre></div></div> <ol> <li>缓冲流，代码如下：</li> </ol> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">BufferedDemo</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">FileNotFoundException</span> <span class="o">{</span>
        <span class="c1">// 记录开始时间</span>
      	<span class="kt">long</span> <span class="n">start</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>
		<span class="c1">// 创建流对象</span>
        <span class="k">try</span> <span class="o">(</span>
        	<span class="nc">BufferedInputStream</span> <span class="n">bis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedInputStream</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"jdk9.exe"</span><span class="o">));</span>
	     <span class="nc">BufferedOutputStream</span> <span class="n">bos</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedOutputStream</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"copy.exe"</span><span class="o">));</span>
        <span class="o">){</span>
        <span class="c1">// 读写数据</span>
            <span class="kt">int</span> <span class="n">b</span><span class="o">;</span>
            <span class="k">while</span> <span class="o">((</span><span class="n">b</span> <span class="o">=</span> <span class="n">bis</span><span class="o">.</span><span class="na">read</span><span class="o">())</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">bos</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">b</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
		<span class="c1">// 记录结束时间</span>
        <span class="kt">long</span> <span class="n">end</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"缓冲流复制时间:"</span><span class="o">+(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="o">)+</span><span class="s">" 毫秒"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="nl">缓冲流复制时间:</span><span class="mi">8016</span> <span class="n">毫秒</span>
</code></pre></div></div> <p>如何更快呢？</p> <p>使用数组的方式，代码如下：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">BufferedDemo</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">FileNotFoundException</span> <span class="o">{</span>
      	<span class="c1">// 记录开始时间</span>
        <span class="kt">long</span> <span class="n">start</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>
		<span class="c1">// 创建流对象</span>
        <span class="k">try</span> <span class="o">(</span>
			<span class="nc">BufferedInputStream</span> <span class="n">bis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedInputStream</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"jdk9.exe"</span><span class="o">));</span>
		 <span class="nc">BufferedOutputStream</span> <span class="n">bos</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedOutputStream</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"copy.exe"</span><span class="o">));</span>
        <span class="o">){</span>
          	<span class="c1">// 读写数据</span>
            <span class="kt">int</span> <span class="n">len</span><span class="o">;</span>
            <span class="kt">byte</span><span class="o">[]</span> <span class="n">bytes</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="mi">8</span><span class="o">*</span><span class="mi">1024</span><span class="o">];</span>
            <span class="k">while</span> <span class="o">((</span><span class="n">len</span> <span class="o">=</span> <span class="n">bis</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">bytes</span><span class="o">))</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">bos</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">bytes</span><span class="o">,</span> <span class="mi">0</span> <span class="o">,</span> <span class="n">len</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
		<span class="c1">// 记录结束时间</span>
        <span class="kt">long</span> <span class="n">end</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"缓冲流使用数组复制时间:"</span><span class="o">+(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="o">)+</span><span class="s">" 毫秒"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="nl">缓冲流使用数组复制时间:</span><span class="mi">666</span> <span class="n">毫秒</span>
</code></pre></div></div> <hr /> <hr /> <hr /> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.io.FileInputStream</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.FileOutputStream</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>

<span class="cm">/*
    文件复制练习:一读一写

    明确:
        数据源: c:\\1.jpg
        数据的目的地: d:\\1.jpg

    文件复制的步骤:
        1.创建一个字节输入流对象,构造方法中绑定要读取的数据源
        2.创建一个字节输出流对象,构造方法中绑定要写入的目的地
        3.使用字节输入流对象中的方法read读取文件
        4.使用字节输出流中的方法write,把读取到的字节写入到目的地的文件中
        5.释放资源
    文件的大小:780,831 字节
    一次读写一个字节:6043毫秒
    使用数组缓冲读取多个字节,写入多个字节:10毫秒
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo01CopyFile</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="kt">long</span> <span class="n">s</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>
        <span class="c1">//1.创建一个字节输入流对象,构造方法中绑定要读取的数据源</span>
        <span class="nc">FileInputStream</span> <span class="n">fis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"c:\\1.jpg"</span><span class="o">);</span>
        <span class="c1">//2.创建一个字节输出流对象,构造方法中绑定要写入的目的地</span>
        <span class="nc">FileOutputStream</span> <span class="n">fos</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"d:\\1.jpg"</span><span class="o">);</span>
        <span class="c1">//一次读取一个字节写入一个字节的方式</span>
        <span class="c1">//3.使用字节输入流对象中的方法read读取文件</span>
        <span class="cm">/*int len = 0;
        while((len = fis.read())!=-1){
            //4.使用字节输出流中的方法write,把读取到的字节写入到目的地的文件中
            fos.write(len);
        }*/</span>

        <span class="c1">//使用数组缓冲读取多个字节,写入多个字节</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">bytes</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="mi">1024</span><span class="o">];</span>
        <span class="c1">//3.使用字节输入流对象中的方法read读取文件</span>
        <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span><span class="c1">//每次读取的有效字节个数</span>
        <span class="k">while</span><span class="o">((</span><span class="n">len</span> <span class="o">=</span> <span class="n">fis</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">bytes</span><span class="o">))!=-</span><span class="mi">1</span><span class="o">){</span>
            <span class="c1">//4.使用字节输出流中的方法write,把读取到的字节写入到目的地的文件中</span>
            <span class="n">fos</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">bytes</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="n">len</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">//5.释放资源(先关写的,后关闭读的;如果写完了,肯定读取完毕了)</span>
        <span class="n">fos</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="n">fis</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="kt">long</span> <span class="n">e</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"复制文件共耗时:"</span><span class="o">+(</span><span class="n">e</span><span class="o">-</span><span class="n">s</span><span class="o">)+</span><span class="s">"毫秒"</span><span class="o">);</span>
    <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>

<span class="cm">/*
    文件复制练习:一读一写

    明确:
        数据源: c:\\1.jpg
        数据的目的地: d:\\1.jpg
    文件复制的步骤:
        1.创建字节缓冲输入流对象,构造方法中传递字节输入流
        2.创建字节缓冲输出流对象,构造方法中传递字节输出流
        3.使用字节缓冲输入流对象中的方法read,读取文件
        4.使用字节缓冲输出流中的方法write,把读取的数据写入到内部缓冲区中
        5.释放资源(会先把缓冲区中的数据,刷新到文件中)

    文件的大小:780,831 字节
    一次读写一个字节:32毫秒
    使用数组缓冲读取多个字节,写入多个字节:5毫秒
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo02CopyFile</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="kt">long</span> <span class="n">s</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>
        <span class="c1">//1.创建字节缓冲输入流对象,构造方法中传递字节输入流</span>
        <span class="nc">BufferedInputStream</span> <span class="n">bis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedInputStream</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"c:\\1.jpg"</span><span class="o">));</span>
        <span class="c1">//2.创建字节缓冲输出流对象,构造方法中传递字节输出流</span>
        <span class="nc">BufferedOutputStream</span> <span class="n">bos</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedOutputStream</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"d:\\1.jpg"</span><span class="o">));</span>
        <span class="c1">//3.使用字节缓冲输入流对象中的方法read,读取文件</span>
        <span class="c1">//一次读取一个字节写入一个字节的方式</span>
        <span class="cm">/*int len = 0;
        while((len = bis.read())!=-1){
            bos.write(len);
        }*/</span>

        <span class="c1">//使用数组缓冲读取多个字节,写入多个字节</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">bytes</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="mi">1024</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span><span class="o">((</span><span class="n">len</span> <span class="o">=</span> <span class="n">bis</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">bytes</span><span class="o">))!=-</span><span class="mi">1</span><span class="o">){</span>
            <span class="n">bos</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">bytes</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="n">len</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="n">bos</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="n">bis</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>

        <span class="kt">long</span> <span class="n">e</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"复制文件共耗时:"</span><span class="o">+(</span><span class="n">e</span><span class="o">-</span><span class="n">s</span><span class="o">)+</span><span class="s">"毫秒"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h3 id="93-字符缓冲流">9.3 字符缓冲流</h3> <h4 id="构造方法-6">构造方法</h4> <ul> <li><code class="language-plaintext highlighter-rouge">public BufferedReader(Reader in)</code> ：创建一个 新的缓冲输入流。</li> <li><code class="language-plaintext highlighter-rouge">public BufferedWriter(Writer out)</code>： 创建一个新的缓冲输出流。</li> </ul> <p>构造举例，代码如下：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 创建字符缓冲输入流</span>
<span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileReader</span><span class="o">(</span><span class="s">"br.txt"</span><span class="o">));</span>
<span class="c1">// 创建字符缓冲输出流</span>
<span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileWriter</span><span class="o">(</span><span class="s">"bw.txt"</span><span class="o">));</span>
</code></pre></div></div> <h4 id="特有方法">特有方法</h4> <p>字符缓冲流的基本方法与普通字符流调用方式一致，不再阐述，我们来看它们具备的特有方法。</p> <ul> <li>BufferedReader：<code class="language-plaintext highlighter-rouge">public String readLine()</code>: 读一行文字。</li> <li>BufferedWriter：<code class="language-plaintext highlighter-rouge">public void newLine()</code>: 写一行行分隔符,由系统属性定义符号。</li> </ul> <p><code class="language-plaintext highlighter-rouge">readLine</code>方法演示，代码如下：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">BufferedReaderDemo</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
      	 <span class="c1">// 创建流对象</span>
        <span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileReader</span><span class="o">(</span><span class="s">"in.txt"</span><span class="o">));</span>
		<span class="c1">// 定义字符串,保存读取的一行文字</span>
        <span class="nc">String</span> <span class="n">line</span>  <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
      	<span class="c1">// 循环读取,读取到最后返回null</span>
        <span class="k">while</span> <span class="o">((</span><span class="n">line</span> <span class="o">=</span> <span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">())!=</span><span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">line</span><span class="o">);</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"------"</span><span class="o">);</span>
        <span class="o">}</span>
		<span class="c1">// 释放资源</span>
        <span class="n">br</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">newLine</code>方法演示，代码如下：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">BufferedWriterDemo</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span>  <span class="o">{</span>
      	<span class="c1">// 创建流对象</span>
		<span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileWriter</span><span class="o">(</span><span class="s">"out.txt"</span><span class="o">));</span>
      	<span class="c1">// 写出数据</span>
        <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"我是"</span><span class="o">);</span>
      	<span class="c1">// 写出换行</span>
        <span class="n">bw</span><span class="o">.</span><span class="na">newLine</span><span class="o">();</span>
        <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"程序"</span><span class="o">);</span>
        <span class="n">bw</span><span class="o">.</span><span class="na">newLine</span><span class="o">();</span>
        <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"员"</span><span class="o">);</span>
        <span class="n">bw</span><span class="o">.</span><span class="na">newLine</span><span class="o">();</span>
		<span class="c1">// 释放资源</span>
        <span class="n">bw</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="nl">输出效果:</span>
<span class="n">我是</span>
<span class="n">程序</span>
<span class="n">员</span>
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.io.BufferedWriter</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.FileWriter</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>

<span class="cm">/*
    java.io.BufferedWriter extends Writer
    BufferedWriter:字符缓冲输出流

    继承自父类的共性成员方法:
        - void write(int c) 写入单个字符。
        - void write(char[] cbuf)写入字符数组。
        - abstract  void write(char[] cbuf, int off, int len)写入字符数组的某一部分,off数组的开始索引,len写的字符个数。
        - void write(String str)写入字符串。
        - void write(String str, int off, int len) 写入字符串的某一部分,off字符串的开始索引,len写的字符个数。
        - void flush()刷新该流的缓冲。
        - void close() 关闭此流，但要先刷新它。

    构造方法:
        BufferedWriter(Writer out) 创建一个使用默认大小输出缓冲区的缓冲字符输出流。
        BufferedWriter(Writer out, int sz) 创建一个使用给定大小输出缓冲区的新缓冲字符输出流。
        参数:
            Writer out:字符输出流
                我们可以传递FileWriter,缓冲流会给FileWriter增加一个缓冲区,提高FileWriter的写入效率
            int sz:指定缓冲区的大小,不写默认大小

    特有的成员方法:
        void newLine() 写入一个行分隔符。会根据不同的操作系统,获取不同的行分隔符
        换行:换行符号
        windows:\r\n
        linux:/n
        mac:/r
     使用步骤:
        1.创建字符缓冲输出流对象,构造方法中传递字符输出流
        2.调用字符缓冲输出流中的方法write,把数据写入到内存缓冲区中
        3.调用字符缓冲输出流中的方法flush,把内存缓冲区中的数据,刷新到文件中
        4.释放资源
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo03BufferedWriter</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="c1">//System.out.println();</span>
        <span class="c1">//1.创建字符缓冲输出流对象,构造方法中传递字符输出流</span>
        <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileWriter</span><span class="o">(</span><span class="s">"10_IO\\c.txt"</span><span class="o">));</span>
        <span class="c1">//2.调用字符缓冲输出流中的方法write,把数据写入到内存缓冲区中</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span><span class="mi">10</span> <span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"举世无双"</span><span class="o">);</span>
            <span class="c1">//bw.write("\r\n");</span>
            <span class="n">bw</span><span class="o">.</span><span class="na">newLine</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="c1">//3.调用字符缓冲输出流中的方法flush,把内存缓冲区中的数据,刷新到文件中</span>
        <span class="n">bw</span><span class="o">.</span><span class="na">flush</span><span class="o">();</span>
        <span class="c1">//4.释放资源</span>
        <span class="n">bw</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.io.BufferedReader</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.FileReader</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>

<span class="cm">/*
    java.io.BufferedReader extends Reader
    BufferedReader:字符缓冲输入流

    继承自父类的共性成员方法:
        int read() 读取单个字符并返回。
        int read(char[] cbuf)一次读取多个字符,将字符读入数组。
        void close() 关闭该流并释放与之关联的所有资源。

     构造方法:
        BufferedReader(Reader in)  创建一个使用默认大小输入缓冲区的缓冲字符输入流。
        BufferedReader(Reader in, int sz)     创建一个使用指定大小输入缓冲区的缓冲字符输入流。
        参数:
            Reader in:字符输入流
                我们可以传递FileReader,缓冲流会给FileReader增加一个缓冲区,提高FileReader的读取效率
     特有的成员方法:
        String readLine() 读取一个文本行。读取一行数据
            行的终止符号:通过下列字符之一即可认为某行已终止：换行 ('\n')、回车 ('\r') 或回车后直接跟着换行(\r\n)。
        返回值:
            包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null

     使用步骤:
        1.创建字符缓冲输入流对象,构造方法中传递字符输入流
        2.使用字符缓冲输入流对象中的方法read/readLine读取文本
        3.释放资源
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo04BufferedReader</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="c1">//1.创建字符缓冲输入流对象,构造方法中传递字符输入流</span>
        <span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileReader</span><span class="o">(</span><span class="s">"10_IO\\c.txt"</span><span class="o">));</span>

        <span class="c1">//2.使用字符缓冲输入流对象中的方法read/readLine读取文本</span>
        <span class="cm">/*String line = br.readLine();
        System.out.println(line);

        line = br.readLine();
        System.out.println(line);

        line = br.readLine();
        System.out.println(line);

        line = br.readLine();
        System.out.println(line);*/</span>

        <span class="cm">/*
            发下以上读取是一个重复的过程,所以可以使用循环优化
            不知道文件中有多少行数据,所以使用while循环
            while的结束条件,读取到null结束
         */</span>
        <span class="nc">String</span> <span class="n">line</span><span class="o">;</span>
        <span class="k">while</span><span class="o">((</span><span class="n">line</span> <span class="o">=</span> <span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">())!=</span><span class="kc">null</span><span class="o">){</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">line</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">//3.释放资源</span>
        <span class="n">br</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h3 id="94-练习文本排序">9.4 练习:文本排序</h3> <p>请将文本信息恢复顺序。</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>3.侍中、侍郎郭攸之、费祎、董允等，此皆良实，志虑忠纯，是以先帝简拔以遗陛下。愚以为宫中之事，事无大小，悉以咨之，然后施行，必得裨补阙漏，有所广益。
8.愿陛下托臣以讨贼兴复之效，不效，则治臣之罪，以告先帝之灵。若无兴德之言，则责攸之、祎、允等之慢，以彰其咎；陛下亦宜自谋，以咨诹善道，察纳雅言，深追先帝遗诏，臣不胜受恩感激。
4.将军向宠，性行淑均，晓畅军事，试用之于昔日，先帝称之曰能，是以众议举宠为督。愚以为营中之事，悉以咨之，必能使行阵和睦，优劣得所。
2.宫中府中，俱为一体，陟罚臧否，不宜异同。若有作奸犯科及为忠善者，宜付有司论其刑赏，以昭陛下平明之理，不宜偏私，使内外异法也。
1.先帝创业未半而中道崩殂，今天下三分，益州疲弊，此诚危急存亡之秋也。然侍卫之臣不懈于内，忠志之士忘身于外者，盖追先帝之殊遇，欲报之于陛下也。诚宜开张圣听，以光先帝遗德，恢弘志士之气，不宜妄自菲薄，引喻失义，以塞忠谏之路也。
9.今当远离，临表涕零，不知所言。
6.臣本布衣，躬耕于南阳，苟全性命于乱世，不求闻达于诸侯。先帝不以臣卑鄙，猥自枉屈，三顾臣于草庐之中，咨臣以当世之事，由是感激，遂许先帝以驱驰。后值倾覆，受任于败军之际，奉命于危难之间，尔来二十有一年矣。
7.先帝知臣谨慎，故临崩寄臣以大事也。受命以来，夙夜忧叹，恐付托不效，以伤先帝之明，故五月渡泸，深入不毛。今南方已定，兵甲已足，当奖率三军，北定中原，庶竭驽钝，攘除奸凶，兴复汉室，还于旧都。此臣所以报先帝而忠陛下之职分也。至于斟酌损益，进尽忠言，则攸之、祎、允之任也。
5.亲贤臣，远小人，此先汉所以兴隆也；亲小人，远贤臣，此后汉所以倾颓也。先帝在时，每与臣论此事，未尝不叹息痛恨于桓、灵也。侍中、尚书、长史、参军，此悉贞良死节之臣，愿陛下亲之信之，则汉室之隆，可计日而待也。
</code></pre></div></div> <h4 id="案例分析">案例分析</h4> <ol> <li>逐行读取文本信息。</li> <li>解析文本信息到集合中。</li> <li>遍历集合，按顺序，写出文本信息。</li> </ol> <h4 id="案例实现-1">案例实现</h4> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">BufferedTest</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="c1">// 创建map集合,保存文本数据,键为序号,值为文字</span>
        <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">lineMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// 创建流对象</span>
        <span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileReader</span><span class="o">(</span><span class="s">"in.txt"</span><span class="o">));</span>
        <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileWriter</span><span class="o">(</span><span class="s">"out.txt"</span><span class="o">));</span>

        <span class="c1">// 读取数据</span>
        <span class="nc">String</span> <span class="n">line</span>  <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">((</span><span class="n">line</span> <span class="o">=</span> <span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">())!=</span><span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 解析文本</span>
            <span class="nc">String</span><span class="o">[]</span> <span class="n">split</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">"\\."</span><span class="o">);</span>
            <span class="c1">// 保存到集合</span>
            <span class="n">lineMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">split</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span><span class="n">split</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span>
        <span class="o">}</span>
        <span class="c1">// 释放资源</span>
        <span class="n">br</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>

        <span class="c1">// 遍历map集合</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">lineMap</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">String</span> <span class="n">key</span> <span class="o">=</span> <span class="nc">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="c1">// 获取map中文本</span>
            <span class="nc">String</span> <span class="n">value</span> <span class="o">=</span> <span class="n">lineMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
          	<span class="c1">// 写出拼接文本</span>
            <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">key</span><span class="o">+</span><span class="s">"."</span><span class="o">+</span><span class="n">value</span><span class="o">);</span>
          	<span class="c1">// 写出换行</span>
            <span class="n">bw</span><span class="o">.</span><span class="na">newLine</span><span class="o">();</span>
        <span class="o">}</span>
		<span class="c1">// 释放资源</span>
        <span class="n">bw</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.HashMap</span><span class="o">;</span>

<span class="cm">/*
    练习:
        对文本的内容进行排序
        按照(1,2,3....)顺序排序
    分析:
        1.创建一个HashMap集合对象,可以:存储每行文本的序号(1,2,3,..);value:存储每行的文本
        2.创建字符缓冲输入流对象,构造方法中绑定字符输入流
        3.创建字符缓冲输出流对象,构造方法中绑定字符输出流
        4.使用字符缓冲输入流中的方法readline,逐行读取文本
        5.对读取到的文本进行切割,获取行中的序号和文本内容
        6.把切割好的序号和文本的内容存储到HashMap集合中(key序号是有序的,会自动排序1,2,3,4..)
        7.遍历HashMap集合,获取每一个键值对
        8.把每一个键值对,拼接为一个文本行
        9.把拼接好的文本,使用字符缓冲输出流中的方法write,写入到文件中
        10.释放资源
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo05Test</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="c1">//1.创建一个HashMap集合对象,可以:存储每行文本的序号(1,2,3,..);value:存储每行的文本</span>
        <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="c1">//2.创建字符缓冲输入流对象,构造方法中绑定字符输入流</span>
        <span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileReader</span><span class="o">(</span><span class="s">"10_IO\\in.txt"</span><span class="o">));</span>
        <span class="c1">//3.创建字符缓冲输出流对象,构造方法中绑定字符输出流</span>
        <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileWriter</span><span class="o">(</span><span class="s">"10_IO\\out.txt"</span><span class="o">));</span>
        <span class="c1">//4.使用字符缓冲输入流中的方法readline,逐行读取文本</span>
        <span class="nc">String</span> <span class="n">line</span><span class="o">;</span>
        <span class="k">while</span><span class="o">((</span><span class="n">line</span> <span class="o">=</span> <span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">())!=</span><span class="kc">null</span><span class="o">){</span>
            <span class="c1">//5.对读取到的文本进行切割,获取行中的序号和文本内容</span>
            <span class="nc">String</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">"\\."</span><span class="o">);</span>
            <span class="c1">//6.把切割好的序号和文本的内容存储到HashMap集合中(key序号是有序的,会自动排序1,2,3,4..)</span>
            <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span><span class="n">arr</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span>
        <span class="o">}</span>

        <span class="c1">//7.遍历HashMap集合,获取每一个键值对</span>
        <span class="k">for</span><span class="o">(</span><span class="nc">String</span> <span class="n">key</span> <span class="o">:</span> <span class="n">map</span><span class="o">.</span><span class="na">keySet</span><span class="o">()){</span>
            <span class="nc">String</span> <span class="n">value</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
            <span class="c1">//8.把每一个键值对,拼接为一个文本行</span>
            <span class="n">line</span> <span class="o">=</span> <span class="n">key</span> <span class="o">+</span> <span class="s">"."</span> <span class="o">+</span> <span class="n">value</span><span class="o">;</span>
            <span class="c1">//9.把拼接好的文本,使用字符缓冲输出流中的方法write,写入到文件中</span>
            <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">line</span><span class="o">);</span>
            <span class="n">bw</span><span class="o">.</span><span class="na">newLine</span><span class="o">();</span><span class="c1">//写换行</span>
        <span class="o">}</span>
        <span class="c1">//10.释放资源</span>
        <span class="n">bw</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="n">br</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h2 id="10-转换流">10. 转换流</h2> <h3 id="101-字符编码和字符集">10.1 字符编码和字符集</h3> <h4 id="字符编码">字符编码</h4> <p>计算机中储存的信息都是用二进制数表示的，而我们在屏幕上看到的数字、英文、标点符号、汉字等字符是二进制数转换之后的结果。按照某种规则，将字符存储到计算机中，称为<strong>编码</strong> 。反之，将存储在计算机中的二进制数按照某种规则解析显示出来，称为<strong>解码</strong> 。比如说，按照A规则存储，同样按照A规则解析，那么就能显示正确的文本符号。反之，按照A规则存储，再按照B规则解析，就会导致乱码现象。</p> <p>编码:字符(能看懂的)–字节(看不懂的)</p> <p>解码:字节(看不懂的)–&gt;字符(能看懂的)</p> <ul> <li> <p><strong>字符编码<code class="language-plaintext highlighter-rouge">Character Encoding</code></strong> : 就是一套自然语言的字符与二进制数之间的对应规则。</p> <p>编码表:生活中文字和计算机中二进制的对应规则</p> </li> </ul> <h4 id="字符集">字符集</h4> <ul> <li><strong>字符集 <code class="language-plaintext highlighter-rouge">Charset</code></strong>：也叫编码表。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。</li> </ul> <p>计算机要准确的存储和识别各种字符集符号，需要进行字符编码，一套字符集必然至少有一套字符编码。常见字符集有ASCII字符集、GBK字符集、Unicode字符集等。</p> <p><img src="https://blog.slienceme.cn/images/posts/20210126095749716.jpg" alt="Alt Text" /></p> <p>可见，当指定了<strong>编码</strong>，它所对应的<strong>字符集</strong>自然就指定了，所以<strong>编码</strong>才是我们最终要关心的。</p> <ul> <li><strong>ASCII字符集</strong> ： <ul> <li>ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统，用于显示现代英语，主要包括控制字符（回车键、退格、换行键等）和可显示字符（英文大小写字符、阿拉伯数字和西文符号）。</li> <li>基本的ASCII字符集，使用7位（bits）表示一个字符，共128字符。ASCII的扩展字符集使用8位（bits）表示一个字符，共256字符，方便支持欧洲常用字符。</li> </ul> </li> <li><strong>ISO-8859-1字符集</strong>： <ul> <li>拉丁码表，别名Latin-1，用于显示欧洲使用的语言，包括荷兰、丹麦、德语、意大利语、西班牙语等。</li> <li>ISO-8859-1使用单字节编码，兼容ASCII编码。</li> </ul> </li> <li><strong>GBxxx字符集</strong>： <ul> <li>GB就是国标的意思，是为了显示中文而设计的一套字符集。</li> <li><strong>GB2312</strong>：简体中文码表。一个小于127的字符的意义与原来相同。但两个大于127的字符连在一起时，就表示一个汉字，这样大约可以组合了包含7000多个简体汉字，此外数学符号、罗马希腊的字母、日文的假名们都编进去了，连在ASCII里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了。</li> <li><strong>GBK</strong>：最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了双字节编码方案，共收录了21003个汉字，完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等。</li> <li><strong>GB18030</strong>：最新的中文码表。收录汉字70244个，采用多字节编码，每个字可以由1个、2个或4个字节组成。支持中国国内少数民族的文字，同时支持繁体汉字以及日韩汉字等。</li> </ul> </li> <li><strong>Unicode字符集</strong> ： <ul> <li>Unicode编码系统为表达任意语言的任意字符而设计，是业界的一种标准，也称为统一码、标准万国码。</li> <li>它最多使用4个字节的数字来表达每个字母、符号，或者文字。有三种编码方案，UTF-8、UTF-16和UTF-32。最为常用的UTF-8编码。</li> <li>UTF-8编码，可以用来表示Unicode标准中任何字符，它是电子邮件、网页及其他存储或传送文字的应用中，优先采用的编码。互联网工程工作小组（IETF）要求所有互联网协议都必须支持UTF-8编码。所以，我们开发Web应用，也要使用UTF-8编码。它使用一至四个字节为每个字符编码，编码规则： <ol> <li>128个US-ASCII字符，只需一个字节编码。</li> <li>拉丁文等字符，需要二个字节编码。</li> <li>大部分常用字（含中文），使用三个字节编码。</li> <li>其他极少使用的Unicode辅助字符，使用四字节编码。</li> </ol> </li> </ul> </li> </ul> <h3 id="102-编码引出的问题">10.2 编码引出的问题</h3> <p>在IDEA中，使用<code class="language-plaintext highlighter-rouge">FileReader</code> 读取项目中的文本文件。由于IDEA的设置，都是默认的<code class="language-plaintext highlighter-rouge">UTF-8</code>编码，所以没有任何问题。但是，当读取Windows系统中创建的文本文件时，由于Windows系统的默认是GBK编码，就会出现乱码。</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ReaderDemo</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="nc">FileReader</span> <span class="n">fileReader</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileReader</span><span class="o">(</span><span class="s">"E:\\File_GBK.txt"</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">read</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">((</span><span class="n">read</span> <span class="o">=</span> <span class="n">fileReader</span><span class="o">.</span><span class="na">read</span><span class="o">())</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">((</span><span class="kt">char</span><span class="o">)</span><span class="n">read</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">fileReader</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="n">输出结果</span><span class="err">：</span>
<span class="err">���</span>
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.io.FileReader</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>

<span class="cm">/*
    FileReader可以读取IDE默认编码格式(UTF-8)的文件
    FileReader读取系统默认编码(中文GBK)会产生乱码���
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo01FileReader</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="nc">FileReader</span> <span class="n">fr</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileReader</span><span class="o">(</span><span class="s">"10_IO\\我是GBK格式的文本.txt"</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span><span class="o">((</span><span class="n">len</span> <span class="o">=</span> <span class="n">fr</span><span class="o">.</span><span class="na">read</span><span class="o">())!=-</span><span class="mi">1</span><span class="o">){</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">((</span><span class="kt">char</span><span class="o">)</span><span class="n">len</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">fr</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>那么如何读取GBK编码的文件呢？ <img src="https://blog.slienceme.cn/images/posts/20210127163851842.bmp.jpg" alt="Alt Text" /></p> <h3 id="103-inputstreamreader类">10.3 InputStreamReader类</h3> <p>转换流<code class="language-plaintext highlighter-rouge">java.io.InputStreamReader</code>，是Reader的子类，是从字节流到字符流的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。</p> <h4 id="构造方法-7">构造方法</h4> <ul> <li><code class="language-plaintext highlighter-rouge">InputStreamReader(InputStream in)</code>: 创建一个使用默认字符集的字符流。</li> <li><code class="language-plaintext highlighter-rouge">InputStreamReader(InputStream in, String charsetName)</code>: 创建一个指定字符集的字符流。</li> </ul> <p>构造举例，代码如下：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">InputStreamReader</span> <span class="n">isr</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"in.txt"</span><span class="o">));</span>
<span class="nc">InputStreamReader</span> <span class="n">isr2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"in.txt"</span><span class="o">)</span> <span class="o">,</span> <span class="s">"GBK"</span><span class="o">);</span>
</code></pre></div></div> <h4 id="指定编码读取">指定编码读取</h4> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ReaderDemo2</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
      	<span class="c1">// 定义文件路径,文件为gbk编码</span>
        <span class="nc">String</span> <span class="nc">FileName</span> <span class="o">=</span> <span class="s">"E:\\file_gbk.txt"</span><span class="o">;</span>
      	<span class="c1">// 创建流对象,默认UTF8编码</span>
        <span class="nc">InputStreamReader</span> <span class="n">isr</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="nc">FileName</span><span class="o">));</span>
      	<span class="c1">// 创建流对象,指定GBK编码</span>
        <span class="nc">InputStreamReader</span> <span class="n">isr2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="nc">FileName</span><span class="o">)</span> <span class="o">,</span> <span class="s">"GBK"</span><span class="o">);</span>
		<span class="c1">// 定义变量,保存字符</span>
        <span class="kt">int</span> <span class="n">read</span><span class="o">;</span>
      	<span class="c1">// 使用默认编码字符流读取,乱码</span>
        <span class="k">while</span> <span class="o">((</span><span class="n">read</span> <span class="o">=</span> <span class="n">isr</span><span class="o">.</span><span class="na">read</span><span class="o">())</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">((</span><span class="kt">char</span><span class="o">)</span><span class="n">read</span><span class="o">);</span> <span class="c1">// ��Һ�</span>
        <span class="o">}</span>
        <span class="n">isr</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
      
      	<span class="c1">// 使用指定编码字符流读取,正常解析</span>
        <span class="k">while</span> <span class="o">((</span><span class="n">read</span> <span class="o">=</span> <span class="n">isr2</span><span class="o">.</span><span class="na">read</span><span class="o">())</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">((</span><span class="kt">char</span><span class="o">)</span><span class="n">read</span><span class="o">);</span><span class="c1">// 大家好</span>
        <span class="o">}</span>
        <span class="n">isr2</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <hr /> <hr /> <hr /> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.io.FileInputStream</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.InputStreamReader</span><span class="o">;</span>

<span class="cm">/*
    java.io.InputStreamReader extends Reader
    InputStreamReader:是字节流通向字符流的桥梁：它使用指定的 charset 读取字节并将其解码为字符。(解码:把看不懂的变成能看懂的)

    继承自父类的共性成员方法:
        int read() 读取单个字符并返回。
        int read(char[] cbuf)一次读取多个字符,将字符读入数组。
        void close() 关闭该流并释放与之关联的所有资源。
    构造方法:
        InputStreamReader(InputStream in) 创建一个使用默认字符集的 InputStreamReader。
        InputStreamReader(InputStream in, String charsetName) 创建使用指定字符集的 InputStreamReader。
        参数:
            InputStream in:字节输入流,用来读取文件中保存的字节
            String charsetName:指定的编码表名称,不区分大小写,可以是utf-8/UTF-8,gbk/GBK,...不指定默认使用UTF-8
     使用步骤:
        1.创建InputStreamReader对象,构造方法中传递字节输入流和指定的编码表名称
        2.使用InputStreamReader对象中的方法read读取文件
        3.释放资源
     注意事项:
        构造方法中指定的编码表名称要和文件的编码相同,否则会发生乱码
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo03InputStreamReader</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="c1">//read_utf_8();</span>
        <span class="n">read_gbk</span><span class="o">();</span>
    <span class="o">}</span>


    <span class="cm">/*
        使用InputStreamReader读取GBK格式的文件
     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">read_gbk</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="c1">//1.创建InputStreamReader对象,构造方法中传递字节输入流和指定的编码表名称</span>
        <span class="c1">//InputStreamReader isr = new InputStreamReader(new FileInputStream("10_IO\\gbk.txt"),"UTF-8");//???</span>
        <span class="nc">InputStreamReader</span> <span class="n">isr</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"10_IO\\gbk.txt"</span><span class="o">),</span><span class="s">"GBK"</span><span class="o">);</span><span class="c1">//你好</span>

        <span class="c1">//2.使用InputStreamReader对象中的方法read读取文件</span>
        <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span><span class="o">((</span><span class="n">len</span> <span class="o">=</span> <span class="n">isr</span><span class="o">.</span><span class="na">read</span><span class="o">())!=-</span><span class="mi">1</span><span class="o">){</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">((</span><span class="kt">char</span><span class="o">)</span><span class="n">len</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="c1">//3.释放资源</span>
        <span class="n">isr</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="cm">/*
        使用InputStreamReader读取UTF-8格式的文件
     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">read_utf_8</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="c1">//1.创建InputStreamReader对象,构造方法中传递字节输入流和指定的编码表名称</span>
        <span class="c1">//InputStreamReader isr = new InputStreamReader(new FileInputStream("10_IO\\utf_8.txt"),"UTF-8");</span>
        <span class="nc">InputStreamReader</span> <span class="n">isr</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"10_IO\\utf_8.txt"</span><span class="o">));</span><span class="c1">//不指定默认使用UTF-8</span>
        <span class="c1">//2.使用InputStreamReader对象中的方法read读取文件</span>
        <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span><span class="o">((</span><span class="n">len</span> <span class="o">=</span> <span class="n">isr</span><span class="o">.</span><span class="na">read</span><span class="o">())!=-</span><span class="mi">1</span><span class="o">){</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">((</span><span class="kt">char</span><span class="o">)</span><span class="n">len</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="c1">//3.释放资源</span>
        <span class="n">isr</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h3 id="104-outputstreamwriter类">10.4 OutputStreamWriter类</h3> <p>转换流<code class="language-plaintext highlighter-rouge">java.io.OutputStreamWriter</code> ，是Writer的子类，是从字符流到字节流的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。</p> <h4 id="构造方法-8">构造方法</h4> <ul> <li><code class="language-plaintext highlighter-rouge">OutputStreamWriter(OutputStream in)</code>: 创建一个使用默认字符集的字符流。</li> <li><code class="language-plaintext highlighter-rouge">OutputStreamWriter(OutputStream in, String charsetName)</code>: 创建一个指定字符集的字符流。</li> </ul> <p>构造举例，代码如下：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">OutputStreamWriter</span> <span class="n">isr</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"out.txt"</span><span class="o">));</span>
<span class="nc">OutputStreamWriter</span> <span class="n">isr2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"out.txt"</span><span class="o">)</span> <span class="o">,</span> <span class="s">"GBK"</span><span class="o">);</span>
</code></pre></div></div> <h4 id="指定编码写出">指定编码写出</h4> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">OutputDemo</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
      	<span class="c1">// 定义文件路径</span>
        <span class="nc">String</span> <span class="nc">FileName</span> <span class="o">=</span> <span class="s">"E:\\out.txt"</span><span class="o">;</span>
      	<span class="c1">// 创建流对象,默认UTF8编码</span>
        <span class="nc">OutputStreamWriter</span> <span class="n">osw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="nc">FileName</span><span class="o">));</span>
        <span class="c1">// 写出数据</span>
      	<span class="n">osw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"你好"</span><span class="o">);</span> <span class="c1">// 保存为6个字节</span>
        <span class="n">osw</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
      	
		<span class="c1">// 定义文件路径</span>
		<span class="nc">String</span> <span class="nc">FileName2</span> <span class="o">=</span> <span class="s">"E:\\out2.txt"</span><span class="o">;</span>
     	<span class="c1">// 创建流对象,指定GBK编码</span>
        <span class="nc">OutputStreamWriter</span> <span class="n">osw2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="nc">FileName2</span><span class="o">),</span><span class="s">"GBK"</span><span class="o">);</span>
        <span class="c1">// 写出数据</span>
      	<span class="n">osw2</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"你好"</span><span class="o">);</span><span class="c1">// 保存为4个字节</span>
        <span class="n">osw2</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <hr /> <hr /> <hr /> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.io.FileOutputStream</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.OutputStreamWriter</span><span class="o">;</span>

<span class="cm">/*
    java.io.OutputStreamWriter extends Writer
    OutputStreamWriter: 是字符流通向字节流的桥梁：可使用指定的 charset 将要写入流中的字符编码成字节。(编码:把能看懂的变成看不懂)

    继续自父类的共性成员方法:
        - void write(int c) 写入单个字符。
        - void write(char[] cbuf)写入字符数组。
        - abstract  void write(char[] cbuf, int off, int len)写入字符数组的某一部分,off数组的开始索引,len写的字符个数。
        - void write(String str)写入字符串。
        - void write(String str, int off, int len) 写入字符串的某一部分,off字符串的开始索引,len写的字符个数。
        - void flush()刷新该流的缓冲。
        - void close() 关闭此流，但要先刷新它。
    构造方法:
        OutputStreamWriter(OutputStream out)创建使用默认字符编码的 OutputStreamWriter。
        OutputStreamWriter(OutputStream out, String charsetName) 创建使用指定字符集的 OutputStreamWriter。
        参数:
            OutputStream out:字节输出流,可以用来写转换之后的字节到文件中
            String charsetName:指定的编码表名称,不区分大小写,可以是utf-8/UTF-8,gbk/GBK,...不指定默认使用UTF-8
    使用步骤:
        1.创建OutputStreamWriter对象,构造方法中传递字节输出流和指定的编码表名称
        2.使用OutputStreamWriter对象中的方法write,把字符转换为字节存储缓冲区中(编码)
        3.使用OutputStreamWriter对象中的方法flush,把内存缓冲区中的字节刷新到文件中(使用字节流写字节的过程)
        4.释放资源
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo02OutputStreamWriter</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="c1">//write_utf_8();</span>
        <span class="n">write_gbk</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="cm">/*
       使用转换流OutputStreamWriter写GBK格式的文件
    */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">write_gbk</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="c1">//1.创建OutputStreamWriter对象,构造方法中传递字节输出流和指定的编码表名称</span>
        <span class="nc">OutputStreamWriter</span> <span class="n">osw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"10_IO\\gbk.txt"</span><span class="o">),</span><span class="s">"GBK"</span><span class="o">);</span>
        <span class="c1">//2.使用OutputStreamWriter对象中的方法write,把字符转换为字节存储缓冲区中(编码)</span>
        <span class="n">osw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"你好"</span><span class="o">);</span>
        <span class="c1">//3.使用OutputStreamWriter对象中的方法flush,把内存缓冲区中的字节刷新到文件中(使用字节流写字节的过程)</span>
        <span class="n">osw</span><span class="o">.</span><span class="na">flush</span><span class="o">();</span>
        <span class="c1">//4.释放资源</span>
        <span class="n">osw</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="cm">/*
        使用转换流OutputStreamWriter写UTF-8格式的文件
     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">write_utf_8</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="c1">//1.创建OutputStreamWriter对象,构造方法中传递字节输出流和指定的编码表名称</span>
        <span class="c1">//OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream("10_IO\\utf_8.txt"),"utf-8");</span>
        <span class="nc">OutputStreamWriter</span> <span class="n">osw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"10_IO\\utf_8.txt"</span><span class="o">));</span><span class="c1">//不指定默认使用UTF-8</span>
        <span class="c1">//2.使用OutputStreamWriter对象中的方法write,把字符转换为字节存储缓冲区中(编码)</span>
        <span class="n">osw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"你好"</span><span class="o">);</span>
        <span class="c1">//3.使用OutputStreamWriter对象中的方法flush,把内存缓冲区中的字节刷新到文件中(使用字节流写字节的过程)</span>
        <span class="n">osw</span><span class="o">.</span><span class="na">flush</span><span class="o">();</span>
        <span class="c1">//4.释放资源</span>
        <span class="n">osw</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
</code></pre></div></div> <h4 id="转换流理解图解">转换流理解图解</h4> <p><strong>转换流是字节与字符间的桥梁！</strong> <img src="https://blog.slienceme.cn/images/posts/2021012609580277.jpg" alt="Alt Text" /></p> <h3 id="105-练习转换文件编码">10.5 练习：转换文件编码</h3> <p>将GBK编码的文本文件，转换为UTF-8编码的文本文件。</p> <h4 id="案例分析-1">案例分析</h4> <ol> <li>指定GBK编码的转换流，读取文本文件。</li> <li>使用UTF-8编码的转换流，写出文本文件。</li> </ol> <h4 id="案例实现-2">案例实现</h4> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TransDemo</span> <span class="o">{</span>
   <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>      
    	<span class="c1">// 1.定义文件路径</span>
     	<span class="nc">String</span> <span class="n">srcFile</span> <span class="o">=</span> <span class="s">"file_gbk.txt"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">destFile</span> <span class="o">=</span> <span class="s">"file_utf8.txt"</span><span class="o">;</span>
		<span class="c1">// 2.创建流对象</span>
    	<span class="c1">// 2.1 转换输入流,指定GBK编码</span>
        <span class="nc">InputStreamReader</span> <span class="n">isr</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="n">srcFile</span><span class="o">)</span> <span class="o">,</span> <span class="s">"GBK"</span><span class="o">);</span>
    	<span class="c1">// 2.2 转换输出流,默认utf8编码</span>
        <span class="nc">OutputStreamWriter</span> <span class="n">osw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="n">destFile</span><span class="o">));</span>
		<span class="c1">// 3.读写数据</span>
    	<span class="c1">// 3.1 定义数组</span>
        <span class="kt">char</span><span class="o">[]</span> <span class="n">cbuf</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="o">[</span><span class="mi">1024</span><span class="o">];</span>
    	<span class="c1">// 3.2 定义长度</span>
        <span class="kt">int</span> <span class="n">len</span><span class="o">;</span>
    	<span class="c1">// 3.3 循环读取</span>
        <span class="k">while</span> <span class="o">((</span><span class="n">len</span> <span class="o">=</span> <span class="n">isr</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">cbuf</span><span class="o">))!=-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 循环写出</span>
          	<span class="n">osw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">cbuf</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="n">len</span><span class="o">);</span>
        <span class="o">}</span>
    	<span class="c1">// 4.释放资源</span>
        <span class="n">osw</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="n">isr</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
  	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h2 id="11-序列化">11. 序列化</h2> <h3 id="111-概述">11.1 概述</h3> <p>Java 提供了一种对象<strong>序列化</strong>的机制。用一个字节序列可以表示一个对象，该字节序列包含该<code class="language-plaintext highlighter-rouge">对象的数据</code>、<code class="language-plaintext highlighter-rouge">对象的类型</code>和<code class="language-plaintext highlighter-rouge">对象中存储的属性</code>等信息。字节序列写出到文件之后，相当于文件中<strong>持久保存</strong>了一个对象的信息。</p> <p>反之，该字节序列还可以从文件中读取回来，重构对象，对它进行<strong>反序列化</strong>。<code class="language-plaintext highlighter-rouge">对象的数据</code>、<code class="language-plaintext highlighter-rouge">对象的类型</code>和<code class="language-plaintext highlighter-rouge">对象中存储的数据</code>信息，都可以用来在内存中创建对象。看图理解序列化：</p> <p><img src="https://blog.slienceme.cn/images/posts/20210126095809791.jpg" alt="Alt Text" /> <img src="https://blog.slienceme.cn/images/posts/20210127163904533.bmp.jpg" alt="Alt Text" /></p> <h3 id="112-objectoutputstream类">11.2 ObjectOutputStream类</h3> <p><code class="language-plaintext highlighter-rouge">java.io.ObjectOutputStream </code> 类，将Java对象的原始数据类型写出到文件,实现对象的持久存储。</p> <h4 id="构造方法-9">构造方法</h4> <ul> <li><code class="language-plaintext highlighter-rouge">public ObjectOutputStream(OutputStream out) </code>： 创建一个指定OutputStream的ObjectOutputStream。</li> </ul> <p>构造举例，代码如下：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">FileOutputStream</span> <span class="n">fileOut</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"employee.txt"</span><span class="o">);</span>
<span class="nc">ObjectOutputStream</span> <span class="n">out</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ObjectOutputStream</span><span class="o">(</span><span class="n">fileOut</span><span class="o">);</span>
</code></pre></div></div> <h4 id="序列化操作">序列化操作</h4> <ol> <li>一个对象要想序列化，必须满足两个条件:</li> </ol> <ul> <li>该类必须实现<code class="language-plaintext highlighter-rouge">java.io.Serializable </code> 接口，<code class="language-plaintext highlighter-rouge">Serializable</code> 是一个标记接口，不实现此接口的类将不会使任何状态序列化或反序列化，会抛出<code class="language-plaintext highlighter-rouge">NotSerializableException</code> 。</li> <li>该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用<code class="language-plaintext highlighter-rouge">transient</code> 关键字修饰。</li> </ul> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Employee</span> <span class="kd">implements</span> <span class="n">java</span><span class="o">.</span><span class="na">io</span><span class="o">.</span><span class="na">Serializable</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="n">address</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kd">transient</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span> <span class="c1">// transient瞬态修饰成员,不会被序列化</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addressCheck</span><span class="o">()</span> <span class="o">{</span>
      	<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Address  check : "</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s">" -- "</span> <span class="o">+</span> <span class="n">address</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>2.写出对象方法</p> <ul> <li><code class="language-plaintext highlighter-rouge">public final void writeObject (Object obj)</code> : 将指定的对象写出。</li> </ul> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SerializeDemo</span><span class="o">{</span>
   	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span> <span class="o">[]</span> <span class="n">args</span><span class="o">)</span>   <span class="o">{</span>
    	<span class="nc">Employee</span> <span class="n">e</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Employee</span><span class="o">();</span>
    	<span class="n">e</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="s">"zhangsan"</span><span class="o">;</span>
    	<span class="n">e</span><span class="o">.</span><span class="na">address</span> <span class="o">=</span> <span class="s">"beiqinglu"</span><span class="o">;</span>
    	<span class="n">e</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="mi">20</span><span class="o">;</span> 
    	<span class="k">try</span> <span class="o">{</span>
      		<span class="c1">// 创建序列化流对象</span>
          <span class="nc">ObjectOutputStream</span> <span class="n">out</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ObjectOutputStream</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"employee.txt"</span><span class="o">));</span>
        	<span class="c1">// 写出对象</span>
        	<span class="n">out</span><span class="o">.</span><span class="na">writeObject</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
        	<span class="c1">// 释放资源</span>
        	<span class="n">out</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        	<span class="n">fileOut</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        	<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Serialized data is saved"</span><span class="o">);</span> <span class="c1">// 姓名，地址被序列化，年龄没有被序列化。</span>
        <span class="o">}</span> <span class="k">catch</span><span class="o">(</span><span class="nc">IOException</span> <span class="n">i</span><span class="o">)</span>   <span class="o">{</span>
            <span class="n">i</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
   	<span class="o">}</span>
<span class="o">}</span>
<span class="n">输出结果</span><span class="err">：</span>
<span class="nc">Serialized</span> <span class="n">data</span> <span class="n">is</span> <span class="n">saved</span>
</code></pre></div></div> <hr /> <hr /> <hr /> <hr /> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.io.Serializable</span><span class="o">;</span>

<span class="cm">/*
    序列化和反序列化的时候,会抛出NotSerializableException没有序列化异常
    类通过实现 java.io.Serializable 接口以启用其序列化功能。未实现此接口的类将无法使其任何状态序列化或反序列化。
    Serializable接口也叫标记型接口
        要进行序列化和反序列化的类必须实现Serializable接口,就会给类添加一个标记
        当我们进行序列化和反序列化的时候,就会检测类上是否有这个标记
            有:就可以序列化和反序列化
            没有:就会抛出 NotSerializableException异常
    去市场买肉--&gt;肉上有一个蓝色章(检测合格)--&gt;放心购买--&gt;买回来怎么吃随意


    static关键字:静态关键字
        静态优先于非静态加载到内存中(静态优先于对象进入到内存中)
        被static修饰的成员变量不能被序列化的,序列化的都是对象
        private static int age;
        oos.writeObject(new Person("小美女",18));
        Object o = ois.readObject();
        Person{name='小美女', age=0}

    transient关键字:瞬态关键字
        被transient修饰成员变量,不能被序列化
        private transient int age;
        oos.writeObject(new Person("小美女",18));
        Object o = ois.readObject();
        Person{name='小美女', age=0}

 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Person</span> <span class="kd">implements</span> <span class="nc">Serializable</span><span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">serialVersionUID</span> <span class="o">=</span> <span class="mi">1L</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="c1">//private static int age;</span>
    <span class="c1">//private transient int age;</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Person</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nf">Person</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">int</span> <span class="n">age</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="n">age</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"Person{"</span> <span class="o">+</span>
                <span class="s">"name='"</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="sc">'\''</span> <span class="o">+</span>
                <span class="s">", age="</span> <span class="o">+</span> <span class="n">age</span> <span class="o">+</span>
                <span class="sc">'}'</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getName</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setName</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getAge</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">age</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setAge</span><span class="o">(</span><span class="kt">int</span> <span class="n">age</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="n">age</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.io.FileOutputStream</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.ObjectOutputStream</span><span class="o">;</span>

<span class="cm">/*
    java.io.ObjectOutputStream extends OutputStream
    ObjectOutputStream:对象的序列化流
    作用:把对象以流的方式写入到文件中保存

    构造方法:
        ObjectOutputStream(OutputStream out) 创建写入指定 OutputStream 的 ObjectOutputStream。
        参数:
            OutputStream out:字节输出流
    特有的成员方法:
        void writeObject(Object obj) 将指定的对象写入 ObjectOutputStream。

    使用步骤:
        1.创建ObjectOutputStream对象,构造方法中传递字节输出流
        2.使用ObjectOutputStream对象中的方法writeObject,把对象写入到文件中
        3.释放资源
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo01ObjectOutputStream</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="c1">//1.创建ObjectOutputStream对象,构造方法中传递字节输出流</span>
        <span class="nc">ObjectOutputStream</span> <span class="n">oos</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ObjectOutputStream</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"10_IO\\person.txt"</span><span class="o">));</span>
        <span class="c1">//2.使用ObjectOutputStream对象中的方法writeObject,把对象写入到文件中</span>
        <span class="n">oos</span><span class="o">.</span><span class="na">writeObject</span><span class="o">(</span><span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"小美女"</span><span class="o">,</span><span class="mi">18</span><span class="o">));</span>
        <span class="c1">//3.释放资源</span>
        <span class="n">oos</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h3 id="113-objectinputstream类">11.3 ObjectInputStream类</h3> <p>ObjectInputStream反序列化流，将之前使用ObjectOutputStream序列化的原始数据恢复为对象。</p> <h4 id="构造方法-10">构造方法</h4> <ul> <li><code class="language-plaintext highlighter-rouge">public ObjectInputStream(InputStream in) </code>： 创建一个指定InputStream的ObjectInputStream。</li> </ul> <h4 id="反序列化操作1">反序列化操作1</h4> <p>如果能找到一个对象的class文件，我们可以进行反序列化操作，调用<code class="language-plaintext highlighter-rouge">ObjectInputStream</code>读取对象的方法：</p> <ul> <li><code class="language-plaintext highlighter-rouge">public final Object readObject ()</code> : 读取一个对象。</li> </ul> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DeserializeDemo</span> <span class="o">{</span>
   <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span> <span class="o">[]</span> <span class="n">args</span><span class="o">)</span>   <span class="o">{</span>
        <span class="nc">Employee</span> <span class="n">e</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">try</span> <span class="o">{</span>		
             <span class="c1">// 创建反序列化流</span>
             <span class="nc">FileInputStream</span> <span class="n">fileIn</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"employee.txt"</span><span class="o">);</span>
             <span class="nc">ObjectInputStream</span> <span class="n">in</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ObjectInputStream</span><span class="o">(</span><span class="n">fileIn</span><span class="o">);</span>
             <span class="c1">// 读取一个对象</span>
             <span class="n">e</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Employee</span><span class="o">)</span> <span class="n">in</span><span class="o">.</span><span class="na">readObject</span><span class="o">();</span>
             <span class="c1">// 释放资源</span>
             <span class="n">in</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
             <span class="n">fileIn</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="o">}</span><span class="k">catch</span><span class="o">(</span><span class="nc">IOException</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
             <span class="c1">// 捕获其他异常</span>
             <span class="n">i</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
             <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span><span class="k">catch</span><span class="o">(</span><span class="nc">ClassNotFoundException</span> <span class="n">c</span><span class="o">)</span>  <span class="o">{</span>
        	<span class="c1">// 捕获类找不到异常</span>
             <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Employee class not found"</span><span class="o">);</span>
             <span class="n">c</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
             <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">// 无异常,直接打印输出</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Name: "</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="na">name</span><span class="o">);</span>	<span class="c1">// zhangsan</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Address: "</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="na">address</span><span class="o">);</span> <span class="c1">// beiqinglu</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"age: "</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="na">age</span><span class="o">);</span> <span class="c1">// 0</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p><strong>对于JVM可以反序列化对象，它必须是能够找到class文件的类。如果找不到该类的class文件，则抛出一个 <code class="language-plaintext highlighter-rouge">ClassNotFoundException</code> 异常。</strong></p> <h4 id="反序列化操作2"><strong>反序列化操作2</strong></h4> <p><img src="https://blog.slienceme.cn/images/posts/20210127173222896.bmp.jpg" alt="Alt Text" /></p> <p><strong>另外，当JVM反序列化对象时，能找到class文件，但是class文件在序列化对象之后发生了修改，那么反序列化操作也会失败，抛出一个<code class="language-plaintext highlighter-rouge">InvalidClassException</code>异常。</strong>发生这个异常的原因如下：</p> <ul> <li>该类的序列版本号与从流中读取的类描述符的版本号不匹配</li> <li>该类包含未知数据类型</li> <li>该类没有可访问的无参数构造方法</li> </ul> <p><code class="language-plaintext highlighter-rouge">Serializable</code> 接口给需要序列化的类，提供了一个序列版本号。<code class="language-plaintext highlighter-rouge">serialVersionUID</code> 该版本号的目的在于验证序列化的对象和对应类是否版本匹配。</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Employee</span> <span class="kd">implements</span> <span class="n">java</span><span class="o">.</span><span class="na">io</span><span class="o">.</span><span class="na">Serializable</span> <span class="o">{</span>
     <span class="c1">// 加入序列版本号</span>
     <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">serialVersionUID</span> <span class="o">=</span> <span class="mi">1L</span><span class="o">;</span>
     <span class="kd">public</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
     <span class="kd">public</span> <span class="nc">String</span> <span class="n">address</span><span class="o">;</span>
     <span class="c1">// 添加新的属性 ,重新编译, 可以反序列化,该属性赋为默认值.</span>
     <span class="kd">public</span> <span class="kt">int</span> <span class="n">eid</span><span class="o">;</span> 

     <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addressCheck</span><span class="o">()</span> <span class="o">{</span>
         <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Address  check : "</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s">" -- "</span> <span class="o">+</span> <span class="n">address</span><span class="o">);</span>
     <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <hr /> <hr /> <hr /> <hr /> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.io.Serializable</span><span class="o">;</span>

<span class="cm">/*
    序列化和反序列化的时候,会抛出NotSerializableException没有序列化异常
    类通过实现 java.io.Serializable 接口以启用其序列化功能。未实现此接口的类将无法使其任何状态序列化或反序列化。
    Serializable接口也叫标记型接口
        要进行序列化和反序列化的类必须实现Serializable接口,就会给类添加一个标记
        当我们进行序列化和反序列化的时候,就会检测类上是否有这个标记
            有:就可以序列化和反序列化
            没有:就会抛出 NotSerializableException异常
    去市场买肉--&gt;肉上有一个蓝色章(检测合格)--&gt;放心购买--&gt;买回来怎么吃随意


    static关键字:静态关键字
        静态优先于非静态加载到内存中(静态优先于对象进入到内存中)
        被static修饰的成员变量不能被序列化的,序列化的都是对象
        private static int age;
        oos.writeObject(new Person("小美女",18));
        Object o = ois.readObject();
        Person{name='小美女', age=0}

    transient关键字:瞬态关键字
        被transient修饰成员变量,不能被序列化
        private transient int age;
        oos.writeObject(new Person("小美女",18));
        Object o = ois.readObject();
        Person{name='小美女', age=0}

 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Person</span> <span class="kd">implements</span> <span class="nc">Serializable</span><span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">serialVersionUID</span> <span class="o">=</span> <span class="mi">1L</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="c1">//private static int age;</span>
    <span class="c1">//private transient int age;</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Person</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nf">Person</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">int</span> <span class="n">age</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="n">age</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"Person{"</span> <span class="o">+</span>
                <span class="s">"name='"</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="sc">'\''</span> <span class="o">+</span>
                <span class="s">", age="</span> <span class="o">+</span> <span class="n">age</span> <span class="o">+</span>
                <span class="sc">'}'</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getName</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setName</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getAge</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">age</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setAge</span><span class="o">(</span><span class="kt">int</span> <span class="n">age</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="n">age</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.io.FileInputStream</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.ObjectInputStream</span><span class="o">;</span>

<span class="cm">/*
    java.io.ObjectInputStream extends InputStream
    ObjectInputStream:对象的反序列化流
    作用:把文件中保存的对象,以流的方式读取出来使用

    构造方法:
        ObjectInputStream(InputStream in) 创建从指定 InputStream 读取的 ObjectInputStream。
        参数:
            InputStream in:字节输入流
    特有的成员方法:
        Object readObject() 从 ObjectInputStream 读取对象。

    使用步骤:
        1.创建ObjectInputStream对象,构造方法中传递字节输入流
        2.使用ObjectInputStream对象中的方法readObject读取保存对象的文件
        3.释放资源
        4.使用读取出来的对象(打印)

     readObject方法声明抛出了ClassNotFoundException(class文件找不到异常)
     当不存在对象的class文件时抛出此异常
     反序列化的前提:
        1.类必须实现Serializable
        2.必须存在类对应的class文件
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo02ObjectInputStream</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span><span class="o">,</span> <span class="nc">ClassNotFoundException</span> <span class="o">{</span>
        <span class="c1">//1.创建ObjectInputStream对象,构造方法中传递字节输入流</span>
        <span class="nc">ObjectInputStream</span> <span class="n">ois</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ObjectInputStream</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"10_IO\\person.txt"</span><span class="o">));</span>
        <span class="c1">//2.使用ObjectInputStream对象中的方法readObject读取保存对象的文件</span>
        <span class="nc">Object</span> <span class="n">o</span> <span class="o">=</span> <span class="n">ois</span><span class="o">.</span><span class="na">readObject</span><span class="o">();</span>
        <span class="c1">//3.释放资源</span>
        <span class="n">ois</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="c1">//4.使用读取出来的对象(打印)</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">o</span><span class="o">);</span>
        <span class="nc">Person</span> <span class="n">p</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Person</span><span class="o">)</span><span class="n">o</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">getName</span><span class="o">()+</span><span class="n">p</span><span class="o">.</span><span class="na">getAge</span><span class="o">());</span>
    <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div> <h3 id="114-练习序列化集合">11.4 练习：序列化集合</h3> <ol> <li>将存有多个自定义对象的集合序列化操作，保存到<code class="language-plaintext highlighter-rouge">list.txt</code>文件中。</li> <li>反序列化<code class="language-plaintext highlighter-rouge">list.txt</code> ，并遍历集合，打印对象信息。</li> </ol> <h4 id="案例分析-2">案例分析</h4> <ol> <li>把若干学生对象 ，保存到集合中。</li> <li>把集合序列化。</li> <li>反序列化读取时，只需要读取一次，转换为集合类型。</li> <li>遍历集合，可以打印所有的学生信息</li> </ol> <h4 id="案例实现-3">案例实现</h4> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SerTest</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
		<span class="c1">// 创建 学生对象</span>
		<span class="nc">Student</span> <span class="n">student</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Student</span><span class="o">(</span><span class="s">"老王"</span><span class="o">,</span> <span class="s">"laow"</span><span class="o">);</span>
		<span class="nc">Student</span> <span class="n">student2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Student</span><span class="o">(</span><span class="s">"老张"</span><span class="o">,</span> <span class="s">"laoz"</span><span class="o">);</span>
		<span class="nc">Student</span> <span class="n">student3</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Student</span><span class="o">(</span><span class="s">"老李"</span><span class="o">,</span> <span class="s">"laol"</span><span class="o">);</span>

		<span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Student</span><span class="o">&gt;</span> <span class="n">arrayList</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
		<span class="n">arrayList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">student</span><span class="o">);</span>
		<span class="n">arrayList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">student2</span><span class="o">);</span>
		<span class="n">arrayList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">student3</span><span class="o">);</span>
		<span class="c1">// 序列化操作</span>
		<span class="c1">// serializ(arrayList);</span>
		
		<span class="c1">// 反序列化  </span>
		<span class="nc">ObjectInputStream</span> <span class="n">ois</span>  <span class="o">=</span> <span class="k">new</span> <span class="nc">ObjectInputStream</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"list.txt"</span><span class="o">));</span>
		<span class="c1">// 读取对象,强转为ArrayList类型</span>
		<span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Student</span><span class="o">&gt;</span> <span class="n">list</span>  <span class="o">=</span> <span class="o">(</span><span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Student</span><span class="o">&gt;)</span><span class="n">ois</span><span class="o">.</span><span class="na">readObject</span><span class="o">();</span>
		
      	<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++</span> <span class="o">){</span>
          	<span class="nc">Student</span> <span class="n">s</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
        	<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">getName</span><span class="o">()+</span><span class="s">"--"</span><span class="o">+</span> <span class="n">s</span><span class="o">.</span><span class="na">getPwd</span><span class="o">());</span>
      	<span class="o">}</span>
	<span class="o">}</span>

	<span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">serializ</span><span class="o">(</span><span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Student</span><span class="o">&gt;</span> <span class="n">arrayList</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
		<span class="c1">// 创建 序列化流 </span>
		<span class="nc">ObjectOutputStream</span> <span class="n">oos</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ObjectOutputStream</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"list.txt"</span><span class="o">));</span>
		<span class="c1">// 写出对象</span>
		<span class="n">oos</span><span class="o">.</span><span class="na">writeObject</span><span class="o">(</span><span class="n">arrayList</span><span class="o">);</span>
		<span class="c1">// 释放资源</span>
		<span class="n">oos</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>

<span class="cm">/*
    练习：序列化集合
        当我们想在文件中保存多个对象的时候
        可以把多个对象存储到一个集合中
        对集合进序列化和反序列化
    分析:
        1.定义一个存储Person对象的ArrayList集合
        2.往ArrayList集合中存储Person对象
        3.创建一个序列化流ObjectOutputStream对象
        4.使用ObjectOutputStream对象中的方法writeObject,对集合进行序列化
        5.创建一个反序列化ObjectInputStream对象
        6.使用ObjectInputStream对象中的方法readObject读取文件中保存的集合
        7.把Object类型的集合转换为ArrayList类型
        8.遍历ArrayList集合
        9.释放资源
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo03Test</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span><span class="o">,</span> <span class="nc">ClassNotFoundException</span> <span class="o">{</span>
        <span class="c1">//1.定义一个存储Person对象的ArrayList集合</span>
        <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Person</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="c1">//2.往ArrayList集合中存储Person对象</span>
        <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"张三"</span><span class="o">,</span><span class="mi">18</span><span class="o">));</span>
        <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"李四"</span><span class="o">,</span><span class="mi">19</span><span class="o">));</span>
        <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"王五"</span><span class="o">,</span><span class="mi">20</span><span class="o">));</span>
        <span class="c1">//3.创建一个序列化流ObjectOutputStream对象</span>
        <span class="nc">ObjectOutputStream</span> <span class="n">oos</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ObjectOutputStream</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"10_IO\\list.txt"</span><span class="o">));</span>
        <span class="c1">//4.使用ObjectOutputStream对象中的方法writeObject,对集合进行序列化</span>
        <span class="n">oos</span><span class="o">.</span><span class="na">writeObject</span><span class="o">(</span><span class="n">list</span><span class="o">);</span>
        <span class="c1">//5.创建一个反序列化ObjectInputStream对象</span>
        <span class="nc">ObjectInputStream</span> <span class="n">ois</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ObjectInputStream</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"10_IO\\list.txt"</span><span class="o">));</span>
        <span class="c1">//6.使用ObjectInputStream对象中的方法readObject读取文件中保存的集合</span>
        <span class="nc">Object</span> <span class="n">o</span> <span class="o">=</span> <span class="n">ois</span><span class="o">.</span><span class="na">readObject</span><span class="o">();</span>
        <span class="c1">//7.把Object类型的集合转换为ArrayList类型</span>
        <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Person</span><span class="o">&gt;</span> <span class="n">list2</span> <span class="o">=</span> <span class="o">(</span><span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Person</span><span class="o">&gt;)</span><span class="n">o</span><span class="o">;</span>
        <span class="c1">//8.遍历ArrayList集合</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">Person</span> <span class="n">p</span> <span class="o">:</span> <span class="n">list2</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">p</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="c1">//9.释放资源</span>
        <span class="n">ois</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="n">oos</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h2 id="12-打印流">12. 打印流</h2> <h3 id="121-概述">12.1 概述</h3> <p>平时我们在控制台打印输出，是调用<code class="language-plaintext highlighter-rouge">print</code>方法和<code class="language-plaintext highlighter-rouge">println</code>方法完成的，这两个方法都来自于<code class="language-plaintext highlighter-rouge">java.io.PrintStream</code>类，该类能够方便地打印各种数据类型的值，是一种便捷的输出方式。</p> <h3 id="122-printstream类">12.2 PrintStream类</h3> <h4 id="构造方法-11">构造方法</h4> <ul> <li><code class="language-plaintext highlighter-rouge">public PrintStream(String fileName) </code>： 使用指定的文件名创建一个新的打印流。</li> </ul> <p>构造举例，代码如下：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">PrintStream</span> <span class="n">ps</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PrintStream</span><span class="o">(</span><span class="s">"ps.txt"</span><span class="o">)</span><span class="err">；</span>
</code></pre></div></div> <h4 id="改变打印流向">改变打印流向</h4> <p><code class="language-plaintext highlighter-rouge">System.out</code>就是<code class="language-plaintext highlighter-rouge">PrintStream</code>类型的，只不过它的流向是系统规定的，打印在控制台上。不过，既然是流对象，我们就可以玩一个”小把戏”，改变它的流向。</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">PrintDemo</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
		<span class="c1">// 调用系统的打印流,控制台直接输出97</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="mi">97</span><span class="o">);</span>
      
		<span class="c1">// 创建打印流,指定文件的名称</span>
        <span class="nc">PrintStream</span> <span class="n">ps</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PrintStream</span><span class="o">(</span><span class="s">"ps.txt"</span><span class="o">);</span>
      	
      	<span class="c1">// 设置系统的打印流流向,输出到ps.txt</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">setOut</span><span class="o">(</span><span class="n">ps</span><span class="o">);</span>
      	<span class="c1">// 调用系统的打印流,ps.txt中输出97</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="mi">97</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.io.FileNotFoundException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.PrintStream</span><span class="o">;</span>

<span class="cm">/*
    java.io.PrintStream:打印流
        PrintStream 为其他输出流添加了功能，使它们能够方便地打印各种数据值表示形式。
    PrintStream特点:
        1.只负责数据的输出,不负责数据的读取
        2.与其他输出流不同，PrintStream 永远不会抛出 IOException
        3.有特有的方法,print,println
            void print(任意类型的值)
            void println(任意类型的值并换行)
    构造方法:
        PrintStream(File file):输出的目的地是一个文件
        PrintStream(OutputStream out):输出的目的地是一个字节输出流
        PrintStream(String fileName) :输出的目的地是一个文件路径
    PrintStream extends OutputStream
    继承自父类的成员方法:
        - public void close() ：关闭此输出流并释放与此流相关联的任何系统资源。
        - public void flush() ：刷新此输出流并强制任何缓冲的输出字节被写出。
        - public void write(byte[] b)：将 b.length字节从指定的字节数组写入此输出流。
        - public void write(byte[] b, int off, int len) ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。
        - public abstract void write(int b) ：将指定的字节输出流。
    注意:
        如果使用继承自父类的write方法写数据,那么查看数据的时候会查询编码表 97-&gt;a
        如果使用自己特有的方法print/println方法写数据,写的数据原样输出 97-&gt;97
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo01PrintStream</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">FileNotFoundException</span> <span class="o">{</span>
        <span class="c1">//System.out.println("HelloWorld");</span>

        <span class="c1">//创建打印流PrintStream对象,构造方法中绑定要输出的目的地</span>
        <span class="nc">PrintStream</span> <span class="n">ps</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PrintStream</span><span class="o">(</span><span class="s">"10_IO\\print.txt"</span><span class="o">);</span>
        <span class="c1">//如果使用继承自父类的write方法写数据,那么查看数据的时候会查询编码表 97-&gt;a</span>
        <span class="n">ps</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="mi">97</span><span class="o">);</span>
        <span class="c1">//如果使用自己特有的方法print/println方法写数据,写的数据原样输出 97-&gt;97</span>
        <span class="n">ps</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="mi">97</span><span class="o">);</span>
        <span class="n">ps</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="mf">8.8</span><span class="o">);</span>
        <span class="n">ps</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="sc">'a'</span><span class="o">);</span>
        <span class="n">ps</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"HelloWorld"</span><span class="o">);</span>
        <span class="n">ps</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>

        <span class="c1">//释放资源</span>
        <span class="n">ps</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.io.FileNotFoundException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.PrintStream</span><span class="o">;</span>

<span class="cm">/*
    可以改变输出语句的目的地(打印流的流向)
    输出语句,默认在控制台输出
    使用System.setOut方法改变输出语句的目的地改为参数中传递的打印流的目的地
        static void setOut(PrintStream out)
          重新分配“标准”输出流。
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo02PrintStream</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">FileNotFoundException</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"我是在控制台输出"</span><span class="o">);</span>

        <span class="nc">PrintStream</span> <span class="n">ps</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PrintStream</span><span class="o">(</span><span class="s">"10_IO\\目的地是打印流.txt"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">setOut</span><span class="o">(</span><span class="n">ps</span><span class="o">);</span><span class="c1">//把输出语句的目的地改变为打印流的目的地</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"我在打印流的目的地中输出"</span><span class="o">);</span>

        <span class="n">ps</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div> <div style="margin-top:2em;padding:0 1.5em;border:1px solid #d3d3d3;background-color:#deebf7"> <h3>文档信息</h3> <ul> <li>本文作者：<a href="https://blog.slienceme.cn" target="_blank">slience_me</a></li> <li>本文链接：<a href="https://blog.slienceme.cn/2021/01/27/Java%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7-%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86-File%E7%B1%BB%E4%B8%8EIO%E6%B5%81/" target="_blank">https://blog.slienceme.cn/2021/01/27/Java%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7-%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86-File%E7%B1%BB%E4%B8%8EIO%E6%B5%81/</a></li> <li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank">创意共享3.0许可证</a>）</li> </ul> </div> </article> <div class="share"> <div class="share-component" data-disabled='qq,facebook'></div> </div> <div class="comment"> <script src="https://giscus.app/client.js" data-repo="slience-me/blog-comments" data-repo-id="R_kgDOKr27jA" data-category="Announcements" data-category-id="DIC_kwDOKr27jM4CnWMe" data-mapping="title" data-strict="1" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="light" data-lang="zh-CN" data-loading="lazy" crossorigin="anonymous" async> </script> </div> </div> <div class="column one-fourth"> <h3>Search</h3> <div id="site_search"> <div id="docsearch"> <input style="width:96%" type="text" id="search_box" placeholder="Search"> </div> </div> <script src="https://cdn.jsdelivr.net/npm/@docsearch/js@3"></script> <script type="text/javascript"> docsearch({ appId: "8W5T6R2WWG", apiKey: "e56e511c7c9f85e2c97e2817664aafb2", indexName: "doc", container: "#docsearch" }); </script> <h3 class="post-directory-title mobile-hidden">Table of Contents</h3> <div id="post-directory-module" class="mobile-hidden"> <section class="post-directory"> <dl></dl> </section> </div> <script src="https://blog.slienceme.cn/assets/js/jquery.toc.js"></script> </div> </div> </section> <footer class="container"> <div class="site-footer" role="contentinfo"> <div class="copyright left mobile-block"> <img src="/images/logo/logo.png" class="w-full" style="height: 10px;width: 10px;" alt="logo" />;"> <a href="https://beian.mps.gov.cn/#/query/webSearch?code=13102202000626" rel="noreferrer" target="_blank">冀公网安备13102202000626</a> | <a href="https://beian.miit.gov.cn/#/Integrated/index" target="_blank" rel="noreferrer">津ICP备2024026565号-1</a> Copyright © 2019-present slience_me&emsp; <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a> </div> <ul class="site-footer-links right mobile-hidden"> <li> <a href="javascript:window.scrollTo(0,0)" >TOP</a> </li> </ul> <br/> <script defer src="https://vercount.one/js"></script> <div class="mobile-hidden" style="margin-top:8px"> <span id="busuanzi_container_site_pv" style="display:none"> 本站访问量<span id="busuanzi_value_site_pv"></span>次 </span> <span id="busuanzi_container_site_uv" style="display:none"> / 本站访客数<span id="busuanzi_value_site_uv"></span>人 </span> <span id="busuanzi_container_page_pv" style="display:none"> / 本页访问量<span id="busuanzi_value_page_pv"></span>次 / 统计始于2024-12-01 </span> </div> </div> </footer> <div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a> </div> <script src="https://blog.slienceme.cn/assets/vendor/share.js/dist/js/share.min.js"></script> <script src="https://blog.slienceme.cn/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function($) { $('.geopattern').each(function(){ $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script> </body> </html>
