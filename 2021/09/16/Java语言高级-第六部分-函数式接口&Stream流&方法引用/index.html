<!DOCTYPE html> <html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"> <head> <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /> <title>Java｜Java语言高级（第六部分）函数式接口&Stream流&方法引用 &mdash; Slience_me的博客</title> <link rel="stylesheet" href="https://blog.slienceme.cn/assets/vendor/primer-css/css/primer.css"> <link rel="stylesheet" href="https://blog.slienceme.cn/assets/css/components/collection.css"> <link rel="stylesheet" href="https://blog.slienceme.cn/assets/css/components/repo-card.css"> <link rel="stylesheet" href="https://blog.slienceme.cn/assets/css/sections/repo-list.css"> <link rel="stylesheet" href="https://blog.slienceme.cn/assets/css/components/boxed-group.css"> <link rel="stylesheet" href="https://blog.slienceme.cn/assets/css/globals/common.css"> <link rel="stylesheet" href="https://blog.slienceme.cn/assets/css/globals/responsive.css"> <link rel="stylesheet" href="https://blog.slienceme.cn/assets/css/posts/index.css"> <link rel="stylesheet" href="https://blog.slienceme.cn/assets/vendor/octicons/octicons/octicons.css"> <link rel="stylesheet" href="https://mazhuang.org/rouge-themes/dist/github.css"> <link rel="stylesheet" href="https://blog.slienceme.cn/assets/vendor/share.js/dist/css/share.min.css"> <link rel="canonical" href="https://blog.slienceme.cn/2021/09/16/Java%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7-%E7%AC%AC%E5%85%AD%E9%83%A8%E5%88%86-%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3&Stream%E6%B5%81&%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/"> <link rel="alternate" type="application/atom+xml" title="Slience_me的博客" href="https://blog.slienceme.cn/feed.xml"> <link rel="shortcut icon" href="https://blog.slienceme.cn/favicon.ico"> <meta property="og:title" content="Java｜Java语言高级（第六部分）函数式接口&Stream流&方法引用"> <meta name="keywords" content="编程语言, Java"> <meta name="og:keywords" content="编程语言, Java"> <meta name="description" content=""> <meta name="og:description" content=""> <meta property="og:url" content="https://blog.slienceme.cn/2021/09/16/Java%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7-%E7%AC%AC%E5%85%AD%E9%83%A8%E5%88%86-%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3&Stream%E6%B5%81&%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/"> <meta property="og:site_name" content="Slience_me的博客"> <meta property="og:type" content="article"> <meta property="og:locale" content="zh_CN" /> <meta property="article:published_time" content="2021-09-16"> <meta name="google-site-verification" content="2feHjT1GNs1Yi2JQfOtdYx7d048naG_-cMwZaDAopIA" /> <script src="https://blog.slienceme.cn/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="https://blog.slienceme.cn/assets/js/main.js"></script> </head> <body class="" data-mz=""> <header class="site-header"> <div class="container"> <h1><a href="https://blog.slienceme.cn/" title="Slience_me的博客"><span class="octicon octicon-mark-github"></span> Slience_me的博客</a></h1> <button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button> <nav class="site-header-nav" role="navigation"> <a href="https://blog.slienceme.cn/" class="site-header-nav-item" target="" title="首页">首页</a> <a href="https://blog.slienceme.cn/categories/" class="site-header-nav-item" target="" title="分类">分类</a> <a href="https://blog.slienceme.cn/archives/" class="mobile-hidden site-header-nav-item" target="" title="归档">归档</a> <a href="https://blog.slienceme.cn/open-source/" class="mobile-hidden site-header-nav-item" target="" title="开源">开源</a> <a href="https://blog.slienceme.cn/fragments/" class="site-header-nav-item" target="" title="片段">片段</a> <a href="https://blog.slienceme.cn/wiki/" class="site-header-nav-item" target="" title="维基">维基</a> <a href="https://blog.slienceme.cn/links/" class="mobile-hidden site-header-nav-item" target="" title="链接">链接</a> <a href="https://blog.slienceme.cn/about/" class="site-header-nav-item" target="" title="关于">关于</a> <a class="mobile-hidden" href="https://blog.slienceme.cn/feed.xml"><span class="octicon octicon-rss" style="color:orange;"></span></a> </nav> </div> </header> <section class="collection-head small geopattern" data-pattern-id="Java｜Java语言高级（第"> <div class="container"> <div class="columns"> <div class="column three-fourths"> <div class="collection-title"> <h1 class="collection-header">Java｜Java语言高级（第六部分）函数式接口&Stream流&方法引用</h1> <div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2021/09/16 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="https://blog.slienceme.cn/categories/#Java" title="Java">Java</a> </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 29960 字，约 86 分钟 </span> </div> </div> </div> <div class="column one-fourth mobile-hidden"> <div class="collection-title"> </div> </div> </div> </div> </section> <section class="container content"> <div class="columns"> <div class="column three-fourths" > <article class="article-content markdown-body"> <p><img src="https://blog.slienceme.cn/images/posts/logo_slienceme3.png" alt="img" /></p> <p>本文作者： <a href="https://slienceme.cn/">slience_me</a></p> <hr /> <h1 id="第一章-函数式接口">第一章 函数式接口</h1> <h2 id="11-概念">1.1 概念</h2> <p>函数式接口在Java中是指：<strong>有且仅有一个抽象方法的接口</strong>。</p> <p>函数式接口，即适用于函数式编程场景的接口。而Java中的函数式编程体现就是Lambda，所以函数式接口就是可以适用于Lambda使用的接口。只有确保接口中有且仅有一个抽象方法，Java中的Lambda才能顺利地进行推导。</p> <blockquote> <p>备注：“语法糖”是指使用更加方便，但是原理不变的代码语法。例如在遍历集合时使用的for-each语法，其实 底层的实现原理仍然是迭代器，这便是“语法糖”。从应用层面来讲，Java中的Lambda可以被当做是匿名内部 类的“语法糖”，但是二者在原理上是不同的。</p> </blockquote> <h2 id="12-格式">1.2 格式</h2> <p>只要确保接口中有且仅有一个抽象方法即可：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">修饰符</span> <span class="kd">interface</span> <span class="nc">接口名称</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="n">返回值类型</span> <span class="n">方法名称</span><span class="o">(</span><span class="n">可选参数信息</span><span class="o">);</span>
    <span class="c1">// 其他非抽象方法内容</span>
<span class="o">}</span>
</code></pre></div></div> <p>由于接口当中抽象方法的 <code class="language-plaintext highlighter-rouge">public abstract</code> 是可以省略的，所以定义一个函数式接口很简单：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">MyFunctionalInterface</span> <span class="o">{</span>   
	<span class="kt">void</span> <span class="nf">myMethod</span><span class="o">();</span>    
<span class="o">}</span>
</code></pre></div></div> <h2 id="13-functionalinterface注解">1.3 @FunctionalInterface注解</h2> <p>与 <code class="language-plaintext highlighter-rouge">@Override</code> 注解的作用类似，Java 8中专门为函数式接口引入了一个新的注解： <code class="language-plaintext highlighter-rouge">@FunctionalInterface</code> 。该注解可用于一个接口的定义上：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@FunctionalInterface</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">MyFunctionalInterface</span> <span class="o">{</span>
	<span class="kt">void</span> <span class="nf">myMethod</span><span class="o">();</span>    
<span class="o">}</span>
</code></pre></div></div> <p>一旦使用该注解来定义接口，编译器将会强制检查该接口是否确实有且仅有一个抽象方法，否则将会报错。需要注意的是，即使不使用该注解，只要满足函数式接口的定义，这仍然是一个函数式接口，使用起来都一样。</p> <h2 id="14-自定义函数式接口">1.4 自定义函数式接口</h2> <p>对于刚刚定义好的 <code class="language-plaintext highlighter-rouge">MyFunctionalInterface</code> 函数式接口，典型使用场景就是作为方法的参数：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo09FunctionalInterface</span> <span class="o">{</span>   
	<span class="c1">// 使用自定义的函数式接口作为方法参数    </span>
	<span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">doSomething</span><span class="o">(</span><span class="nc">MyFunctionalInterface</span> <span class="n">inter</span><span class="o">)</span> <span class="o">{</span>    
		<span class="n">inter</span><span class="o">.</span><span class="na">myMethod</span><span class="o">();</span> <span class="c1">// 调用自定义的函数式接口方法        </span>
	<span class="o">}</span>    
   
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>    
		<span class="c1">// 调用使用函数式接口的方法        </span>
		<span class="n">doSomething</span><span class="o">(()</span> <span class="err">‐</span><span class="o">&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Lambda执行啦！"</span><span class="o">));</span>        
	<span class="o">}</span>    
<span class="o">}</span>
</code></pre></div></div> <hr /> <hr /> <hr /> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
    函数式接口:有且只有一个抽象方法的接口,称之为函数式接口
    当然接口中可以包含其他的方法(默认,静态,私有)

    @FunctionalInterface注解
    作用:可以检测接口是否是一个函数式接口
        是:编译成功
        否:编译失败(接口中没有抽象方法抽象方法的个数多余1个)
 */</span>
<span class="nd">@FunctionalInterface</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">MyFunctionalInterface</span> <span class="o">{</span>
    <span class="c1">//定义一个抽象方法</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">method</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
    @Override注解
    检查方法是否为重写的方法
        是:编译成功
        否:编译失败
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyFunctionalInterfaceImpl</span> <span class="kd">implements</span> <span class="nc">MyFunctionalInterface</span><span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">method</span><span class="o">()</span> <span class="o">{</span>

    <span class="o">}</span>

    <span class="cm">/*@Override
    public void method2() {

    }*/</span>

    <span class="cm">/*@Override
    public void method3() {

    }*/</span>
<span class="o">}</span>

</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
    函数式接口的使用:一般可以作为方法的参数和返回值类型
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo</span> <span class="o">{</span>
    <span class="c1">//定义一个方法,参数使用函数式接口MyFunctionalInterface</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">show</span><span class="o">(</span><span class="nc">MyFunctionalInterface</span> <span class="n">myInter</span><span class="o">){</span>
        <span class="n">myInter</span><span class="o">.</span><span class="na">method</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//调用show方法,方法的参数是一个接口,所以可以传递接口的实现类对象</span>
        <span class="n">show</span><span class="o">(</span><span class="k">new</span> <span class="nc">MyFunctionalInterfaceImpl</span><span class="o">());</span>

        <span class="c1">//调用show方法,方法的参数是一个接口,所以我们可以传递接口的匿名内部类</span>
        <span class="n">show</span><span class="o">(</span><span class="k">new</span> <span class="nc">MyFunctionalInterface</span><span class="o">()</span> <span class="o">{</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">method</span><span class="o">()</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"使用匿名内部类重写接口中的抽象方法"</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">});</span>

        <span class="c1">//调用show方法,方法的参数是一个函数式接口,所以我们可以Lambda表达式</span>
        <span class="n">show</span><span class="o">(()-&gt;{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"使用Lambda表达式重写接口中的抽象方法"</span><span class="o">);</span>
        <span class="o">});</span>

        <span class="c1">//简化Lambda表达式</span>
        <span class="n">show</span><span class="o">(()-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"使用Lambda表达式重写接口中的抽象方法"</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h1 id="第二章-函数式编程">第二章 函数式编程</h1> <p>在兼顾面向对象特性的基础上，Java语言通过Lambda表达式与方法引用等，为开发者打开了函数式编程的大门。</p> <p>下面我们做一个初探。</p> <h2 id="21-lambda的延迟执行">2.1 Lambda的延迟执行</h2> <p>有些场景的代码执行后，结果不一定会被使用，从而造成性能浪费。而Lambda表达式是延迟执行的，这正好可以作为解决方案，提升性能。</p> <h3 id="性能浪费的日志案例">性能浪费的日志案例</h3> <p>注:日志可以帮助我们快速的定位问题，记录程序运行过程中的情况，以便项目的监控和优化。一种典型的场景就是对参数进行有条件使用，例如对日志消息进行拼接后，在满足条件的情况下进行打印输出：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo01Logger</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">log</span><span class="o">(</span><span class="kt">int</span> <span class="n">level</span><span class="o">,</span> <span class="nc">String</span> <span class="n">msg</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">level</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
           <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">msg</span><span class="o">);</span>  
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">String</span> <span class="n">msgA</span> <span class="o">=</span> <span class="s">"Hello"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">msgB</span> <span class="o">=</span> <span class="s">"World"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">msgC</span> <span class="o">=</span> <span class="s">"Java"</span><span class="o">;</span>
        <span class="n">log</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">msgA</span> <span class="o">+</span> <span class="n">msgB</span> <span class="o">+</span> <span class="n">msgC</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>这段代码存在问题：无论级别是否满足要求，作为 log 方法的第二个参数，三个字符串一定会首先被拼接并传入方法内，然后才会进行级别判断。如果级别不符合要求，那么字符串的拼接操作就白做了，存在性能浪费。</p> <blockquote> <p>备注：SLF4J是应用非常广泛的日志框架，它在记录日志时为了解决这种性能浪费的问题，并不推荐首先进行字符串的拼接，而是将字符串的若干部分作为可变参数传入方法中，仅在日志级别满足要求的情况下才会进行字符串拼接。例如： LOGGER.debug(“变量{}的取值为{}。”, “os”, “macOS”) ，其中的大括号 {} 为占位符。如果满足日志级别要求，则会将“os”和“macOS”两个字符串依次拼接到大括号的位置；否则不会进行字符串拼接。这也是一种可行解决方案，但Lambda可以做到更好。</p> </blockquote> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
    日志案例

    发现以下代码存在的一些性能浪费的问题
    调用showLog方法,传递的第二个参数是一个拼接后的字符串
    先把字符串拼接好,然后在调用showLog方法
    showLog方法中如果传递的日志等级不是1级
    那么就不会是如此拼接后的字符串
    所以感觉字符串就白拼接了,存在了浪费
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo01Logger</span> <span class="o">{</span>
    <span class="c1">//定义一个根据日志的级别,显示日志信息的方法</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">showLog</span><span class="o">(</span><span class="kt">int</span> <span class="n">level</span><span class="o">,</span> <span class="nc">String</span> <span class="n">message</span><span class="o">){</span>
        <span class="c1">//对日志的等级进行判断,如果是1级别,那么输出日志信息</span>
        <span class="k">if</span><span class="o">(</span><span class="n">level</span><span class="o">==</span><span class="mi">1</span><span class="o">){</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">message</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//定义三个日志信息</span>
        <span class="nc">String</span> <span class="n">msg1</span> <span class="o">=</span> <span class="s">"Hello"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">msg2</span> <span class="o">=</span> <span class="s">"World"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">msg3</span> <span class="o">=</span> <span class="s">"Java"</span><span class="o">;</span>

        <span class="c1">//调用showLog方法,传递日志级别和日志信息</span>
        <span class="n">showLog</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span><span class="n">msg1</span><span class="o">+</span><span class="n">msg2</span><span class="o">+</span><span class="n">msg3</span><span class="o">);</span>

    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h3 id="体验lambda的更优写法">体验Lambda的更优写法</h3> <p>使用Lambda必然需要一个函数式接口：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@FunctionalInterface</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">MessageBuilder</span> <span class="o">{</span> 
   <span class="nc">String</span> <span class="nf">buildMessage</span><span class="o">();</span> 
<span class="o">}</span>
</code></pre></div></div> <p>然后对 <code class="language-plaintext highlighter-rouge">log</code> 方法进行改造：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo02LoggerLambda</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">log</span><span class="o">(</span><span class="kt">int</span> <span class="n">level</span><span class="o">,</span> <span class="nc">MessageBuilder</span> <span class="n">builder</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">level</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
           <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">builder</span><span class="o">.</span><span class="na">buildMessage</span><span class="o">());</span>  
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">String</span> <span class="n">msgA</span> <span class="o">=</span> <span class="s">"Hello"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">msgB</span> <span class="o">=</span> <span class="s">"World"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">msgC</span> <span class="o">=</span> <span class="s">"Java"</span><span class="o">;</span>
        <span class="n">log</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="o">()</span> <span class="err">‐</span><span class="o">&gt;</span> <span class="n">msgA</span> <span class="o">+</span> <span class="n">msgB</span> <span class="o">+</span> <span class="n">msgC</span> <span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>这样一来，只有当级别满足要求的时候，才会进行三个字符串的拼接；否则三个字符串将不会进行拼接。</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
    使用Lambda优化日志案例
    Lambda的特点:延迟加载
    Lambda的使用前提,必须存在函数式接口
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo02Lambda</span> <span class="o">{</span>
    <span class="c1">//定义一个显示日志的方法,方法的参数传递日志的等级和MessageBuilder接口</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">showLog</span><span class="o">(</span><span class="kt">int</span> <span class="n">level</span><span class="o">,</span> <span class="nc">MessageBuilder</span> <span class="n">mb</span><span class="o">){</span>
        <span class="c1">//对日志的等级进行判断,如果是1级,则调用MessageBuilder接口中的builderMessage方法</span>
        <span class="k">if</span><span class="o">(</span><span class="n">level</span><span class="o">==</span><span class="mi">1</span><span class="o">){</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">mb</span><span class="o">.</span><span class="na">builderMessage</span><span class="o">());</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//定义三个日志信息</span>
        <span class="nc">String</span> <span class="n">msg1</span> <span class="o">=</span> <span class="s">"Hello"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">msg2</span> <span class="o">=</span> <span class="s">"World"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">msg3</span> <span class="o">=</span> <span class="s">"Java"</span><span class="o">;</span>

        <span class="c1">//调用showLog方法,参数MessageBuilder是一个函数式接口,所以可以传递Lambda表达式</span>
        <span class="cm">/*showLog(2,()-&gt;{
            //返回一个拼接好的字符串
            return  msg1+msg2+msg3;
        });*/</span>

        <span class="cm">/*
            使用Lambda表达式作为参数传递,仅仅是把参数传递到showLog方法中
            只有满足条件,日志的等级是1级
                才会调用接口MessageBuilder中的方法builderMessage
                才会进行字符串的拼接
            如果条件不满足,日志的等级不是1级
                那么MessageBuilder接口中的方法builderMessage也不会执行
                所以拼接字符串的代码也不会执行
            所以不会存在性能的浪费
         */</span>
        <span class="n">showLog</span><span class="o">(</span><span class="mi">1</span><span class="o">,()-&gt;{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"不满足条件不执行"</span><span class="o">);</span>
            <span class="c1">//返回一个拼接好的字符串</span>
            <span class="k">return</span>  <span class="n">msg1</span><span class="o">+</span><span class="n">msg2</span><span class="o">+</span><span class="n">msg3</span><span class="o">;</span>
        <span class="o">});</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@FunctionalInterface</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">MessageBuilder</span> <span class="o">{</span>
    <span class="c1">//定义一个拼接消息的抽象方法,返回被拼接的消息</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="nc">String</span> <span class="nf">builderMessage</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div> <h3 id="证明lambda的延迟">证明Lambda的延迟</h3> <p>下面的代码可以通过结果进行验证：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo03LoggerDelay</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">log</span><span class="o">(</span><span class="kt">int</span> <span class="n">level</span><span class="o">,</span> <span class="nc">MessageBuilder</span> <span class="n">builder</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">level</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
           <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">builder</span><span class="o">.</span><span class="na">buildMessage</span><span class="o">());</span>  
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">String</span> <span class="n">msgA</span> <span class="o">=</span> <span class="s">"Hello"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">msgB</span> <span class="o">=</span> <span class="s">"World"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">msgC</span> <span class="o">=</span> <span class="s">"Java"</span><span class="o">;</span>
        <span class="n">log</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="o">()</span> <span class="err">‐</span><span class="o">&gt;</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Lambda执行！"</span><span class="o">);</span>
            <span class="k">return</span> <span class="n">msgA</span> <span class="o">+</span> <span class="n">msgB</span> <span class="o">+</span> <span class="n">msgC</span><span class="o">;</span>
        <span class="o">});</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>从结果中可以看出，在不符合级别要求的情况下, Lambda将不会执行。从而达到节省性能的效果。</p> <blockquote> <p>扩展：实际上使用内部类也可以达到同样的效果，只是将代码操作延迟到了另外一个对象当中通过调用方法来完成。而是否调用其所在方法是在条件判断之后才执行的。</p> </blockquote> <h2 id="22-使用lambda作为参数和返回值">2.2 使用Lambda作为参数和返回值</h2> <p>如果抛开实现原理不说，Java中的Lambda表达式可以被当作是匿名内部类的替代品。如果方法的参数是一个函数式接口类型，那么就可以使用Lambda表达式进行替代。使用Lambda表达式作为方法参数，其实就是使用函数式接口作为方法参数。</p> <p>例如 <code class="language-plaintext highlighter-rouge">java.lang.Runnable</code> 接口就是一个函数式接口，假设有一个 <code class="language-plaintext highlighter-rouge">startThread</code> 方法使用该接口作为参数，那么就 可以使用Lambda进行传参。这种情况其实和 <code class="language-plaintext highlighter-rouge">Thread</code> 类的构造方法参数为 <code class="language-plaintext highlighter-rouge">Runnable</code> 没有本质区别。</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo04Runnable</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">startThread</span><span class="o">(</span><span class="nc">Runnable</span> <span class="n">task</span><span class="o">)</span> <span class="o">{</span>
       <span class="k">new</span> <span class="nf">Thread</span><span class="o">(</span><span class="n">task</span><span class="o">).</span><span class="na">start</span><span class="o">();</span>  
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
       <span class="n">startThread</span><span class="o">(()</span> <span class="err">‐</span><span class="o">&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"线程任务执行！"</span><span class="o">));</span>  
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>类似地，如果一个方法的返回值类型是一个函数式接口，那么就可以直接返回一个Lambda表达式。当需要通过一个方法来获取一个 <code class="language-plaintext highlighter-rouge">java.util.Comparator</code> 接口类型的对象作为排序器时,就可以调该方法获取。</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Comparator</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo06Comparator</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">Comparator</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="nf">newComparator</span><span class="o">()</span> <span class="o">{</span>
       <span class="k">return</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="err">‐</span><span class="o">&gt;</span> <span class="n">b</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="err">‐</span> <span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>  
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">array</span> <span class="o">=</span> <span class="o">{</span> <span class="s">"abc"</span><span class="o">,</span> <span class="s">"ab"</span><span class="o">,</span> <span class="s">"abcd"</span> <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">array</span><span class="o">));</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">array</span><span class="o">,</span> <span class="n">newComparator</span><span class="o">());</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">array</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>其中直接return一个Lambda表达式即可。</p> <h1 id="第三章-常用函数式接口">第三章 常用函数式接口</h1> <p>JDK提供了大量常用的函数式接口以丰富Lambda的典型使用场景，它们主要在 java.util.function 包中被提供。</p> <p>下面是最简单的几个接口及使用示例。</p> <h2 id="31-supplier接口">3.1 Supplier接口</h2> <p><code class="language-plaintext highlighter-rouge">java.util.function.Supplier&lt;T&gt;</code> 接口仅包含一个无参的方法： <code class="language-plaintext highlighter-rouge">T get()</code> 。用来获取一个泛型参数指定类型的对 象数据。由于这是一个函数式接口，这也就意味着对应的Lambda表达式需要“对外提供”一个符合泛型类型的对象 数据。</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.function.Supplier</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo08Supplier</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">getString</span><span class="o">(</span><span class="nc">Supplier</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">function</span><span class="o">)</span> <span class="o">{</span>
       <span class="k">return</span> <span class="n">function</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>  
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">String</span> <span class="n">msgA</span> <span class="o">=</span> <span class="s">"Hello"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">msgB</span> <span class="o">=</span> <span class="s">"World"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">getString</span><span class="o">(()</span> <span class="err">‐</span><span class="o">&gt;</span> <span class="n">msgA</span> <span class="o">+</span> <span class="n">msgB</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h2 id="32-练习求数组元素最大值">3.2 练习：求数组元素最大值</h2> <h3 id="题目">题目</h3> <p>使用 <code class="language-plaintext highlighter-rouge">Supplier</code> 接口作为方法参数类型，通过Lambda表达式求出int数组中的最大值。提示：接口的泛型请使用<code class="language-plaintext highlighter-rouge">java.lang.Integer</code> 类。</p> <h3 id="解答">解答</h3> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo02Test</span> <span class="o">{</span>
    <span class="c1">//定一个方法,方法的参数传递Supplier,泛型使用Integer</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">getMax</span><span class="o">(</span><span class="nc">Supplier</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">sup</span><span class="o">){</span>
        <span class="k">return</span> <span class="n">sup</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">arr</span><span class="o">[]</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">52</span><span class="o">,</span><span class="mi">333</span><span class="o">,</span><span class="mi">23</span><span class="o">};</span>
        <span class="c1">//调用getMax方法,参数传递Lambda</span>
        <span class="kt">int</span> <span class="n">maxNum</span> <span class="o">=</span> <span class="n">getMax</span><span class="o">(()</span><span class="err">‐</span><span class="o">&gt;{</span>
           <span class="c1">//计算数组的最大值</span>
           <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
           <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">:</span> <span class="n">arr</span><span class="o">){</span>
               <span class="k">if</span><span class="o">(</span><span class="n">i</span><span class="o">&gt;</span><span class="n">max</span><span class="o">){</span>
                   <span class="n">max</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
               <span class="o">}</span>
           <span class="o">}</span>
           <span class="k">return</span> <span class="n">max</span><span class="o">;</span>
        <span class="o">});</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">maxNum</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h2 id="33-consumer接口">3.3 Consumer接口</h2> <p><code class="language-plaintext highlighter-rouge">java.util.function.Consumer&lt;T&gt;</code> 接口则正好与Supplier接口相反，它不是生产一个数据，而是消费一个数据，其数据类型由泛型决定。</p> <h3 id="抽象方法accept">抽象方法：accept</h3> <p><code class="language-plaintext highlighter-rouge">Consumer</code> 接口中包含抽象方法 <code class="language-plaintext highlighter-rouge">void accept(T t)</code> ，意为消费一个指定泛型的数据。基本使用如：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.function.Consumer</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo09Consumer</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">consumeString</span><span class="o">(</span><span class="nc">Consumer</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">function</span><span class="o">)</span> <span class="o">{</span>
       <span class="n">function</span><span class="o">.</span><span class="na">accept</span><span class="o">(</span><span class="s">"Hello"</span><span class="o">);</span>  
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">consumeString</span><span class="o">(</span><span class="n">s</span> <span class="err">‐</span><span class="o">&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>当然，更好的写法是使用方法引用。</p> <h3 id="默认方法andthen">默认方法：andThen</h3> <p>如果一个方法的参数和返回值全都是 <code class="language-plaintext highlighter-rouge">Consumer</code> 类型，那么就可以实现效果：消费数据的时候，首先做一个操作，然后再做一个操作，实现组合。而这个方法就是 <code class="language-plaintext highlighter-rouge">Consumer</code> 接口中的default方法 <code class="language-plaintext highlighter-rouge">andThen</code> 。下面是JDK的源代码：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">default</span> <span class="nc">Consumer</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">andThen</span><span class="o">(</span><span class="nc">Consumer</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">T</span><span class="o">&gt;</span> <span class="n">after</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Objects</span><span class="o">.</span><span class="na">requireNonNull</span><span class="o">(</span><span class="n">after</span><span class="o">);</span>
    <span class="k">return</span> <span class="o">(</span><span class="no">T</span> <span class="n">t</span><span class="o">)</span> <span class="err">‐</span><span class="o">&gt;</span> <span class="o">{</span> <span class="n">accept</span><span class="o">(</span><span class="n">t</span><span class="o">);</span> <span class="n">after</span><span class="o">.</span><span class="na">accept</span><span class="o">(</span><span class="n">t</span><span class="o">);</span> <span class="o">};</span>
<span class="o">}</span>
</code></pre></div></div> <blockquote> <p>备注： <code class="language-plaintext highlighter-rouge">java.util.Objects</code> 的 <code class="language-plaintext highlighter-rouge">requireNonNull</code> 静态方法将会在参数为null时主动抛出 <code class="language-plaintext highlighter-rouge">NullPointerException</code> 异常。这省去了重复编写if语句和抛出空指针异常的麻烦。</p> </blockquote> <p>要想实现组合，需要两个或多个Lambda表达式即可，而 andThen 的语义正是“一步接一步”操作。例如两个步骤组合的情况：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.function.Consumer</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo10ConsumerAndThen</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">consumeString</span><span class="o">(</span><span class="nc">Consumer</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">one</span><span class="o">,</span> <span class="nc">Consumer</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">two</span><span class="o">)</span> <span class="o">{</span>
       <span class="n">one</span><span class="o">.</span><span class="na">andThen</span><span class="o">(</span><span class="n">two</span><span class="o">).</span><span class="na">accept</span><span class="o">(</span><span class="s">"Hello"</span><span class="o">);</span>  
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">consumeString</span><span class="o">(</span>
            <span class="n">s</span> <span class="err">‐</span><span class="o">&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">toUpperCase</span><span class="o">()),</span>
            <span class="n">s</span> <span class="err">‐</span><span class="o">&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">toLowerCase</span><span class="o">()));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>运行结果将会首先打印完全大写的HELLO，然后打印完全小写的hello。当然，通过链式写法可以实现更多步骤的组合。</p> <h2 id="34-练习格式化打印信息">3.4 练习：格式化打印信息</h2> <h3 id="题目-1">题目</h3> <p>下面的字符串数组当中存有多条信息，请按照格式“ <code class="language-plaintext highlighter-rouge">姓名：XX。性别：XX。</code> ”的格式将信息打印出来。要求将打印姓名的动作作为第一个 <code class="language-plaintext highlighter-rouge">Consumer</code> 接口的Lambda实例，将打印性别的动作作为第二个 <code class="language-plaintext highlighter-rouge">Consumer</code> 接口的Lambda实例，将两个 <code class="language-plaintext highlighter-rouge">Consumer</code> 接口按照顺序“拼接”到一起。</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
   <span class="nc">String</span><span class="o">[]</span> <span class="n">array</span> <span class="o">=</span> <span class="o">{</span> <span class="s">"迪丽热巴,女"</span><span class="o">,</span> <span class="s">"古力娜扎,女"</span><span class="o">,</span> <span class="s">"马尔扎哈,男"</span> <span class="o">};</span>  
<span class="o">}</span>
</code></pre></div></div> <h3 id="解答-1">解答</h3> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.function.Consumer</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DemoConsumer</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">array</span> <span class="o">=</span> <span class="o">{</span> <span class="s">"迪丽热巴,女"</span><span class="o">,</span> <span class="s">"古力娜扎,女"</span><span class="o">,</span> <span class="s">"马尔扎哈,男"</span> <span class="o">};</span>
        <span class="n">printInfo</span><span class="o">(</span><span class="n">s</span> <span class="err">‐</span><span class="o">&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"姓名："</span> <span class="o">+</span> <span class="n">s</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">","</span><span class="o">)[</span><span class="mi">0</span><span class="o">]),</span>
                  <span class="n">s</span> <span class="err">‐</span><span class="o">&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"。性别："</span> <span class="o">+</span> <span class="n">s</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">","</span><span class="o">)[</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="s">"。"</span><span class="o">),</span>
                  <span class="n">array</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">printInfo</span><span class="o">(</span><span class="nc">Consumer</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">one</span><span class="o">,</span> <span class="nc">Consumer</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">two</span><span class="o">,</span> <span class="nc">String</span><span class="o">[]</span> <span class="n">array</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">info</span> <span class="o">:</span> <span class="n">array</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">one</span><span class="o">.</span><span class="na">andThen</span><span class="o">(</span><span class="n">two</span><span class="o">).</span><span class="na">accept</span><span class="o">(</span><span class="n">info</span><span class="o">);</span> <span class="c1">// 姓名：迪丽热巴。性别：女。</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h2 id="35-predicate接口">3.5 Predicate接口</h2> <p>有时候我们需要对某种类型的数据进行判断，从而得到一个boolean值结果。这时可以使用 <code class="language-plaintext highlighter-rouge">java.util.function.Predicate&lt;T&gt;</code> 接口。</p> <h3 id="抽象方法test">抽象方法：test</h3> <p><code class="language-plaintext highlighter-rouge">Predicate</code> 接口中包含一个抽象方法： <code class="language-plaintext highlighter-rouge">boolean test(T t)</code> 。用于条件判断的场景：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.function.Predicate</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo15PredicateTest</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">method</span><span class="o">(</span><span class="nc">Predicate</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">predicate</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">boolean</span> <span class="n">veryLong</span> <span class="o">=</span> <span class="n">predicate</span><span class="o">.</span><span class="na">test</span><span class="o">(</span><span class="s">"HelloWorld"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"字符串很长吗："</span> <span class="o">+</span> <span class="n">veryLong</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">method</span><span class="o">(</span><span class="n">s</span> <span class="err">‐</span><span class="o">&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>条件判断的标准是传入的Lambda表达式逻辑，只要字符串长度大于5则认为很长。</p> <h3 id="默认方法and">默认方法：and</h3> <p>既然是条件判断，就会存在与、或、非三种常见的逻辑关系。其中将两个Predicate 条件使用“与”逻辑连接起来实现“<strong>并且</strong>”的效果时，可以使用default方法 and 。其JDK源码为：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">default</span> <span class="nc">Predicate</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">and</span><span class="o">(</span><span class="nc">Predicate</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">T</span><span class="o">&gt;</span> <span class="n">other</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Objects</span><span class="o">.</span><span class="na">requireNonNull</span><span class="o">(</span><span class="n">other</span><span class="o">);</span>
    <span class="k">return</span> <span class="o">(</span><span class="n">t</span><span class="o">)</span> <span class="err">‐</span><span class="o">&gt;</span> <span class="n">test</span><span class="o">(</span><span class="n">t</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">other</span><span class="o">.</span><span class="na">test</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div> <p>如果要判断一个字符串既要包含大写“H”，又要包含大写“W”，那么：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.function.Predicate</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo16PredicateAnd</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">method</span><span class="o">(</span><span class="nc">Predicate</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">one</span><span class="o">,</span> <span class="nc">Predicate</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">two</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">boolean</span> <span class="n">isValid</span> <span class="o">=</span> <span class="n">one</span><span class="o">.</span><span class="na">and</span><span class="o">(</span><span class="n">two</span><span class="o">).</span><span class="na">test</span><span class="o">(</span><span class="s">"Helloworld"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"字符串符合要求吗："</span> <span class="o">+</span> <span class="n">isValid</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">method</span><span class="o">(</span><span class="n">s</span> <span class="err">‐</span><span class="o">&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="s">"H"</span><span class="o">),</span> <span class="n">s</span> <span class="err">‐</span><span class="o">&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="s">"W"</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h3 id="默认方法or">默认方法：or</h3> <p>与 <code class="language-plaintext highlighter-rouge">and</code> 的“与”类似，默认方法 <code class="language-plaintext highlighter-rouge">or</code> 实现逻辑关系中的“或”。JDK源码为：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">default</span> <span class="nc">Predicate</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">or</span><span class="o">(</span><span class="nc">Predicate</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">T</span><span class="o">&gt;</span> <span class="n">other</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Objects</span><span class="o">.</span><span class="na">requireNonNull</span><span class="o">(</span><span class="n">other</span><span class="o">);</span>
    <span class="k">return</span> <span class="o">(</span><span class="n">t</span><span class="o">)</span> <span class="err">‐</span><span class="o">&gt;</span> <span class="n">test</span><span class="o">(</span><span class="n">t</span><span class="o">)</span> <span class="o">||</span> <span class="n">other</span><span class="o">.</span><span class="na">test</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div> <p>如果希望实现逻辑“字符串包含大写H或者包含大写W”，那么代码只需要将“and”修改为“or”名称即可，其他都不变：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.function.Predicate</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo16PredicateAnd</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">method</span><span class="o">(</span><span class="nc">Predicate</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">one</span><span class="o">,</span> <span class="nc">Predicate</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">two</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">boolean</span> <span class="n">isValid</span> <span class="o">=</span> <span class="n">one</span><span class="o">.</span><span class="na">or</span><span class="o">(</span><span class="n">two</span><span class="o">).</span><span class="na">test</span><span class="o">(</span><span class="s">"Helloworld"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"字符串符合要求吗："</span> <span class="o">+</span> <span class="n">isValid</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">method</span><span class="o">(</span><span class="n">s</span> <span class="err">‐</span><span class="o">&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="s">"H"</span><span class="o">),</span> <span class="n">s</span> <span class="err">‐</span><span class="o">&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="s">"W"</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h3 id="默认方法negate">默认方法：negate</h3> <p>“与”、“或”已经了解了，剩下的“非”（取反）也会简单。默认方法 negate 的JDK源代码为：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">default</span> <span class="nc">Predicate</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">negate</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="o">(</span><span class="n">t</span><span class="o">)</span> <span class="err">‐</span><span class="o">&gt;</span> <span class="o">!</span><span class="n">test</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div> <p>从实现中很容易看出，它是执行了test方法之后，对结果boolean值进行“!”取反而已。一定要在 <code class="language-plaintext highlighter-rouge">test</code> 方法调用之前调用 <code class="language-plaintext highlighter-rouge">negate</code> 方法，正如 <code class="language-plaintext highlighter-rouge">and</code> 和 <code class="language-plaintext highlighter-rouge">or</code> 方法一样：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.function.Predicate</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo17PredicateNegate</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">method</span><span class="o">(</span><span class="nc">Predicate</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">predicate</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">boolean</span> <span class="n">veryLong</span> <span class="o">=</span> <span class="n">predicate</span><span class="o">.</span><span class="na">negate</span><span class="o">().</span><span class="na">test</span><span class="o">(</span><span class="s">"HelloWorld"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"字符串很长吗："</span> <span class="o">+</span> <span class="n">veryLong</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
       <span class="n">method</span><span class="o">(</span><span class="n">s</span> <span class="err">‐</span><span class="o">&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="o">);</span>  
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h2 id="36-练习集合信息筛选">3.6 练习：集合信息筛选</h2> <h3 id="题目-2">题目</h3> <p>数组当中有多条“姓名+性别”的信息如下，请通过 <code class="language-plaintext highlighter-rouge">Predicate</code> 接口的拼装将符合要求的字符串筛选到集合<code class="language-plaintext highlighter-rouge">ArrayList</code> 中，需要同时满足两个条件：</p> <ol> <li>必须为女生；</li> <li>姓名为4个字。</li> </ol> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DemoPredicate</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
       <span class="nc">String</span><span class="o">[]</span> <span class="n">array</span> <span class="o">=</span> <span class="o">{</span> <span class="s">"迪丽热巴,女"</span><span class="o">,</span> <span class="s">"古力娜扎,女"</span><span class="o">,</span> <span class="s">"马尔扎哈,男"</span><span class="o">,</span> <span class="s">"赵丽颖,女"</span> <span class="o">};</span>  
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h3 id="解答-2">解答</h3> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.function.Predicate</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DemoPredicate</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">array</span> <span class="o">=</span> <span class="o">{</span> <span class="s">"迪丽热巴,女"</span><span class="o">,</span> <span class="s">"古力娜扎,女"</span><span class="o">,</span> <span class="s">"马尔扎哈,男"</span><span class="o">,</span> <span class="s">"赵丽颖,女"</span> <span class="o">};</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="n">filter</span><span class="o">(</span><span class="n">array</span><span class="o">,</span>
                                   <span class="n">s</span> <span class="err">‐</span><span class="o">&gt;</span> <span class="s">"女"</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">","</span><span class="o">)[</span><span class="mi">1</span><span class="o">]),</span>
                                   <span class="n">s</span> <span class="err">‐</span><span class="o">&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">","</span><span class="o">)[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">()</span> <span class="o">==</span> <span class="mi">4</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">list</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="nf">filter</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">array</span><span class="o">,</span> <span class="nc">Predicate</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">one</span><span class="o">,</span>
                                       <span class="nc">Predicate</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">two</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">info</span> <span class="o">:</span> <span class="n">array</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">one</span><span class="o">.</span><span class="na">and</span><span class="o">(</span><span class="n">two</span><span class="o">).</span><span class="na">test</span><span class="o">(</span><span class="n">info</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">info</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">list</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h2 id="37-function接口">3.7 Function接口</h2> <p><code class="language-plaintext highlighter-rouge">java.util.function.Function&lt;T,R&gt;</code> 接口用来根据一个类型的数据得到另一个类型的数据，前者称为前置条件，后者称为后置条件。</p> <h3 id="抽象方法apply">抽象方法：apply</h3> <p><code class="language-plaintext highlighter-rouge">Function</code> 接口中最主要的抽象方法为： <code class="language-plaintext highlighter-rouge">R apply(T t)</code> ，根据类型T的参数获取类型R的结果。使用的场景例如：将 <code class="language-plaintext highlighter-rouge">String</code> 类型转换为 <code class="language-plaintext highlighter-rouge">Integer</code> 类型。</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.function.Function</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo11FunctionApply</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">method</span><span class="o">(</span><span class="nc">Function</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">function</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="n">function</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="s">"10"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">num</span> <span class="o">+</span> <span class="mi">20</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">method</span><span class="o">(</span><span class="n">s</span> <span class="err">‐</span><span class="o">&gt;</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">s</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>当然，最好是通过方法引用的写法。</p> <h3 id="默认方法andthen-1">默认方法：andThen</h3> <p><code class="language-plaintext highlighter-rouge">Function</code> 接口中有一个默认的 <code class="language-plaintext highlighter-rouge">andThen</code> 方法，用来进行组合操作。JDK源代码如：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">default</span> <span class="o">&lt;</span><span class="no">V</span><span class="o">&gt;</span> <span class="nc">Function</span><span class="o">&lt;</span><span class="no">T</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="nf">andThen</span><span class="o">(</span><span class="nc">Function</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">R</span><span class="o">,</span> <span class="o">?</span> <span class="kd">extends</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">after</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Objects</span><span class="o">.</span><span class="na">requireNonNull</span><span class="o">(</span><span class="n">after</span><span class="o">);</span>
    <span class="k">return</span> <span class="o">(</span><span class="no">T</span> <span class="n">t</span><span class="o">)</span> <span class="err">‐</span><span class="o">&gt;</span> <span class="n">after</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">apply</span><span class="o">(</span><span class="n">t</span><span class="o">));</span>
<span class="o">}</span>
</code></pre></div></div> <p>该方法同样用于“先做什么，再做什么”的场景，和 <code class="language-plaintext highlighter-rouge">Consumer</code> 中的 <code class="language-plaintext highlighter-rouge">andThen</code> 差不多：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.function.Function</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo12FunctionAndThen</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">method</span><span class="o">(</span><span class="nc">Function</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">one</span><span class="o">,</span> <span class="nc">Function</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">two</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="n">one</span><span class="o">.</span><span class="na">andThen</span><span class="o">(</span><span class="n">two</span><span class="o">).</span><span class="na">apply</span><span class="o">(</span><span class="s">"10"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">num</span> <span class="o">+</span> <span class="mi">20</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">method</span><span class="o">(</span><span class="n">str</span><span class="err">‐</span><span class="o">&gt;</span><span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">str</span><span class="o">)+</span><span class="mi">10</span><span class="o">,</span> <span class="n">i</span> <span class="err">‐</span><span class="o">&gt;</span> <span class="n">i</span> <span class="o">*=</span> <span class="mi">10</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>第一个操作是将字符串解析成为int数字，第二个操作是乘以10。两个操作通过 <code class="language-plaintext highlighter-rouge">andThen</code> 按照前后顺序组合到了一起。</p> <blockquote> <p>请注意，Function的前置条件泛型和后置条件泛型可以相同。</p> </blockquote> <h2 id="38-练习自定义函数模型拼接">3.8 练习：自定义函数模型拼接</h2> <h3 id="题目-3">题目</h3> <p>请使用 <code class="language-plaintext highlighter-rouge">Function</code> 进行函数模型的拼接，按照顺序需要执行的多个函数操作为： String str = “赵丽颖,20”;</p> <ol> <li>将字符串截取数字年龄部分，得到字符串；</li> <li>将上一步的字符串转换成为int类型的数字；</li> <li>将上一步的int数字累加100，得到结果int数字。</li> </ol> <h3 id="解答-3">解答</h3> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.function.Function</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DemoFunction</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">String</span> <span class="n">str</span> <span class="o">=</span> <span class="s">"赵丽颖,20"</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">age</span> <span class="o">=</span> <span class="n">getAgeNum</span><span class="o">(</span><span class="n">str</span><span class="o">,</span> <span class="n">s</span> <span class="err">‐</span><span class="o">&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">","</span><span class="o">)[</span><span class="mi">1</span><span class="o">],</span>
                            <span class="n">s</span> <span class="err">‐</span><span class="o">&gt;</span><span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">s</span><span class="o">),</span>
                            <span class="n">n</span> <span class="err">‐</span><span class="o">&gt;</span> <span class="n">n</span> <span class="o">+=</span> <span class="mi">100</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">age</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">getAgeNum</span><span class="o">(</span><span class="nc">String</span> <span class="n">str</span><span class="o">,</span> <span class="nc">Function</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">one</span><span class="o">,</span>
                                 <span class="nc">Function</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">two</span><span class="o">,</span>
                                 <span class="nc">Function</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">three</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">one</span><span class="o">.</span><span class="na">andThen</span><span class="o">(</span><span class="n">two</span><span class="o">).</span><span class="na">andThen</span><span class="o">(</span><span class="n">three</span><span class="o">).</span><span class="na">apply</span><span class="o">(</span><span class="n">str</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h1 id="第四章-stream流">第四章 Stream流</h1> <p>说到Stream便容易想到I/O Stream，而实际上，谁规定“流”就一定是“IO流”呢？在Java 8中，得益于Lambda所带来的函数式编程，引入了一个<strong>全新的Stream概念</strong>，用于解决已有集合类库既有的弊端。</p> <h2 id="41-引言">4.1 引言</h2> <h3 id="传统集合的多步遍历代码">传统集合的多步遍历代码</h3> <p>几乎所有的集合（如 <code class="language-plaintext highlighter-rouge">Collection</code> 接口或 <code class="language-plaintext highlighter-rouge">Map</code> 接口等）都支持直接或间接的遍历操作。而当我们需要对集合中的元素进行操作的时候，除了必需的添加、删除、获取外，最典型的就是集合遍历。例如：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo01ForEach</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"张无忌"</span><span class="o">);</span>
        <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"周芷若"</span><span class="o">);</span>
        <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"赵敏"</span><span class="o">);</span>
        <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"张强"</span><span class="o">);</span>
        <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"张三丰"</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">name</span> <span class="o">:</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
           <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>  
        <span class="o">}</span>
    <span class="o">}</span> 
<span class="o">}</span>
</code></pre></div></div> <p>这是一段非常简单的集合遍历操作：对集合中的每一个字符串都进行打印输出操作。</p> <h3 id="循环遍历的弊端">循环遍历的弊端</h3> <p>Java 8的Lambda让我们可以更加专注于<strong>做什么</strong>（What），而不是<strong>怎么做</strong>（How），这点此前已经结合内部类进行了对比说明。现在，我们仔细体会一下上例代码，可以发现：</p> <ul> <li>for循环的语法就是“怎么做”</li> <li>for循环的循环体才是“做什么”</li> </ul> <p>为什么使用循环？因为要进行遍历。但循环是遍历的唯一方式吗？遍历是指每一个元素逐一进行处理，<strong>而并不是从第一个到最后一个顺次处理的循环</strong>。前者是目的，后者是方式。</p> <p>试想一下，如果希望对集合中的元素进行筛选过滤：</p> <ol> <li>将集合A根据条件一过滤为子集B；</li> <li>然后再根据条件二过滤为子集C。</li> </ol> <p>那怎么办？在Java 8之前的做法可能为：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo02NormalFilter</span> <span class="o">{</span>
   <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>  
       <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>  
        <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"张无忌"</span><span class="o">);</span>
        <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"周芷若"</span><span class="o">);</span>
        <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"赵敏"</span><span class="o">);</span>
        <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"张强"</span><span class="o">);</span>
        <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"张三丰"</span><span class="o">);</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">zhangList</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">name</span> <span class="o">:</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">name</span><span class="o">.</span><span class="na">startsWith</span><span class="o">(</span><span class="s">"张"</span><span class="o">))</span> <span class="o">{</span>
               <span class="n">zhangList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>  
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">shortList</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">name</span> <span class="o">:</span> <span class="n">zhangList</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">name</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">==</span> <span class="mi">3</span><span class="o">)</span> <span class="o">{</span>
               <span class="n">shortList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>  
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">name</span> <span class="o">:</span> <span class="n">shortList</span><span class="o">)</span> <span class="o">{</span>
           <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>  
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>这段代码中含有三个循环，每一个作用不同：</p> <ol> <li>首先筛选所有姓张的人；</li> <li>然后筛选名字有三个字的人；</li> <li>最后进行对结果进行打印输出。</li> </ol> <p>每当我们需要对集合中的元素进行操作的时候，总是需要进行循环、循环、再循环。这是理所当然的么？<strong>不是</strong>。循环是做事情的方式，而不是目的。另一方面，使用线性循环就意味着只能遍历一次。如果希望再次遍历，只能再使用另一个循环从头开始。</p> <p>那，Lambda的衍生物Stream能给我们带来怎样更加优雅的写法呢？</p> <h3 id="stream的更优写法">Stream的更优写法</h3> <p>下面来看一下借助Java 8的Stream API，什么才叫优雅：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo03StreamFilter</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"张无忌"</span><span class="o">);</span>
        <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"周芷若"</span><span class="o">);</span>
        <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"赵敏"</span><span class="o">);</span>
        <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"张强"</span><span class="o">);</span>
        <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"张三丰"</span><span class="o">);</span>
        <span class="n">list</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
           <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">s</span> <span class="err">‐</span><span class="o">&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">startsWith</span><span class="o">(</span><span class="s">"张"</span><span class="o">))</span>  
            <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">s</span> <span class="err">‐</span><span class="o">&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">==</span> <span class="mi">3</span><span class="o">)</span>
            <span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>直接阅读代码的字面意思即可完美展示无关逻辑方式的语义：<strong>获取流、过滤姓张、过滤长度为3、逐一打印。</strong> 代码中并没有体现使用线性循环或是其他任何算法进行遍历，我们真正要做的事情内容被更好地体现在代码中。</p> <h2 id="42-流式思想概述">4.2 流式思想概述</h2> <p><strong>注意：请暂时忘记对传统IO流的固有印象！</strong> <img src="https://blog.slienceme.cn/images/posts/20210129095838181.png" alt="Alt Text" /> 当需要对多个元素进行操作（特别是多步操作）的时候，考虑到性能及便利性，我们应该首先拼好一个“模型”步骤方案，然后再按照方案去执行它。</p> <p><a href="https://img-blog.csdnimg.cn/20210129095838181.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NsaWVuY2VfbWU=,size_16,color_FFFFFF,t_70">在这里插入图片描述</a></p> <p>这张图中展示了过滤、映射、跳过、计数等多步操作，这是一种集合元素的处理方案，而方案就是一种“函数模型”。图中的每一个方框都是一个“流”，调用指定的方法，可以从一个流模型转换为另一个流模型。而最右侧的数字3是最终结果。</p> <p>这里的 <code class="language-plaintext highlighter-rouge">filter</code> 、 <code class="language-plaintext highlighter-rouge">map</code> 、 <code class="language-plaintext highlighter-rouge">skip</code> 都是在对函数模型进行操作，集合元素并没有真正被处理。只有当终结方法 <code class="language-plaintext highlighter-rouge">count</code>执行的时候，整个模型才会按照指定策略执行操作。而这得益于Lambda的延迟执行特性。</p> <blockquote> <p>备注：“Stream流”其实是一个集合元素的函数模型，它并不是集合，也不是数据结构，其本身并不存储任何元素（或其地址值）。</p> </blockquote> <p>Stream（流）是一个来自数据源的元素队列</p> <ul> <li>元素是特定类型的对象，形成一个队列。 Java中的Stream并不会存储元素，而是按需计算。</li> <li><strong>数据源</strong> 流的来源。 可以是集合，数组 等。</li> </ul> <p>和以前的Collection操作不同， Stream操作还有两个基础的特征：</p> <ul> <li><strong>Pipelining</strong>: 中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格（fluent style）。这样做可以对操作进行优化， 比如延迟执行(laziness)和短路( short-circuiting)。</li> <li><strong>内部迭代</strong>：以前对集合遍历都是通过Iterator或者增强for的方式, 显式的在集合外部进行迭代， 这叫做外部迭 代。Stream提供了内部迭代的方式，流可以直接调用遍历方法。</li> </ul> <p>当使用一个流的时候，通常包括三个基本步骤：获取一个数据源（source）→ 数据转换→执行操作获取想要的结果，每次转换原有 Stream 对象不改变，返回一个新的 Stream 对象（可以有多次转换），这就允许对其操作可以像链条一样排列，变成一个管道。</p> <h2 id="43-获取流">4.3 获取流</h2> <p><code class="language-plaintext highlighter-rouge">java.util.stream.Stream&lt;T&gt;</code> 是Java 8新加入的最常用的流接口。（这并不是一个函数式接口。） 获取一个流非常简单，有以下几种常用的方式：</p> <ul> <li>所有的 <code class="language-plaintext highlighter-rouge">Collection</code> 集合都可以通过 <code class="language-plaintext highlighter-rouge">stream</code> 默认方法获取流；</li> <li><code class="language-plaintext highlighter-rouge">Stream</code> 接口的静态方法 <code class="language-plaintext highlighter-rouge">of</code> 可以获取数组对应的流。</li> </ul> <h3 id="根据collection获取流">根据Collection获取流</h3> <p>首先， <code class="language-plaintext highlighter-rouge">java.util.Collection</code> 接口中加入了default方法 <code class="language-plaintext highlighter-rouge">stream</code> 用来获取流，所以其所有实现类均可获取流。</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.stream.Stream</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo04GetStream</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="c1">// ...</span>
        <span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">stream1</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">stream</span><span class="o">();</span>
        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
        <span class="c1">// ...</span>
        <span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">stream2</span> <span class="o">=</span> <span class="n">set</span><span class="o">.</span><span class="na">stream</span><span class="o">();</span>
        <span class="nc">Vector</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">vector</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Vector</span><span class="o">&lt;&gt;();</span>
        <span class="c1">// ...</span>
         <span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">stream3</span> <span class="o">=</span> <span class="n">vector</span><span class="o">.</span><span class="na">stream</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h3 id="根据map获取流">根据Map获取流</h3> <p><code class="language-plaintext highlighter-rouge">java.util.Map</code> 接口不是 <code class="language-plaintext highlighter-rouge">Collection</code> 的子接口，且其K-V数据结构不符合流元素的单一特征，所以获取对应的流需要分key、value或entry等情况：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.HashMap</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Map</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.stream.Stream</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo05GetStream</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="c1">// ...</span>
        <span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">keyStream</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">keySet</span><span class="o">().</span><span class="na">stream</span><span class="o">();</span>
        <span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">valueStream</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">values</span><span class="o">().</span><span class="na">stream</span><span class="o">();</span>
        <span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="n">entryStream</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">entrySet</span><span class="o">().</span><span class="na">stream</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h3 id="根据数组获取流">根据数组获取流</h3> <p>如果使用的不是集合或映射而是数组，由于数组对象不可能添加默认方法，所以 <code class="language-plaintext highlighter-rouge">Stream</code> 接口中提供了静态方法<code class="language-plaintext highlighter-rouge">of</code> ，使用很简单：</p> <blockquote> <p>备注： <code class="language-plaintext highlighter-rouge">of</code> 方法的参数其实是一个可变参数，所以支持数组。</p> </blockquote> <h2 id="44-常用方法">4.4 常用方法</h2> <p><a href="https://img-blog.csdnimg.cn/20210129095838181.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NsaWVuY2VfbWU=,size_16,color_FFFFFF,t_70">在这里插入图片描述</a></p> <p>流模型的操作很丰富，这里介绍一些常用的API。这些方法可以被分成两种：</p> <ul> <li><strong>延迟方法</strong>：返回值类型仍然是 Stream 接口自身类型的方法，因此支持链式调用。（除了终结方法外，其余方 法均为延迟方法。）</li> <li><strong>终结方法</strong>：返回值类型不再是 Stream 接口自身类型的方法，因此不再支持类似 StringBuilder 那样的链式调用。本小节中，终结方法包括 count 和 forEach 方法。</li> </ul> <blockquote> <p>备注：本小节之外的更多方法，请自行参考API文档。</p> </blockquote> <h3 id="逐一处理foreach">逐一处理：forEach</h3> <p>虽然方法名字叫 <code class="language-plaintext highlighter-rouge">forEach</code> ，但是与for循环中的“for-each”昵称不同。</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">forEach</span><span class="o">(</span><span class="nc">Consumer</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">T</span><span class="o">&gt;</span> <span class="n">action</span><span class="o">);</span>
</code></pre></div></div> <p>该方法接收一个 <code class="language-plaintext highlighter-rouge">Consumer</code> 接口函数，会将每一个流元素交给该函数进行处理。</p> <h3 id="复习consumer接口">复习Consumer接口</h3> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">java</span><span class="o">.</span><span class="na">util</span><span class="o">.</span><span class="na">function</span><span class="o">.</span><span class="na">Consumer</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span><span class="n">接口是一个消费型接口</span><span class="err">。</span>
<span class="nc">Consumer接口中包含抽象方法void</span> <span class="n">accept</span><span class="o">(</span><span class="no">T</span> <span class="n">t</span><span class="o">)</span><span class="err">，</span><span class="n">意为消费一个指定泛型的数据</span><span class="err">。</span>
</code></pre></div></div> <h3 id="基本使用">基本使用：</h3> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.stream.Stream</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo12StreamForEach</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">stream</span> <span class="o">=</span> <span class="nc">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"张无忌"</span><span class="o">,</span> <span class="s">"张三丰"</span><span class="o">,</span> <span class="s">"周芷若"</span><span class="o">);</span>
        <span class="n">stream</span><span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="n">name</span><span class="err">‐</span><span class="o">&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">name</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h3 id="过滤filter">过滤：filter</h3> <p>可以通过 <code class="language-plaintext highlighter-rouge">filter</code> 方法将一个流转换成另一个子集流。方法签名：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Stream</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">filter</span><span class="o">(</span><span class="nc">Predicate</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">T</span><span class="o">&gt;</span> <span class="n">predicate</span><span class="o">);</span>
</code></pre></div></div> <p>该接口接收一个 <code class="language-plaintext highlighter-rouge">Predicate</code> 函数式接口参数（可以是一个Lambda或方法引用）作为筛选条件。</p> <p><a href="https://img-blog.csdnimg.cn/20210129095838181.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NsaWVuY2VfbWU=,size_16,color_FFFFFF,t_70">在这里插入图片描述</a></p> <h4 id="复习predicate接口">复习Predicate接口</h4> <p>此前我们已经学习过 java.util.stream.Predicate 函数式接口，其中唯一的抽象方法为：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">boolean</span> <span class="nf">test</span><span class="o">(</span><span class="no">T</span> <span class="n">t</span><span class="o">);</span>
</code></pre></div></div> <p>该方法将会产生一个boolean值结果，代表指定的条件是否满足。如果结果为true，那么Stream流的 <code class="language-plaintext highlighter-rouge">filter</code> 方法将会留用元素；如果结果为false，那么 <code class="language-plaintext highlighter-rouge">filter</code> 方法将会舍弃元素。</p> <h4 id="基本使用-1">基本使用</h4> <p>Stream流中的 <code class="language-plaintext highlighter-rouge">filter</code> 方法基本使用的代码如：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.stream.Stream</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo07StreamFilter</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">original</span> <span class="o">=</span> <span class="nc">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"张无忌"</span><span class="o">,</span> <span class="s">"张三丰"</span><span class="o">,</span> <span class="s">"周芷若"</span><span class="o">);</span>
        <span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">original</span><span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">s</span> <span class="err">‐</span><span class="o">&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">startsWith</span><span class="o">(</span><span class="s">"张"</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>在这里通过Lambda表达式来指定了筛选的条件：必须姓张。</p> <h3 id="映射map">映射：map</h3> <p>如果需要将流中的元素映射到另一个流中，可以使用 <code class="language-plaintext highlighter-rouge">map</code> 方法。方法签名：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="no">R</span><span class="o">&gt;</span> <span class="nc">Stream</span><span class="o">&lt;</span><span class="no">R</span><span class="o">&gt;</span> <span class="nf">map</span><span class="o">(</span><span class="nc">Function</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">T</span><span class="o">,</span> <span class="o">?</span> <span class="kd">extends</span> <span class="no">R</span><span class="o">&gt;</span> <span class="n">mapper</span><span class="o">);</span>
</code></pre></div></div> <p>该接口需要一个 <code class="language-plaintext highlighter-rouge">Function</code> 函数式接口参数，可以将当前流中的T类型数据转换为另一种R类型的流。 <a href="https://img-blog.csdnimg.cn/20210129095838181.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NsaWVuY2VfbWU=,size_16,color_FFFFFF,t_70">在这里插入图片描述</a></p> <h3 id="复习function接口">复习Function接口</h3> <p>此前我们已经学习过 <code class="language-plaintext highlighter-rouge">java.util.stream.Function</code> 函数式接口，其中唯一的抽象方法为：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">R</span> <span class="nf">apply</span><span class="o">(</span><span class="no">T</span> <span class="n">t</span><span class="o">);</span>
</code></pre></div></div> <p>这可以将一种T类型转换成为R类型，而这种转换的动作，就称为“映射”。</p> <h3 id="基本使用-2">基本使用</h3> <p>Stream流中的 <code class="language-plaintext highlighter-rouge">map</code> 方法基本使用的代码如：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.stream.Stream</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo08StreamMap</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">original</span> <span class="o">=</span> <span class="nc">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"10"</span><span class="o">,</span> <span class="s">"12"</span><span class="o">,</span> <span class="s">"18"</span><span class="o">);</span>
        <span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">original</span><span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">str</span><span class="err">‐</span><span class="o">&gt;</span><span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">str</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>这段代码中， <code class="language-plaintext highlighter-rouge">map</code> 方法的参数通过方法引用，将字符串类型转换成为了int类型（并自动装箱为 Integer 类对象）。</p> <h3 id="统计个数count">统计个数：count</h3> <p>正如旧集合 <code class="language-plaintext highlighter-rouge">Collection</code> 当中的 <code class="language-plaintext highlighter-rouge">size</code> 方法一样，流提供 <code class="language-plaintext highlighter-rouge">count</code> 方法来数一数其中的元素个数：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">long</span> <span class="nf">count</span><span class="o">();</span>
</code></pre></div></div> <p>该方法返回一个long值代表元素个数（不再像旧集合那样是int值）。基本使用：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.stream.Stream</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo09StreamCount</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">original</span> <span class="o">=</span> <span class="nc">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"张无忌"</span><span class="o">,</span> <span class="s">"张三丰"</span><span class="o">,</span> <span class="s">"周芷若"</span><span class="o">);</span>
        <span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">original</span><span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">s</span> <span class="err">‐</span><span class="o">&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">startsWith</span><span class="o">(</span><span class="s">"张"</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">result</span><span class="o">.</span><span class="na">count</span><span class="o">());</span> <span class="c1">// 2</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h3 id="取用前几个limit">取用前几个：limit</h3> <p><code class="language-plaintext highlighter-rouge">limit</code> 方法可以对流进行截取，只取用前n个。方法签名：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Stream</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">limit</span><span class="o">(</span><span class="kt">long</span> <span class="n">maxSize</span><span class="o">);</span>
</code></pre></div></div> <p>参数是一个long型，如果集合当前长度大于参数则进行截取；否则不进行操作。基本使用： <a href="https://img-blog.csdnimg.cn/20210129095838181.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NsaWVuY2VfbWU=,size_16,color_FFFFFF,t_70">在这里插入图片描述</a></p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.stream.Stream</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo10StreamLimit</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">original</span> <span class="o">=</span> <span class="nc">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"张无忌"</span><span class="o">,</span> <span class="s">"张三丰"</span><span class="o">,</span> <span class="s">"周芷若"</span><span class="o">);</span>
        <span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">original</span><span class="o">.</span><span class="na">limit</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">result</span><span class="o">.</span><span class="na">count</span><span class="o">());</span> <span class="c1">// 2</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h3 id="跳过前几个skip">跳过前几个：skip</h3> <p>如果希望跳过前几个元素，可以使用 <code class="language-plaintext highlighter-rouge">skip</code> 方法获取一个截取之后的新流：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Stream</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">skip</span><span class="o">(</span><span class="kt">long</span> <span class="n">n</span><span class="o">);</span>
</code></pre></div></div> <p>如果流的当前长度大于n，则跳过前n个；否则将会得到一个长度为0的空流。基本使用：</p> <p><a href="https://img-blog.csdnimg.cn/20210129095838181.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NsaWVuY2VfbWU=,size_16,color_FFFFFF,t_70">在这里插入图片描述</a></p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.stream.Stream</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo11StreamSkip</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">original</span> <span class="o">=</span> <span class="nc">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"张无忌"</span><span class="o">,</span> <span class="s">"张三丰"</span><span class="o">,</span> <span class="s">"周芷若"</span><span class="o">);</span>
        <span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">original</span><span class="o">.</span><span class="na">skip</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">result</span><span class="o">.</span><span class="na">count</span><span class="o">());</span> <span class="c1">// 1</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h3 id="组合concat">组合：concat</h3> <p>如果有两个流，希望合并成为一个流，那么可以使用 <code class="language-plaintext highlighter-rouge">Stream</code> 接口的静态方法 <code class="language-plaintext highlighter-rouge">concat</code> ：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nc">Stream</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">concat</span><span class="o">(</span><span class="nc">Stream</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="no">T</span><span class="o">&gt;</span> <span class="n">a</span><span class="o">,</span> <span class="nc">Stream</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="no">T</span><span class="o">&gt;</span> <span class="n">b</span><span class="o">)</span>
</code></pre></div></div> <blockquote> <p>备注：这是一个静态方法，与 <code class="language-plaintext highlighter-rouge">java.lang.String</code> 当中的 <code class="language-plaintext highlighter-rouge">concat</code> 方法是不同的。</p> </blockquote> <p>该方法的基本使用代码如：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.stream.Stream</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo12StreamConcat</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">streamA</span> <span class="o">=</span> <span class="nc">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"张无忌"</span><span class="o">);</span>
        <span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">streamB</span> <span class="o">=</span> <span class="nc">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"张翠山"</span><span class="o">);</span>
        <span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="nc">Stream</span><span class="o">.</span><span class="na">concat</span><span class="o">(</span><span class="n">streamA</span><span class="o">,</span> <span class="n">streamB</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h2 id="45-练习集合元素处理传统方式">4.5 练习：集合元素处理（传统方式）</h2> <h3 id="题目-4">题目</h3> <p>现在有两个 <code class="language-plaintext highlighter-rouge">ArrayList</code> 集合存储队伍当中的多个成员姓名，要求使用传统的for循环（或增强for循环）<strong>依次</strong>进行以下若干操作步骤：</p> <ol> <li>第一个队伍只要名字为3个字的成员姓名；存储到一个新集合中。</li> <li>第一个队伍筛选之后只要前3个人；存储到一个新集合中。</li> <li>第二个队伍只要姓张的成员姓名；存储到一个新集合中。</li> <li>第二个队伍筛选之后不要前2个人；存储到一个新集合中。</li> <li>将两个队伍合并为一个队伍；存储到一个新集合中。</li> <li>根据姓名创建 Person 对象；存储到一个新集合中。</li> <li>打印整个队伍的Person对象信息。</li> </ol> <p>两个队伍（集合）的代码如下：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DemoArrayListNames</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
       <span class="c1">//第一支队伍</span>
        <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">one</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="n">one</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"迪丽热巴"</span><span class="o">);</span>
        <span class="n">one</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"宋远桥"</span><span class="o">);</span>
        <span class="n">one</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"苏星河"</span><span class="o">);</span>
        <span class="n">one</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"石破天"</span><span class="o">);</span>
        <span class="n">one</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"石中玉"</span><span class="o">);</span>
        <span class="n">one</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"老子"</span><span class="o">);</span>
        <span class="n">one</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"庄子"</span><span class="o">);</span>
        <span class="n">one</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"洪七公"</span><span class="o">);</span>
        <span class="c1">//第二支队伍</span>
        <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">two</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="n">two</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"古力娜扎"</span><span class="o">);</span>
        <span class="n">two</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"张无忌"</span><span class="o">);</span>
        <span class="n">two</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"赵丽颖"</span><span class="o">);</span>
        <span class="n">two</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"张三丰"</span><span class="o">);</span>
        <span class="n">two</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"尼古拉斯赵四"</span><span class="o">);</span>
        <span class="n">two</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"张天爱"</span><span class="o">);</span>
        <span class="n">two</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"张二狗"</span><span class="o">);</span>
<span class="c1">// ....        </span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>而 Person 类的代码为：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
   
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Person</span><span class="o">()</span> <span class="o">{}</span>
    <span class="kd">public</span> <span class="nf">Person</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"Person{name='"</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s">"'}"</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getName</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setName</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h3 id="解答-4">解答</h3> <p>既然使用传统的for循环写法，那么：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DemoArrayListNames</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">one</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="c1">// ...</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">two</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="c1">// ...</span>
        <span class="c1">// 第一个队伍只要名字为3个字的成员姓名；</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">oneA</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">name</span> <span class="o">:</span> <span class="n">one</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">name</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">==</span> <span class="mi">3</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">oneA</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">// 第一个队伍筛选之后只要前3个人；</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">oneB</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">oneB</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">oneA</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
        <span class="o">}</span>
        <span class="c1">// 第二个队伍只要姓张的成员姓名；</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">twoA</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">name</span> <span class="o">:</span> <span class="n">two</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">name</span><span class="o">.</span><span class="na">startsWith</span><span class="o">(</span><span class="s">"张"</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">twoA</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">// 第二个队伍筛选之后不要前2个人；</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">twoB</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">twoA</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">twoB</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">twoA</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
        <span class="o">}</span>
        <span class="c1">// 将两个队伍合并为一个队伍；</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">totalNames</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="n">totalNames</span><span class="o">.</span><span class="na">addAll</span><span class="o">(</span><span class="n">oneB</span><span class="o">);</span>
        <span class="n">totalNames</span><span class="o">.</span><span class="na">addAll</span><span class="o">(</span><span class="n">twoB</span><span class="o">);</span>
        <span class="c1">// 根据姓名创建Person对象；</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Person</span><span class="o">&gt;</span> <span class="n">totalPersonList</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">name</span> <span class="o">:</span> <span class="n">totalNames</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">totalPersonList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="n">name</span><span class="o">));</span>
        <span class="o">}</span>
        <span class="c1">// 打印整个队伍的Person对象信息。</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">Person</span> <span class="n">person</span> <span class="o">:</span> <span class="n">totalPersonList</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">person</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>运行结果为：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Person{name='宋远桥'}
Person{name='苏星河'}
Person{name='石破天'}
Person{name='张天爱'}
Person{name='张二狗'}
</code></pre></div></div> <h2 id="46-练习集合元素处理stream方式">4.6 练习：集合元素处理（Stream方式）</h2> <h3 id="题目-5">题目</h3> <p>将上一题当中的传统for循环写法更换为Stream流式处理方式。两个集合的初始内容不变， <code class="language-plaintext highlighter-rouge">Person</code> 类的定义也不变。</p> <h3 id="解答-5">解答</h3> <p>等效的Stream流式处理代码为：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.stream.Stream</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DemoStreamNames</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">one</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="c1">// ...</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">two</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="c1">// ...</span>
        <span class="c1">// 第一个队伍只要名字为3个字的成员姓名；</span>
        <span class="c1">// 第一个队伍筛选之后只要前3个人；</span>
        <span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">streamOne</span> <span class="o">=</span> <span class="n">one</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">filter</span><span class="o">(</span><span class="n">s</span> <span class="err">‐</span><span class="o">&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">==</span> <span class="mi">3</span><span class="o">).</span><span class="na">limit</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span>
        <span class="c1">// 第二个队伍只要姓张的成员姓名；</span>
        <span class="c1">// 第二个队伍筛选之后不要前2个人；</span>
        <span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">streamTwo</span> <span class="o">=</span> <span class="n">two</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">filter</span><span class="o">(</span><span class="n">s</span> <span class="err">‐</span><span class="o">&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">startsWith</span><span class="o">(</span><span class="s">"张"</span><span class="o">)).</span><span class="na">skip</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
        <span class="c1">// 将两个队伍合并为一个队伍；</span>
        <span class="c1">// 根据姓名创建Person对象；</span>
        <span class="c1">// 打印整个队伍的Person对象信息。</span>
        <span class="nc">Stream</span><span class="o">.</span><span class="na">concat</span><span class="o">(</span><span class="n">streamOne</span><span class="o">,</span> <span class="n">streamTwo</span><span class="o">).</span><span class="na">map</span><span class="o">(</span><span class="nl">Person:</span><span class="o">:</span><span class="k">new</span><span class="o">).</span><span class="na">forEach</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>运行效果完全一样：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Person{name='宋远桥'}
Person{name='苏星河'}
Person{name='石破天'}
Person{name='张天爱'}
Person{name='张二狗'}
</code></pre></div></div> <h1 id="第五章-方法引用">第五章 方法引用</h1> <p>在使用Lambda表达式的时候，我们实际上传递进去的代码就是一种解决方案：拿什么参数做什么操作。那么考虑一种情况：如果我们在Lambda中所指定的操作方案，已经有地方存在相同方案，那是否还有必要再写重复逻辑？</p> <h2 id="51-冗余的lambda场景">5.1 冗余的Lambda场景</h2> <p>来看一个简单的函数式接口以应用Lambda表达式：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@FunctionalInterface</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Printable</span> <span class="o">{</span>
   <span class="kt">void</span> <span class="nf">print</span><span class="o">(</span><span class="nc">String</span> <span class="n">str</span><span class="o">);</span>  
<span class="o">}</span>
</code></pre></div></div> <p>在 <code class="language-plaintext highlighter-rouge">Printable</code> 接口当中唯一的抽象方法 <code class="language-plaintext highlighter-rouge">print</code> 接收一个字符串参数，目的就是为了打印显示它。那么通过Lambda来使用它的代码很简单：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo01PrintSimple</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">printString</span><span class="o">(</span><span class="nc">Printable</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span>
       <span class="n">data</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"Hello, World!"</span><span class="o">);</span>  
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
       <span class="n">printString</span><span class="o">(</span><span class="n">s</span> <span class="err">‐</span><span class="o">&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">));</span>  
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>其中 <code class="language-plaintext highlighter-rouge">printString</code> 方法只管调用 <code class="language-plaintext highlighter-rouge">Printable</code> 接口的 <code class="language-plaintext highlighter-rouge">print</code> 方法，而并不管 print 方法的具体实现逻辑会将字符串打印到什么地方去。而 main 方法通过Lambda表达式指定了函数式接口 <code class="language-plaintext highlighter-rouge">Printable</code> 的具体操作方案为：<strong>拿到String（类型可推导，所以可省略）数据后，在控制台中输出它。</strong></p> <h2 id="52-问题分析">5.2 问题分析</h2> <p>这段代码的问题在于，对字符串进行控制台打印输出的操作方案，明明已经有了现成的实现，那就是 <code class="language-plaintext highlighter-rouge">System.out</code>对象中的 <code class="language-plaintext highlighter-rouge">println(String)</code> 方法。既然Lambda希望做的事情就是调用 <code class="language-plaintext highlighter-rouge">println(String)</code> 方法，那何必自己手动调用呢？</p> <h2 id="53-用方法引用改进代码">5.3 用方法引用改进代码</h2> <p>能否省去Lambda的语法格式（尽管它已经相当简洁）呢？只要“引用”过去就好了：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo02PrintRef</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">printString</span><span class="o">(</span><span class="nc">Printable</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">data</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"Hello, World!"</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
       <span class="n">printString</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>  
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>请注意其中的双冒号 :: 写法，这被称为“<strong>方法引用</strong>”，而双冒号是一种新的语法。</p> <h2 id="54-方法引用符">5.4 方法引用符</h2> <p>双冒号 <code class="language-plaintext highlighter-rouge">::</code> 为引用运算符，而它所在的表达式被称为<strong>方法引用</strong>。如果Lambda要表达的函数方案已经存在于某个方法的实现中，那么则可以通过双冒号来引用该方法作为Lambda的替代者。</p> <h3 id="语义分析">语义分析</h3> <p>例如上例中， <code class="language-plaintext highlighter-rouge">System.out</code> 对象中有一个重载的 <code class="language-plaintext highlighter-rouge">println(String)</code> 方法恰好就是我们所需要的。那么对于<code class="language-plaintext highlighter-rouge">printString</code> 方法的函数式接口参数，对比下面两种写法，完全等效：</p> <ul> <li>Lambda表达式写法： <code class="language-plaintext highlighter-rouge">s -&gt; System.out.println(s);</code></li> <li>方法引用写法： <code class="language-plaintext highlighter-rouge">System.out::println</code></li> </ul> <p>第一种语义是指：拿到参数之后经Lambda之手，，继而传递给 <code class="language-plaintext highlighter-rouge">System.out.println</code> 方法去处理。 第二种等效写法的语义是指：直接让 <code class="language-plaintext highlighter-rouge">System.out</code> 中的 <code class="language-plaintext highlighter-rouge">println</code> 方法来取代Lambda。两种写法的执行效果完全一样，而第二种方法引用的写法复用了已有方案，更加简洁。</p> <p>注:Lambda 中 传递的参数 一定是方法引用中 的那个方法可以接收的类型,否则会抛出异常</p> <h3 id="推导与省略">推导与省略</h3> <h2 id="55-通过对象名引用成员方法">5.5 通过对象名引用成员方法</h2> <p>如果使用Lambda，那么根据“<strong>可推导就是可省略</strong>”的原则，无需指定参数类型，也无需指定的重载形式——它们都将被自动推导。而如果使用方法引用，也是同样可以根据上下文进行推导。</p> <p>函数式接口是Lambda的基础，而方法引用是Lambda的孪生兄弟。</p> <p>下面这段代码将会调用 <code class="language-plaintext highlighter-rouge">println</code> 方法的不同重载形式，将函数式接口改为int类型的参数：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@FunctionalInterface</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">PrintableInteger</span> <span class="o">{</span>
   <span class="kt">void</span> <span class="nf">print</span><span class="o">(</span><span class="kt">int</span> <span class="n">str</span><span class="o">);</span>  
<span class="o">}</span>
</code></pre></div></div> <p>由于上下文变了之后可以自动推导出唯一对应的匹配重载，所以方法引用没有任何变化：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo03PrintOverload</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">printInteger</span><span class="o">(</span><span class="nc">PrintableInteger</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span>
       <span class="n">data</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="mi">1024</span><span class="o">);</span>  
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
       <span class="n">printInteger</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>  
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>这次方法引用将会自动匹配到 <code class="language-plaintext highlighter-rouge">println(int)</code> 的重载形式。</p> <h2 id="55-通过对象名引用成员方法-1">5.5 通过对象名引用成员方法</h2> <p>这是最常见的一种用法，与上例相同。如果一个类中已经存在了一个成员方法：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MethodRefObject</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">printUpperCase</span><span class="o">(</span><span class="nc">String</span> <span class="n">str</span><span class="o">)</span> <span class="o">{</span>
       <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">str</span><span class="o">.</span><span class="na">toUpperCase</span><span class="o">());</span>  
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>函数式接口仍然定义为：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@FunctionalInterface</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Printable</span> <span class="o">{</span>
   <span class="kt">void</span> <span class="nf">print</span><span class="o">(</span><span class="nc">String</span> <span class="n">str</span><span class="o">);</span>  
<span class="o">}</span>
</code></pre></div></div> <p>那么当需要使用这个 <code class="language-plaintext highlighter-rouge">printUpperCase</code> 成员方法来替代 <code class="language-plaintext highlighter-rouge">Printable</code> 接口的Lambda的时候，已经具有了<code class="language-plaintext highlighter-rouge">MethodRefObject</code> 类的对象实例，则可以通过对象名引用成员方法，代码为：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo04MethodRef</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">printString</span><span class="o">(</span><span class="nc">Printable</span> <span class="n">lambda</span><span class="o">)</span> <span class="o">{</span>
       <span class="n">lambda</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"Hello"</span><span class="o">);</span>  
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">MethodRefObject</span> <span class="n">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MethodRefObject</span><span class="o">();</span>
        <span class="n">printString</span><span class="o">(</span><span class="nl">obj:</span><span class="o">:</span><span class="n">printUpperCase</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h2 id="56-通过类名称引用静态方法">5.6 通过类名称引用静态方法</h2> <p>由于在 <code class="language-plaintext highlighter-rouge">java.lang.Math</code> 类中已经存在了静态方法 <code class="language-plaintext highlighter-rouge">abs</code> ，所以当我们需要通过Lambda来调用该方法时，有两种写法。首先是函数式接口：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@FunctionalInterface</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Calcable</span> <span class="o">{</span>
   <span class="kt">int</span> <span class="nf">calc</span><span class="o">(</span><span class="kt">int</span> <span class="n">num</span><span class="o">);</span>  
<span class="o">}</span>
</code></pre></div></div> <p>第一种写法是使用Lambda表达式：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo05Lambda</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">method</span><span class="o">(</span><span class="kt">int</span> <span class="n">num</span><span class="o">,</span> <span class="nc">Calcable</span> <span class="n">lambda</span><span class="o">)</span> <span class="o">{</span>
       <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">lambda</span><span class="o">.</span><span class="na">calc</span><span class="o">(</span><span class="n">num</span><span class="o">));</span>  
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
       <span class="n">method</span><span class="o">(</span><span class="err">‐</span><span class="mi">10</span><span class="o">,</span> <span class="n">n</span> <span class="err">‐</span><span class="o">&gt;</span> <span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">n</span><span class="o">));</span>  
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>但是使用方法引用的更好写法是：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo06MethodRef</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">method</span><span class="o">(</span><span class="kt">int</span> <span class="n">num</span><span class="o">,</span> <span class="nc">Calcable</span> <span class="n">lambda</span><span class="o">)</span> <span class="o">{</span>
       <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">lambda</span><span class="o">.</span><span class="na">calc</span><span class="o">(</span><span class="n">num</span><span class="o">));</span>  
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
       <span class="n">method</span><span class="o">(</span><span class="err">‐</span><span class="mi">10</span><span class="o">,</span> <span class="nl">Math:</span><span class="o">:</span><span class="n">abs</span><span class="o">);</span>  
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>在这个例子中，下面两种写法是等效的：</p> <ul> <li>Lambda表达式： <code class="language-plaintext highlighter-rouge">n -&gt; Math.abs(n)</code></li> <li>方法引用： <code class="language-plaintext highlighter-rouge">Math::abs</code></li> </ul> <h2 id="57-通过super引用成员方法">5.7 通过super引用成员方法</h2> <p>如果存在继承关系，当Lambda中需要出现super调用时，也可以使用方法引用进行替代。首先是函数式接口：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@FunctionalInterface</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Greetable</span> <span class="o">{</span>
   <span class="kt">void</span> <span class="nf">greet</span><span class="o">();</span>  
<span class="o">}</span>
</code></pre></div></div> <p>然后是父类 <code class="language-plaintext highlighter-rouge">Human</code> 的内容：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Human</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">sayHello</span><span class="o">()</span> <span class="o">{</span>
       <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Hello!"</span><span class="o">);</span>  
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>最后是子类 <code class="language-plaintext highlighter-rouge">Man</code> 的内容，其中使用了Lambda的写法：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Man</span> <span class="kd">extends</span> <span class="nc">Human</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">sayHello</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"大家好,我是Man!"</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="c1">//定义方法method,参数传递Greetable接口</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">method</span><span class="o">(</span><span class="nc">Greetable</span> <span class="n">g</span><span class="o">){</span>
        <span class="n">g</span><span class="o">.</span><span class="na">greet</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">show</span><span class="o">(){</span>
        <span class="c1">//调用method方法,使用Lambda表达式</span>
        <span class="n">method</span><span class="o">(()</span><span class="err">‐</span><span class="o">&gt;{</span>
            <span class="c1">//创建Human对象,调用sayHello方法</span>
            <span class="k">new</span> <span class="nf">Human</span><span class="o">().</span><span class="na">sayHello</span><span class="o">();</span>
        <span class="o">});</span>
        <span class="c1">//简化Lambda</span>
        <span class="n">method</span><span class="o">(()</span><span class="err">‐</span><span class="o">&gt;</span><span class="k">new</span> <span class="nc">Human</span><span class="o">().</span><span class="na">sayHello</span><span class="o">());</span>
        <span class="c1">//使用super关键字代替父类对象</span>
        <span class="n">method</span><span class="o">(()</span><span class="err">‐</span><span class="o">&gt;</span><span class="kd">super</span><span class="o">.</span><span class="na">sayHello</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>但是如果使用方法引用来调用父类中的 sayHello 方法会更好，例如另一个子类 <code class="language-plaintext highlighter-rouge">Woman</code> ：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Man</span> <span class="kd">extends</span> <span class="nc">Human</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">sayHello</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"大家好,我是Man!"</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="c1">//定义方法method,参数传递Greetable接口</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">method</span><span class="o">(</span><span class="nc">Greetable</span> <span class="n">g</span><span class="o">){</span>
        <span class="n">g</span><span class="o">.</span><span class="na">greet</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">show</span><span class="o">(){</span>
        <span class="n">method</span><span class="o">(</span><span class="kd">super</span><span class="o">::</span><span class="n">sayHello</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>在这个例子中，下面两种写法是等效的：</p> <ul> <li>Lambda表达式： <code class="language-plaintext highlighter-rouge">() -&gt; super.sayHello()</code></li> <li>方法引用： <code class="language-plaintext highlighter-rouge">super::sayHello</code></li> </ul> <h2 id="58-通过this引用成员方法">5.8 通过this引用成员方法</h2> <p>this代表当前对象，如果需要引用的方法就是当前类中的成员方法，那么可以使用“<strong>this::成员方法</strong>”的格式来使用方法引用。首先是简单的函数式接口：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@FunctionalInterface</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Richable</span> <span class="o">{</span>
   <span class="kt">void</span> <span class="nf">buy</span><span class="o">();</span> 
<span class="o">}</span>
</code></pre></div></div> <p>下面是一个丈夫 <code class="language-plaintext highlighter-rouge">Husband</code> 类：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Husband</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">marry</span><span class="o">(</span><span class="nc">Richable</span> <span class="n">lambda</span><span class="o">)</span> <span class="o">{</span>
       <span class="n">lambda</span><span class="o">.</span><span class="na">buy</span><span class="o">();</span>  
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">beHappy</span><span class="o">()</span> <span class="o">{</span>
       <span class="n">marry</span><span class="o">(()</span> <span class="err">‐</span><span class="o">&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"买套房子"</span><span class="o">));</span>  
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>开心方法 <code class="language-plaintext highlighter-rouge">beHappy</code> 调用了结婚方法 <code class="language-plaintext highlighter-rouge">marry</code> ，后者的参数为函数式接口 <code class="language-plaintext highlighter-rouge">Richable</code> ，所以需要一个Lambda表达式。但是如果这个Lambda表达式的内容已经在本类当中存在了，则可以对 <code class="language-plaintext highlighter-rouge">Husband</code> 丈夫类进行修改:</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Husband</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">buyHouse</span><span class="o">()</span> <span class="o">{</span>
       <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"买套房子"</span><span class="o">);</span>  
    <span class="o">}</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">marry</span><span class="o">(</span><span class="nc">Richable</span> <span class="n">lambda</span><span class="o">)</span> <span class="o">{</span>
       <span class="n">lambda</span><span class="o">.</span><span class="na">buy</span><span class="o">();</span>  
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">beHappy</span><span class="o">()</span> <span class="o">{</span>
       <span class="n">marry</span><span class="o">(()</span> <span class="err">‐</span><span class="o">&gt;</span> <span class="k">this</span><span class="o">.</span><span class="na">buyHouse</span><span class="o">());</span>  
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>如果希望取消掉Lambda表达式，用方法引用进行替换，则更好的写法为：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Husband</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">buyHouse</span><span class="o">()</span> <span class="o">{</span>
       <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"买套房子"</span><span class="o">);</span>  
    <span class="o">}</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">marry</span><span class="o">(</span><span class="nc">Richable</span> <span class="n">lambda</span><span class="o">)</span> <span class="o">{</span>
       <span class="n">lambda</span><span class="o">.</span><span class="na">buy</span><span class="o">();</span>  
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">beHappy</span><span class="o">()</span> <span class="o">{</span>
       <span class="n">marry</span><span class="o">(</span><span class="k">this</span><span class="o">::</span><span class="n">buyHouse</span><span class="o">);</span>  
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>在这个例子中，下面两种写法是等效的：</p> <ul> <li>Lambda表达式： <code class="language-plaintext highlighter-rouge">() -&gt; this.buyHouse()</code></li> <li>方法引用： <code class="language-plaintext highlighter-rouge">this::buyHouse</code></li> </ul> <h2 id="59-类的构造器引用">5.9 类的构造器引用</h2> <p>由于构造器的名称与类名完全一样，并不固定。所以构造器引用使用 类名称<code class="language-plaintext highlighter-rouge">::new</code> 的格式表示。首先是一个简单的 <code class="language-plaintext highlighter-rouge">Person</code> 类：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Person</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getName</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setName</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>然后是用来创建 <code class="language-plaintext highlighter-rouge">Person</code> 对象的函数式接口：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">PersonBuilder</span> <span class="o">{</span>
    <span class="nc">Person</span> <span class="nf">buildPerson</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div> <p>要使用这个函数式接口，可以通过Lambda表达式：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo09Lambda</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">printName</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="nc">PersonBuilder</span> <span class="n">builder</span><span class="o">)</span> <span class="o">{</span>
       <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">builder</span><span class="o">.</span><span class="na">buildPerson</span><span class="o">(</span><span class="n">name</span><span class="o">).</span><span class="na">getName</span><span class="o">());</span>  
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
       <span class="n">printName</span><span class="o">(</span><span class="s">"赵丽颖"</span><span class="o">,</span> <span class="n">name</span> <span class="err">‐</span><span class="o">&gt;</span> <span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="n">name</span><span class="o">));</span>  
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>但是通过构造器引用，有更好的写法：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo10ConstructorRef</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">printName</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="nc">PersonBuilder</span> <span class="n">builder</span><span class="o">)</span> <span class="o">{</span>
       <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">builder</span><span class="o">.</span><span class="na">buildPerson</span><span class="o">(</span><span class="n">name</span><span class="o">).</span><span class="na">getName</span><span class="o">());</span>  
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
       <span class="n">printName</span><span class="o">(</span><span class="s">"赵丽颖"</span><span class="o">,</span> <span class="nl">Person:</span><span class="o">:</span><span class="k">new</span><span class="o">);</span>  
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>在这个例子中，下面两种写法是等效的：</p> <ul> <li>Lambda表达式： <code class="language-plaintext highlighter-rouge">name -&gt; new Person(name)</code></li> <li>方法引用： <code class="language-plaintext highlighter-rouge">Person::new</code></li> </ul> <h2 id="510-数组的构造器引用">5.10 数组的构造器引用</h2> <p>数组也是 <code class="language-plaintext highlighter-rouge">Object</code> 的子类对象，所以同样具有构造器，只是语法稍有不同。如果对应到Lambda的使用场景中时，需要一个函数式接口：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@FunctionalInterface</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">ArrayBuilder</span> <span class="o">{</span>
   <span class="kt">int</span><span class="o">[]</span> <span class="nf">buildArray</span><span class="o">(</span><span class="kt">int</span> <span class="n">length</span><span class="o">);</span>  
<span class="o">}</span>
</code></pre></div></div> <p>在应用该接口的时候，可以通过Lambda表达式：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo11ArrayInitRef</span> <span class="o">{</span>  
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">initArray</span><span class="o">(</span><span class="kt">int</span> <span class="n">length</span><span class="o">,</span> <span class="nc">ArrayBuilder</span> <span class="n">builder</span><span class="o">)</span> <span class="o">{</span>
       <span class="k">return</span> <span class="n">builder</span><span class="o">.</span><span class="na">buildArray</span><span class="o">(</span><span class="n">length</span><span class="o">);</span>  
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
       <span class="kt">int</span><span class="o">[]</span> <span class="n">array</span> <span class="o">=</span> <span class="n">initArray</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="n">length</span> <span class="err">‐</span><span class="o">&gt;</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">length</span><span class="o">]);</span>  
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>但是更好的写法是使用数组的构造器引用：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo12ArrayInitRef</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">initArray</span><span class="o">(</span><span class="kt">int</span> <span class="n">length</span><span class="o">,</span> <span class="nc">ArrayBuilder</span> <span class="n">builder</span><span class="o">)</span> <span class="o">{</span>
       <span class="k">return</span> <span class="n">builder</span><span class="o">.</span><span class="na">buildArray</span><span class="o">(</span><span class="n">length</span><span class="o">);</span>  
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
       <span class="kt">int</span><span class="o">[]</span> <span class="n">array</span> <span class="o">=</span> <span class="n">initArray</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]::</span><span class="k">new</span><span class="o">);</span>  
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>在这个例子中，下面两种写法是等效的：</p> <ul> <li>Lambda表达式： <code class="language-plaintext highlighter-rouge">length -&gt; new int[length]</code></li> <li>方法引用： <code class="language-plaintext highlighter-rouge">int[]::new</code></li> </ul> <div style="margin-top:2em;padding:0 1.5em;border:1px solid #d3d3d3;background-color:#deebf7"> <h3>文档信息</h3> <ul> <li>本文作者：<a href="https://blog.slienceme.cn" target="_blank">slience_me</a></li> <li>本文链接：<a href="https://blog.slienceme.cn/2021/09/16/Java%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7-%E7%AC%AC%E5%85%AD%E9%83%A8%E5%88%86-%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3&Stream%E6%B5%81&%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/" target="_blank">https://blog.slienceme.cn/2021/09/16/Java%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7-%E7%AC%AC%E5%85%AD%E9%83%A8%E5%88%86-%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3&Stream%E6%B5%81&%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/</a></li> <li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank">创意共享3.0许可证</a>）</li> </ul> </div> </article> <div class="share"> <div class="share-component" data-disabled='qq,facebook'></div> </div> <div class="comment"> <script src="https://giscus.app/client.js" data-repo="slience-me/blog-comments" data-repo-id="R_kgDOKr27jA" data-category="Announcements" data-category-id="DIC_kwDOKr27jM4CnWMe" data-mapping="title" data-strict="1" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="light" data-lang="zh-CN" data-loading="lazy" crossorigin="anonymous" async> </script> </div> </div> <div class="column one-fourth"> <h3>Search</h3> <div id="site_search"> <input style="width:96%" type="text" id="search_box" placeholder="Search"> </div> <ul id="search_results" style="font-size:14px;list-style-type:none;padding-top:10px;padding-left:10px;"></ul> <script src="https://blog.slienceme.cn/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: 'https://blog.slienceme.cn/assets/search_data.json?v=1740598837', searchResultTemplate: '<li><a href="{url}" title="{title}">{title}</a></li>', noResultsText: 'No results found', limit: 10, fuzzy: false, exclude: ['Welcome'] }) </script> <h3 class="post-directory-title mobile-hidden">Table of Contents</h3> <div id="post-directory-module" class="mobile-hidden"> <section class="post-directory"> <dl></dl> </section> </div> <script src="https://blog.slienceme.cn/assets/js/jquery.toc.js"></script> </div> </div> </section> <footer class="container"> <div class="site-footer" role="contentinfo"> <div class="copyright left mobile-block"> Copyright@ 2019-2025 slience_me 版权所有&emsp; <img src="/images/logo/logo.png" class="w-full" style="width: 12px;"> <a href="https://beian.mps.gov.cn/#/query/webSearch?code=13102202000626" rel="noreferrer" target="_blank">冀公网安备13102202000626</a>&emsp; <a href="https://beian.miit.gov.cn/#/Integrated/index" target="_blank" rel="noreferrer">津ICP备2024026565号-1</a> <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a> </div> <ul class="site-footer-links right mobile-hidden"> <li> <a href="javascript:window.scrollTo(0,0)" >TOP</a> </li> </ul> <br/> <script defer src="https://vercount.one/js"></script> <div class="mobile-hidden" style="margin-top:8px"> <span id="busuanzi_container_site_pv" style="display:none"> 本站访问量<span id="busuanzi_value_site_pv"></span>次 </span> <span id="busuanzi_container_site_uv" style="display:none"> / 本站访客数<span id="busuanzi_value_site_uv"></span>人 </span> <span id="busuanzi_container_page_pv" style="display:none"> / 本页访问量<span id="busuanzi_value_page_pv"></span>次 / 统计始于2024-12-01 </span> </div> </div> </footer> <div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a> </div> <script src="https://blog.slienceme.cn/assets/vendor/share.js/dist/js/share.min.js"></script> <script src="https://blog.slienceme.cn/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function($) { $('.geopattern').each(function(){ $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script> </body> </html>
