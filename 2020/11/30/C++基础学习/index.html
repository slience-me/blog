<!DOCTYPE html> <html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"> <head> <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /> <title>C语言｜C++基础学习 &mdash; Slience_me的博客</title> <link rel="stylesheet" href="https://blog.slienceme.cn/assets/vendor/primer-css/css/primer.css"> <link rel="stylesheet" href="https://blog.slienceme.cn/assets/css/components/collection.css"> <link rel="stylesheet" href="https://blog.slienceme.cn/assets/css/components/repo-card.css"> <link rel="stylesheet" href="https://blog.slienceme.cn/assets/css/sections/repo-list.css"> <link rel="stylesheet" href="https://blog.slienceme.cn/assets/css/components/boxed-group.css"> <link rel="stylesheet" href="https://blog.slienceme.cn/assets/css/globals/common.css"> <link rel="stylesheet" href="https://blog.slienceme.cn/assets/css/globals/responsive.css"> <link rel="stylesheet" href="https://blog.slienceme.cn/assets/css/posts/index.css"> <link rel="stylesheet" href="https://blog.slienceme.cn/assets/vendor/octicons/octicons/octicons.css"> <link rel="stylesheet" href="https://mazhuang.org/rouge-themes/dist/github.css"> <link rel="stylesheet" href="https://blog.slienceme.cn/assets/vendor/share.js/dist/css/share.min.css"> <link rel="canonical" href="https://blog.slienceme.cn/2020/11/30/C++%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"> <link rel="alternate" type="application/atom+xml" title="Slience_me的博客" href="https://blog.slienceme.cn/feed.xml"> <link rel="shortcut icon" href="https://blog.slienceme.cn/favicon.ico"> <meta property="og:title" content="C语言｜C++基础学习"> <meta name="keywords" content="编程语言, C语言, C++, C"> <meta name="og:keywords" content="编程语言, C语言, C++, C"> <meta name="description" content=""> <meta name="og:description" content=""> <meta property="og:url" content="https://blog.slienceme.cn/2020/11/30/C++%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"> <meta property="og:site_name" content="Slience_me的博客"> <meta property="og:type" content="article"> <meta property="og:locale" content="zh_CN" /> <meta property="article:published_time" content="2020-11-30"> <meta name="google-site-verification" content="2feHjT1GNs1Yi2JQfOtdYx7d048naG_-cMwZaDAopIA" /> <script src="https://blog.slienceme.cn/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="https://blog.slienceme.cn/assets/js/main.js"></script> </head> <body class="" data-mz=""> <header class="site-header"> <div class="container"> <h1><a href="https://blog.slienceme.cn/" title="Slience_me的博客"><span class="octicon octicon-mark-github"></span> Slience_me的博客</a></h1> <button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button> <nav class="site-header-nav" role="navigation"> <a href="https://blog.slienceme.cn/" class="site-header-nav-item" target="" title="首页">首页</a> <a href="https://blog.slienceme.cn/categories/" class="site-header-nav-item" target="" title="分类">分类</a> <a href="https://blog.slienceme.cn/archives/" class="mobile-hidden site-header-nav-item" target="" title="归档">归档</a> <a href="https://blog.slienceme.cn/open-source/" class="mobile-hidden site-header-nav-item" target="" title="开源">开源</a> <a href="https://blog.slienceme.cn/fragments/" class="site-header-nav-item" target="" title="片段">片段</a> <a href="https://blog.slienceme.cn/wiki/" class="site-header-nav-item" target="" title="维基">维基</a> <a href="https://blog.slienceme.cn/links/" class="mobile-hidden site-header-nav-item" target="" title="链接">链接</a> <a href="https://blog.slienceme.cn/about/" class="site-header-nav-item" target="" title="关于">关于</a> <a class="mobile-hidden" href="https://blog.slienceme.cn/feed.xml"><span class="octicon octicon-rss" style="color:orange;"></span></a> </nav> </div> </header> <section class="collection-head small geopattern" data-pattern-id="C语言｜C++基础学习"> <div class="container"> <div class="columns"> <div class="column three-fourths"> <div class="collection-title"> <h1 class="collection-header">C语言｜C++基础学习</h1> <div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2020/11/30 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="https://blog.slienceme.cn/categories/#C语言" title="C语言">C语言</a> </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 42822 字，约 123 分钟 </span> </div> </div> </div> <div class="column one-fourth mobile-hidden"> <div class="collection-title"> </div> </div> </div> </div> </section> <section class="container content"> <div class="columns"> <div class="column three-fourths" > <article class="article-content markdown-body"> <p><img src="https://blog.slienceme.cn/images/posts/logo_slienceme3.png" alt="img" /></p> <p>本文作者： <a href="https://slienceme.cn/">slience_me</a></p> <hr /> <h1 id="c">C++</h1> <h1 id="1-new的操作符">1. new的操作符</h1> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="c1">//1.new的基本语法</span>
<span class="kt">int</span><span class="o">*</span> <span class="nf">fun</span><span class="p">()</span>
<span class="p">{</span>
	 <span class="c1">// 在堆区创建整形数据</span>
	<span class="kt">int</span> <span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">test01</span><span class="p">()</span>
<span class="p">{</span>
	<span class="kt">int</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">fun</span><span class="p">();</span>

	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">p</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">p</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">p</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="c1">//堆区的数据 由程序员管理开辟，程序员管理释放</span>
	<span class="c1">//如果想释放堆区的数据，利用关键字 delete</span>
	<span class="k">delete</span> <span class="n">p</span><span class="p">;</span>
	<span class="c1">//cout &lt;&lt; *p &lt;&lt; endl; 内存已经被释放，再次访问就是非法操作，会报错</span>
<span class="p">}</span>

<span class="c1">//2.在堆区利用new开辟数组</span>
<span class="kt">void</span> <span class="n">test02</span><span class="p">()</span>
<span class="p">{</span>
	<span class="c1">//创建10整形数据的数组，在堆区</span>
	<span class="kt">int</span> <span class="o">*</span> <span class="n">arr</span> <span class="o">=</span>  <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span> <span class="c1">//代表数组有10个元素</span>

	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> 
	<span class="p">{</span>
		<span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">100</span><span class="p">;</span> <span class="c1">//给10个元素赋值 100~109</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="c1">//释放堆区数组</span>
	<span class="c1">//释放数组的时候 要加[]才可以</span>
	<span class="k">delete</span><span class="p">[]</span> <span class="n">arr</span><span class="p">;</span> 
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="c1">//test01();</span>
	<span class="n">test02</span><span class="p">();</span>

	<span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h1 id="2引用">2.引用</h1> <h2 id="21-引用的基本使用">2.1 引用的基本使用</h2> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="c1">//引用基本语法</span>
	<span class="c1">//数据类型 &amp;别名 = 原名</span>

	<span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
	<span class="c1">//创建引用</span>
	<span class="kt">int</span> <span class="o">&amp;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>

	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"a= "</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"b= "</span> <span class="o">&lt;&lt;</span> <span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

	<span class="n">b</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>

	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"a= "</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"b= "</span> <span class="o">&lt;&lt;</span> <span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

	<span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p><img src="https://blog.slienceme.cn/images/posts/20201130190733293.png" alt="Alt Text" /></p> <h2 id="22-引用的注意事项">2.2 引用的注意事项</h2> <p><strong>1、引用必须初始化 int &amp;b; //错误的 2、一旦初始化后，就不可以更改了</strong></p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
	<span class="c1">//1、引用必须初始化</span>
	<span class="c1">//int&amp; b;      //错误的,必须要初始化</span>
	<span class="kt">int</span> <span class="o">&amp;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>

	<span class="c1">//2、一旦初始化后，就不可以更改了</span>
	<span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>

	<span class="n">b</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span> <span class="c1">// 赋值操作，而不是更改引用</span>
	
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"a= "</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"b= "</span> <span class="o">&lt;&lt;</span> <span class="n">b</span><span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"c= "</span> <span class="o">&lt;&lt;</span> <span class="n">c</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

	<span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p><img src="https://blog.slienceme.cn/images/posts/20201130191422869.png" alt="Alt Text" /></p> <h2 id="23-引用做函数参数">2.3 引用做函数参数</h2> <p><strong>作用：函数传参时，可以利用引用的技术让形参修饰实参 优点：可以简化指针修改实参</strong></p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="c1">//交换函数</span>

<span class="c1">//1、值传递</span>
<span class="kt">void</span> <span class="nf">mySwap01</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
	<span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
	<span class="n">b</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//2、地址传递</span>
<span class="kt">void</span> <span class="n">mySwap02</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span><span class="kt">int</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="o">*</span><span class="n">a</span><span class="p">;</span>
	<span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="o">*</span><span class="n">b</span><span class="p">;</span>
	<span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//3、引用传递</span>
<span class="kt">void</span> <span class="n">mySwap03</span><span class="p">(</span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
	<span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
	<span class="n">b</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
	<span class="c1">//mySwap01(a, b);  //值传递，形参不会修饰实参</span>
	<span class="c1">//mySwap02(&amp;a, &amp;b); //地址传递会修饰实参的</span>
	<span class="n">mySwap03</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span> <span class="c1">//引用传递，形参会修饰实参的</span>

	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"a= "</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"b= "</span> <span class="o">&lt;&lt;</span> <span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

	<span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>总结：通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单</strong></p> <h2 id="24-引用做函数返回值">2.4 引用做函数返回值</h2> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

 <span class="c1">//引用做函数的返回值</span>
<span class="c1">//1、不要反悔局部变量的引用</span>
<span class="kt">int</span> <span class="o">&amp;</span> <span class="n">test01</span><span class="p">()</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="c1">//局部变量存放在四区中的 栈区</span>
	<span class="k">return</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//2、函数的调用可以作为左值</span>
<span class="kt">int</span><span class="o">&amp;</span> <span class="n">test02</span><span class="p">()</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="c1">//静态变量存放在全局区，全局区的数据在程序结束后才释放</span>
	<span class="k">return</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="c1">//int&amp; ref = test01();</span>

	<span class="c1">//cout &lt;&lt; "ref=" &lt;&lt; ref &lt;&lt; endl; //第一次结果正确，是因为编译器做了保留</span>
	<span class="c1">//cout &lt;&lt; "ref=" &lt;&lt; ref &lt;&lt; endl;.//第二次结果错误，是因为a的内存已经释放</span>

	<span class="kt">int</span><span class="o">&amp;</span> <span class="n">ref2</span> <span class="o">=</span> <span class="n">test02</span><span class="p">();</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"ref2="</span> <span class="o">&lt;&lt;</span> <span class="n">ref2</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> 
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"ref2="</span> <span class="o">&lt;&lt;</span> <span class="n">ref2</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

	<span class="n">test02</span><span class="p">()</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>  <span class="c1">//如果函数的返回值是引用，这个函数调用可以作为左值</span>

	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"ref2="</span> <span class="o">&lt;&lt;</span> <span class="n">ref2</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"ref2="</span> <span class="o">&lt;&lt;</span> <span class="n">ref2</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

	<span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p><img src="https://blog.slienceme.cn/images/posts/20201130194158312.png" alt="Alt Text" /></p> <h2 id="25-引用的本质">2.5 引用的本质</h2> <p><strong>本质：引用的本质在c++内部实现是一个指针常量。</strong></p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="c1">//发现是引用，转换为 int* const ref= &amp;a;</span>
<span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="o">&amp;</span> <span class="n">ref</span><span class="p">){</span>
	<span class="n">ref</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span> <span class="c1">// ref 是引用，转换为*ref=100</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
	<span class="c1">//自动转换为 int* const ref =&amp;a; 指针常量是指针指向不可改，也说明为什么引用不可以更改</span>
	<span class="kt">int</span><span class="o">&amp;</span> <span class="n">ref</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
	<span class="n">ref</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span><span class="c1">//内部发现ref是引用，自动帮我们转换为：*ref =20；</span>

	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"a="</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"ref="</span> <span class="o">&lt;&lt;</span> <span class="n">ref</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

	<span class="n">func</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>

	<span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><img src="https://blog.slienceme.cn/images/posts/20201130195004595.png" alt="Alt Text" /> <strong>C++推荐引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮助我们做了</strong></p> <h2 id="26-常量引用">2.6 常量引用</h2> <p><strong>作用：常量引用主要用来修饰形参，防止误操作 在函数列表中，可以加const修饰形参，防止形参改变实参</strong></p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="c1">//打印数据函数，通常用来修饰形参</span>
<span class="kt">void</span> <span class="nf">showValue</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="c1">//val = 1000;不可以修改</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"val="</span> <span class="o">&lt;&lt;</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="c1">//常量引用</span>
	<span class="c1">//使用场景：用来修饰形参，防止误操作</span>

	<span class="c1">//int a = 10;</span>

	<span class="c1">//加上const之后 编译器将代码修改 int temp =10；const int &amp; ref =temp;</span>
	<span class="c1">//const int &amp; ref = 10; //引用必须引一块合法的内存空间</span>
	<span class="c1">//ref = 20; //加入const之后变为只读，不可以修改</span>
	
	<span class="c1">//函数中利用常量引用防止误触操作修改实参</span>
	<span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
	<span class="n">showValue</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
	
	<span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
	
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h1 id="3-函数提高">3. 函数提高</h1> <h2 id="31-函数默认参数">3.1 函数默认参数</h2> <p><strong>在C++中，函数的形参列表中的形参是可以有默认值的。 语法：返回值类型……函数名…（参数=默认值）{}</strong></p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="c1">//函数默认参数</span>
<span class="c1">//如果自己传入，用自己的，没有就用默认值</span>
<span class="c1">//语法： 返回值类型 函数名 （形参 = 默认值）{}</span>
<span class="kt">int</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span><span class="mi">30</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//注意事项</span>
<span class="c1">//1、如果某个位置已经有了默认参数，那么从这个位置往后，从左到右都必须有默认值</span>

<span class="c1">//int fun2(int a, int b = 20, int c )</span>
<span class="c1">//{</span>
<span class="c1">//	return a + b + c;</span>
<span class="c1">//}</span>
<span class="c1">//2、如果函数声明有默认参数，函数实现就不能有默认值</span>
<span class="kt">int</span> <span class="n">func2</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">10</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">func2</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">func2</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">30</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="32-函数占位参数">3.2 函数占位参数</h2> <p>**C++中函数的形参列表里可以由占位参数，用来做占位，调用函数时必须填补该位置</p> <p>语法：返回值类型 函数名 （数据类型）{} 现阶段函数的占位参数存在意义不大，但是后面的课程会用到该技术**</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="c1">//占位参数</span>
<span class="c1">//返回值类型 函数名 （数据类型）{}</span>

<span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"this is func"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> 
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">func</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>


	<span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="33-函数重载">3.3 函数重载</h2> <p><strong>1.概述</strong></p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="c1">//函数重载</span>
<span class="c1">//可以让函数名相同，提高复用性</span>

<span class="c1">//函数重载的满足条件</span>
<span class="c1">//1、同一个作用域下</span>
<span class="c1">//2、函数名称相同</span>
<span class="c1">//3、函数参数类型不同，或者个数不同，或者顺序不同</span>
<span class="kt">void</span> <span class="nf">func</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"func 的调用"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"func(int a) 的调用"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">func</span><span class="p">(</span><span class="kt">double</span> <span class="n">a</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"func(double a) 的调用"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">double</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"func(int a, double b) 的调用"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">func</span><span class="p">(</span><span class="kt">double</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"func(double a, int b) 的调用"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//注意事项</span>
<span class="c1">//函数的返回值不可以作为函数重载的条件</span>
<span class="c1">//错误</span>
<span class="c1">//int func(double a, int b)</span>
<span class="c1">//{</span>
<span class="c1">//	cout &lt;&lt; "func(double a, int b) 的调用" &lt;&lt; endl;</span>
<span class="c1">//}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="cm">/*func();
	func(10);
	func(3.14);
	func(10, 3.14);
	func(3.14, 10);*/</span>

	<span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>2.函数重载注意事项</strong></p> <ul> <li>引用作为重载条件</li> <li>函数重载碰到函数默认参数 ```cpp #include<iostream> using namespace std;</iostream></li> </ul> <p>//函数重载注意事项</p> <p>//1、引用作为重载的条件 void func(int&amp; a) //int &amp;a =10; 不合法 { cout « “fun()调用” « endl; } void func(const int&amp; a)//const int &amp;a =10; { cout « “fun(const int&amp; a)调用” « endl; } //2、函数重载碰到默认参数 void func2(int a , int b=10) //函数重载二义性 { cout « “func2(int a , int b) 的调用” « endl; } void func2(int a) { cout « “func2(int a) 的调用” « endl; }</p> <p>int main() { //int a = 10; //func(a); 调用无const</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//func(10);调用有const
//func2(10); //当函数重载碰到默认参数，出现二义性，报错，尽量避免这种情况
system("pause");
return 0; } ```
</code></pre></div></div> <h1 id="4-类和对象">4. 类和对象</h1> <h2 id="41-封装">4.1 封装</h2> <p><strong>4.1.1封装的意义</strong> 封装是C++面向对象三大特性之一 封装的意义：</p> <ul> <li>将属性和行为作为一个整体，表现生活中的事物</li> <li>将属性和行为加以权限控制</li> <li><strong>封装意义一：</strong> 在设计类的时候，属性和行为在一起，表现事物</li> </ul> <p>语法 class 类名{ 访问权限： 属性 / 行为 }；</p> <p>示例1：设计一个圆类，求周长</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">double</span> <span class="n">PI</span> <span class="o">=</span> <span class="mf">3.14</span><span class="p">;</span>  
<span class="c1">//设计一个圆类，求圆的周长</span>
<span class="c1">//圆求周长的公式：2 * PI * 半径</span>
<span class="k">class</span> <span class="nc">Circle</span>
<span class="p">{</span>
	<span class="c1">//访问权限</span>
	<span class="c1">//公共权限</span>
<span class="nl">public:</span>
	<span class="c1">//属性</span>
	<span class="kt">int</span> <span class="n">m_r</span><span class="p">;</span>
	<span class="c1">//行为</span>
	<span class="c1">//获取圆的周长</span>
	<span class="kt">double</span> <span class="n">calculateZC</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">PI</span> <span class="o">*</span> <span class="n">m_r</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">};</span>
<span class="n">Circle</span><span class="o">::</span><span class="n">Circle</span><span class="p">()</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="n">Circle</span><span class="o">::~</span><span class="n">Circle</span><span class="p">()</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> 
<span class="p">{</span>
	<span class="c1">//通过圆类 创建一个具体的圆(对象)</span>
	<span class="n">Circle</span> <span class="n">c1</span><span class="p">;</span>
	<span class="c1">//给圆对象 的属性进行赋值</span>
	<span class="n">c1</span><span class="p">.</span><span class="n">m_r</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"圆的周长为： "</span> <span class="o">&lt;&lt;</span> <span class="n">c1</span><span class="p">.</span><span class="n">calculateZC</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>示例2：设计一个学生类，属性有姓名和学号，可以给姓名和学号赋值，可以显示学生的姓名和学号</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="cp">#include</span><span class="cpf">&lt;string&gt;</span><span class="cp">
</span><span class="c1">//学生类</span>
<span class="k">class</span> <span class="nc">Student</span>
<span class="p">{</span>
<span class="nl">public:</span> <span class="c1">//公共权限</span>


	<span class="c1">//类中的属性和行为 我们统称为 成员</span>
	<span class="c1">//属性 成员属性 成员变量</span>
	<span class="c1">//行为 成员函数 成员方法</span>
	

	<span class="c1">//属性</span>
	<span class="n">string</span> <span class="n">m_Name</span><span class="p">;</span> <span class="c1">//姓名</span>
	<span class="kt">int</span> <span class="n">m_Id</span><span class="p">;</span><span class="c1">//学号</span>

	<span class="c1">//行为</span>
	<span class="c1">//显示姓名和学号</span>
	<span class="kt">void</span> <span class="n">showStudent</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"姓名："</span> <span class="o">&lt;&lt;</span> <span class="n">m_Name</span> <span class="o">&lt;&lt;</span><span class="s">"  "</span><span class="o">&lt;&lt;</span> <span class="s">"学号："</span> <span class="o">&lt;&lt;</span> <span class="n">m_Id</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="c1">//给姓名赋值</span>
	<span class="kt">void</span> <span class="n">setName</span><span class="p">(</span><span class="n">string</span> <span class="n">name</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">m_Name</span> <span class="o">=</span> <span class="n">name</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="c1">//给学号赋值</span>
	<span class="kt">void</span> <span class="n">setId</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">m_Id</span> <span class="o">=</span> <span class="n">id</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> 
<span class="p">{</span>
	<span class="c1">//创建一个具体的学生 实例化对象</span>
	<span class="n">Student</span> <span class="n">s1</span><span class="p">;</span>
	<span class="c1">//给s1对象 进行属性赋值操作</span>
	<span class="cm">/*s1.m_Name = "张三";*/</span>
	<span class="n">s1</span><span class="p">.</span><span class="n">setName</span><span class="p">(</span><span class="s">"张三"</span><span class="p">);</span>
	<span class="c1">//s1.m_Id = 1;</span>
	<span class="n">s1</span><span class="p">.</span><span class="n">setId</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="c1">//显示学生信息</span>
	<span class="n">s1</span><span class="p">.</span><span class="n">showStudent</span><span class="p">();</span>


	<span class="n">Student</span> <span class="n">s2</span><span class="p">;</span>
	<span class="c1">//给s1对象 进行属性赋值操作</span>
	<span class="n">s2</span><span class="p">.</span><span class="n">m_Name</span> <span class="o">=</span> <span class="s">"李四"</span><span class="p">;</span>
	<span class="n">s2</span><span class="p">.</span><span class="n">m_Id</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="c1">//显示学生信息</span>
	<span class="n">s2</span><span class="p">.</span><span class="n">showStudent</span><span class="p">();</span>

	
	<span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>封装的意义二：</strong> 类在设计时，可以把属性和行为放在不同的权限下，加以控制 访问权限有三种：</p> <ul> <li>1.public 公共权限</li> <li>2.protected 保护权限</li> <li>3.private 私有权限</li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="cp">#include</span><span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="c1">//访问权限</span>
<span class="c1">//三种</span>
<span class="c1">//公共权限 public        成员  类内可以访问  类外也可以访问</span>
<span class="c1">//保护权限 protected  成员  类内可以访问   类外不可以访问  儿子可以访问父亲中的保护内容</span>
<span class="c1">//私有权限 private		  成员  类内可以访问   类外不可以访问  儿子不可以访问父亲的私有内容</span>
<span class="k">class</span> <span class="nc">Person</span>
<span class="p">{</span>
	
<span class="nl">public:</span>
	<span class="c1">//公共权限</span>
	<span class="n">string</span> <span class="n">m_Name</span><span class="p">;</span>  <span class="c1">//姓名</span>
<span class="nl">protected:</span> 

	<span class="c1">//保护权限</span>
	<span class="n">string</span> <span class="n">m_Car</span><span class="p">;</span> <span class="c1">//汽车</span>
<span class="nl">private:</span>
	<span class="c1">//私有权限</span>
	<span class="kt">int</span> <span class="n">m_Password</span><span class="p">;</span> <span class="c1">//银行卡密码</span>
<span class="nl">public:</span>
	<span class="kt">void</span> <span class="n">func</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">m_Name</span> <span class="o">=</span> <span class="s">"张三"</span><span class="p">;</span>
		<span class="n">m_Car</span> <span class="o">=</span> <span class="s">"拖拉机"</span><span class="p">;</span>
		<span class="n">m_Password</span> <span class="o">=</span> <span class="mi">123456</span> <span class="p">;</span>
	<span class="p">}</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> 
<span class="p">{</span>
	<span class="c1">//实例化具体对象</span>
	<span class="n">Person</span> <span class="n">p1</span><span class="p">;</span>
	<span class="n">p1</span><span class="p">.</span><span class="n">m_Name</span> <span class="o">=</span> <span class="s">"李四"</span><span class="p">;</span>
	<span class="c1">//p1.m_Car = "奔驰";  //保护权限内容，在类外访问不到</span>
	<span class="c1">//p1.m_Password = 123; //私有权限内容，类外访问不到</span>
	<span class="n">p1</span><span class="p">.</span><span class="n">func</span><span class="p">();</span>
	<span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>4.1.2 struct和class区别</strong></p> <p>在c++中struct和class唯一的区别就在于 默认的访问权限不同</p> <p>区别：</p> <ul> <li>struct 默认权限为共有</li> <li>class默认权限为私有</li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="cp">#include</span><span class="cpf">&lt;string&gt;</span><span class="cp">
</span><span class="k">class</span> <span class="nc">C1</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">m_A</span><span class="p">;</span> <span class="c1">//默认权限  是私有</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="nc">C2</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">m_A</span><span class="p">;</span> <span class="c1">//默认权限  是公有</span>

<span class="p">};</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> 
<span class="p">{</span>
	<span class="c1">//struct 和 class 区别</span>
	<span class="c1">//struct 默认权限是 公共 public</span>
	<span class="c1">//class   默认权限是 私有 private</span>
	<span class="n">C1</span> <span class="n">c1</span><span class="p">;</span>
	<span class="cm">/*c1.m_A = 100;   */</span> <span class="c1">//在class默认的权限为私有，因此类外不可以访问</span>
	<span class="n">C2</span> <span class="n">c2</span><span class="p">;</span>
	<span class="n">c2</span><span class="p">.</span><span class="n">m_A</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>  <span class="c1">//在struct默认的权限为公有，因此可以访问</span>
	<span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>4.1.3 成员属性设置为私有</strong></p> <p>优点1： 将所有成员属性设置为私有，可以自己控制读写权限 优点2：对于写权限，我们可以检测数据的有效性</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="cp">#include</span><span class="cpf">&lt;string&gt;</span><span class="cp">
</span><span class="c1">//成员属性设置为私有</span>
<span class="c1">//1： 可以自己控制读写权限</span>
<span class="c1">//2：对于写可以检测数据的有效性</span>

<span class="c1">//设计人类</span>
<span class="k">class</span> <span class="nc">Person</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="c1">//设置姓名</span>
	<span class="kt">void</span> <span class="n">setName</span><span class="p">(</span><span class="n">string</span> <span class="n">name</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">m_Name</span> <span class="o">=</span> <span class="n">name</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="c1">//获取姓名</span>
	<span class="n">string</span> <span class="n">getName</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">m_Name</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="c1">// 获取年龄  只读</span>
	<span class="kt">int</span> <span class="n">getAge</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="c1">//m_Age = 0; //初始化为0岁</span>
		<span class="k">return</span> <span class="n">m_Age</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="kt">void</span> <span class="n">setAge</span><span class="p">(</span><span class="kt">int</span> <span class="n">age</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">age</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">age</span><span class="o">&gt;</span><span class="mi">150</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">m_Age</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"你这个老妖精！"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">m_Age</span> <span class="o">=</span> <span class="n">age</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="c1">//设置情人  只写</span>
	<span class="kt">void</span> <span class="n">setLover</span><span class="p">(</span><span class="n">string</span> <span class="n">lover</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">m_Lover</span> <span class="o">=</span> <span class="n">lover</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">private:</span>
	<span class="c1">//姓名   可读可写</span>
	<span class="n">string</span> <span class="n">m_Name</span><span class="p">;</span>
	<span class="c1">//年龄   只读</span>
	<span class="kt">int</span> <span class="n">m_Age</span><span class="p">;</span>
	<span class="c1">//情人   只写</span>
	<span class="n">string</span> <span class="n">m_Lover</span><span class="p">;</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> 
<span class="p">{</span>
	<span class="n">Person</span> <span class="n">p</span><span class="p">;</span>
	<span class="n">p</span><span class="p">.</span><span class="n">setName</span><span class="p">(</span><span class="s">"张三"</span><span class="p">);</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"姓名为："</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="p">.</span><span class="n">getName</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="cm">/*p.m_Age = 18;
	p.setAge();*/</span>
	<span class="n">p</span><span class="p">.</span><span class="n">setAge</span> <span class="p">(</span><span class="mi">18</span><span class="p">);</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"年龄为："</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="p">.</span><span class="n">getAge</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="c1">//设置情人为仓井女士</span>
	<span class="n">p</span><span class="p">.</span><span class="n">setLover</span><span class="p">(</span><span class="s">"苍井"</span><span class="p">);</span>
	<span class="c1">//cout &lt;&lt; "情人为：" &lt;&lt; p.m_Lover &lt;&lt; endl;</span>
	<span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>练习案列1：设计立方体类</strong> 设计立方体类（Cube） 求出立方体的面积和体积 分别用全局函数和成员函数判断两个立方体是否相等。</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Cube</span> <span class="p">{</span>

<span class="nl">public:</span>
	<span class="c1">//设置长</span>
	<span class="kt">void</span> <span class="n">setL</span><span class="p">(</span><span class="kt">int</span> <span class="n">l</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">m_L</span> <span class="o">=</span> <span class="n">l</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="c1">//获取长</span>
	<span class="kt">int</span> <span class="n">getL</span><span class="p">(){</span>
		<span class="k">return</span> <span class="n">m_L</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="c1">//设置宽</span>
	<span class="kt">void</span> <span class="n">setW</span><span class="p">(</span><span class="kt">int</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">m_W</span> <span class="o">=</span> <span class="n">m</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="c1">//获取宽</span>
	<span class="kt">int</span> <span class="n">getW</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">m_W</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="c1">//设置高</span>
	<span class="kt">void</span> <span class="n">setH</span><span class="p">(</span><span class="kt">int</span> <span class="n">h</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">m_H</span> <span class="o">=</span> <span class="n">h</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="c1">//获取高</span>
	<span class="kt">int</span> <span class="n">getH</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">m_H</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="c1">//获取立方体面积</span>
	<span class="kt">int</span> <span class="n">calculateS</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">m_L</span> <span class="o">*</span> <span class="n">m_W</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">m_W</span> <span class="o">*</span> <span class="n">m_H</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">m_L</span><span class="o">*</span><span class="n">m_H</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="c1">//获取立方体体积</span>
	<span class="kt">int</span> <span class="n">calculateV</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">m_L</span> <span class="o">*</span> <span class="n">m_H</span> <span class="o">*</span> <span class="n">m_W</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="c1">// 利用成员函数判断是否相等</span>
	<span class="kt">bool</span> <span class="n">isSameByClass</span><span class="p">(</span><span class="n">Cube</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">m_L</span> <span class="o">==</span> <span class="n">c</span><span class="p">.</span><span class="n">getL</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">m_W</span> <span class="o">==</span> <span class="n">c</span><span class="p">.</span><span class="n">getW</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">m_H</span> <span class="o">==</span> <span class="n">c</span><span class="p">.</span><span class="n">getH</span><span class="p">())</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">private:</span>
	<span class="kt">int</span> <span class="n">m_L</span><span class="p">;</span><span class="c1">// 长</span>
	<span class="kt">int</span> <span class="n">m_W</span><span class="p">;</span><span class="c1">//宽</span>
	<span class="kt">int</span> <span class="n">m_H</span><span class="p">;</span><span class="c1">//高</span>
<span class="p">};</span>

<span class="c1">//利用全局函数判断 两个立方体是否相等</span>
<span class="kt">bool</span> <span class="n">isSame</span><span class="p">(</span><span class="n">Cube</span> <span class="o">&amp;</span><span class="n">c1</span><span class="p">,</span> <span class="n">Cube</span> <span class="o">&amp;</span><span class="n">c2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c1</span><span class="p">.</span><span class="n">getL</span><span class="p">()</span> <span class="o">==</span> <span class="n">c2</span><span class="p">.</span><span class="n">getL</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">c1</span><span class="p">.</span><span class="n">getW</span><span class="p">()</span> <span class="o">==</span> <span class="n">c2</span><span class="p">.</span><span class="n">getW</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">c1</span><span class="p">.</span><span class="n">getH</span><span class="p">()</span> <span class="o">==</span> <span class="n">c2</span><span class="p">.</span><span class="n">getH</span><span class="p">())</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">//创立立方体对象</span>
	<span class="n">Cube</span> <span class="n">c1</span><span class="p">;</span>
	<span class="n">c1</span><span class="p">.</span><span class="n">setL</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="n">c1</span><span class="p">.</span><span class="n">setW</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="n">c1</span><span class="p">.</span><span class="n">setH</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

	<span class="c1">//创建第二个立方体</span>
	<span class="n">Cube</span> <span class="n">c2</span><span class="p">;</span>
	<span class="n">c2</span><span class="p">.</span><span class="n">setL</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="n">c2</span><span class="p">.</span><span class="n">setW</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="n">c2</span><span class="p">.</span><span class="n">setH</span><span class="p">(</span><span class="mi">11</span><span class="p">);</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"c1的面积为："</span> <span class="o">&lt;&lt;</span> <span class="n">c1</span><span class="p">.</span><span class="n">calculateS</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"c1的体积为："</span> <span class="o">&lt;&lt;</span> <span class="n">c1</span><span class="p">.</span><span class="n">calculateV</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

	<span class="c1">//利用全局函数判断</span>
	<span class="kt">bool</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">isSame</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"c1 和 c2 是相等的"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span>
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"c1和c2是不相等的"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="c1">//利用成员函数判断</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">c1</span><span class="p">.</span><span class="n">isSameByClass</span><span class="p">(</span><span class="n">c2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"成员函数判断:c1 和 c2 是相等的"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span>
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"成员函数判断:c1和c2是不相等的"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="42-对象的初始化和清理">4.2 对象的初始化和清理</h2> <p><strong>4.2.1 构造函数和析构函数</strong></p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="c1">//默认构造函数</span>
	<span class="n">Person</span><span class="p">();</span>
	<span class="c1">//有参数构造函数</span>
	<span class="n">Person</span><span class="p">(</span><span class="kt">int</span> <span class="n">age</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">m_Age</span> <span class="o">=</span> <span class="n">age</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="c1">//拷贝构造函数</span>
	<span class="n">Person</span><span class="p">(</span><span class="k">const</span> <span class="n">Person</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">m_Age</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">m_Age</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">~</span><span class="n">Person</span><span class="p">();</span>
</code></pre></div></div> <p><strong>4.2.2 对象的分类及调用</strong></p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//1.1括号法（常用）</span>
<span class="n">Person</span> <span class="nf">p1</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="c1">//注意调用无参数构造函数不能加括号，如果加了编译器会认为这是一个函数声明</span>
<span class="c1">//Person p2();</span>

<span class="c1">//1.2显示法</span>
<span class="n">Person</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">Person</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="n">Person</span> <span class="n">p3</span> <span class="o">=</span> <span class="n">Person</span><span class="p">(</span><span class="n">p2</span><span class="p">);</span>
<span class="c1">//Person(10)单独写就是匿名对象，当前行结束，马上析构</span>

<span class="c1">//1.3隐式转换法</span>
<span class="n">Person</span> <span class="n">p4</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span><span class="c1">//Person p4 = Person(10);</span>
<span class="n">Person</span> <span class="n">p5</span> <span class="o">=</span> <span class="n">p4</span><span class="p">;</span><span class="c1">//Person p5 = Person(p4);</span>

<span class="c1">//注意2：不能利用 拷贝构造函数 初始化匿名函数对象 编译器认为是对象声明</span>
<span class="c1">//Person p5(p4);</span>
</code></pre></div></div> <p><strong>4.2.3 拷贝构造函数调用时机</strong> 三种情况</p> <ul> <li>使用一个已经创建完毕的对象来初始化一个新对象</li> <li>值传递的方式给函数参数传值</li> <li>以值方式返回局部对象</li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="c1">//拷贝构造函数的 调用时机</span>
<span class="k">class</span> <span class="nc">Person</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="n">Person</span><span class="p">()</span> <span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"默认构造函数"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">Person</span><span class="p">(</span><span class="kt">int</span> <span class="n">age</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"有参构造函数"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
		<span class="n">m_Age</span> <span class="o">=</span> <span class="n">age</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">Person</span><span class="p">(</span><span class="k">const</span> <span class="n">Person</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"拷贝构造函数"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
		<span class="n">m_Age</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">m_Age</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">~</span><span class="n">Person</span><span class="p">()</span> <span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"默认析构函数"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="kt">int</span> <span class="n">m_Age</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">//1.使用一个已经创建完毕的对象来初始化一个新对象</span>
<span class="kt">void</span> <span class="n">test01</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">Person</span> <span class="n">p1</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
	<span class="n">Person</span> <span class="n">p2</span><span class="p">(</span><span class="n">p1</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">//2.值传递的方式个函数参数传值</span>
<span class="kt">void</span> <span class="n">doWork</span><span class="p">(</span><span class="n">Person</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">test02</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">Person</span> <span class="n">p</span><span class="p">;</span>
	<span class="n">doWork</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">//3.值方式返回局部对象</span>
<span class="n">Person</span> <span class="n">doWork2</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">Person</span> <span class="n">p1</span><span class="p">;</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">p1</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">p1</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">test03</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">Person</span> <span class="n">p</span> <span class="o">=</span> <span class="n">doWork2</span><span class="p">();</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">p</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">//test01();</span>
	<span class="c1">//test02();</span>
	<span class="n">test03</span><span class="p">();</span>
	<span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>4.2.4 构造函数调用规则</strong> c++编译器默认给一个类至少添加3个函数</p> <ul> <li>默认构造函数（无参，函数体为空）</li> <li>默认析构函数（无参，函数体为空）</li> <li>默认拷贝构造函数，对属性进行值拷贝</li> </ul> <p>构造函数调用规则如下：</p> <ul> <li>如果用户定义有参构造函数，C++不在提供默认无参构造，但是会提供默认拷贝构造</li> <li>如果用户定义拷贝构造函数，C++不会再提供其他构造函数（默认无参构造函数）</li> </ul> <p><strong>4.2.5 深拷贝与浅拷贝</strong> 浅拷贝：简单的赋值拷贝操作 （带来问题堆区的内存重复释放） -&gt;浅拷贝的问题要用深拷贝进行解决 深拷贝：在堆区重新申请空间，进行拷贝操作</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">Person</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="n">Person</span><span class="p">()</span> <span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"默认构造函数"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">Person</span><span class="p">(</span><span class="kt">int</span> <span class="n">age</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"有参构造函数"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
		<span class="n">m_Age</span> <span class="o">=</span> <span class="n">age</span><span class="p">;</span>
		<span class="n">m_Height</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="n">height</span><span class="p">);</span>
	<span class="p">}</span>

<span class="c1">//自己实现拷贝构造函数  解决浅拷贝带来的问题</span>
	<span class="n">Person</span><span class="p">(</span><span class="k">const</span> <span class="n">Person</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"拷贝构造函数的调用"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
		<span class="n">m_Age</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">m_Age</span><span class="p">;</span>
		<span class="c1">//m_Height = p.m_Height;编译器默认实现就是这行代码</span>
		<span class="c1">//深拷贝的操作</span>
		<span class="n">m_Height</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">.</span><span class="n">m_Height</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="o">~</span><span class="n">Person</span><span class="p">()</span> <span class="p">{</span>
		<span class="c1">//析构代码，将堆区开辟数据做释放操作</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">m_Height</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">delete</span> <span class="n">m_Height</span><span class="p">;</span>
			<span class="n">m_Height</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Person的析构函数调用"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="kt">int</span> <span class="n">m_Age</span><span class="p">;</span>
	<span class="kt">int</span><span class="o">*</span> <span class="n">m_Height</span><span class="p">;</span>
<span class="p">};</span>
<span class="kt">void</span> <span class="n">test01</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">Person</span> <span class="n">p1</span><span class="p">(</span><span class="mi">18</span><span class="p">,</span> <span class="mi">160</span><span class="p">);</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"p1的年龄为："</span> <span class="o">&lt;&lt;</span> <span class="n">p1</span><span class="p">.</span><span class="n">m_Age</span> <span class="o">&lt;&lt;</span> <span class="s">"身高为："</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">p1</span><span class="p">.</span><span class="n">m_Height</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="n">Person</span> <span class="n">p2</span><span class="p">(</span><span class="n">p1</span><span class="p">);</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"p2的年龄为："</span> <span class="o">&lt;&lt;</span> <span class="n">p2</span><span class="p">.</span><span class="n">m_Age</span> <span class="o">&lt;&lt;</span> <span class="s">"身高为："</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">p2</span><span class="p">.</span><span class="n">m_Height</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">test01</span><span class="p">();</span>
	<span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>总结：如果属性有堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题 <strong>4.2.6 初始化列表</strong> 作用：用来初始化属性 语法：<em>构造函数():属性1(值1),属性2(值2) … ()</em></p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="c1">//初始化列表</span>
<span class="k">class</span> <span class="nc">Person</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="c1">////传统初始化操作</span>
	<span class="c1">//Person(int a, int b, int c) {</span>
	<span class="c1">//	m_A = a;</span>
	<span class="c1">//	m_B = b;</span>
	<span class="c1">//	m_C = c;</span>
	<span class="c1">//}</span>
	<span class="c1">//初始化列表初始化属性</span>
	<span class="n">Person</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">)</span> <span class="o">:</span><span class="n">m_A</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">m_B</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="n">m_C</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
	<span class="p">}</span>
	<span class="kt">int</span> <span class="n">m_A</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">m_B</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">m_C</span><span class="p">;</span>
<span class="p">};</span>
<span class="kt">void</span> <span class="n">test01</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">Person</span> <span class="n">p</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span><span class="mi">30</span><span class="p">);</span>
	<span class="c1">//Person p;</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"m_A="</span><span class="o">&lt;&lt;</span> <span class="n">p</span><span class="p">.</span><span class="n">m_A</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"m_B="</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="p">.</span><span class="n">m_B</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"m_C="</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="p">.</span><span class="n">m_C</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">test01</span><span class="p">();</span>
	<span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>4.2.7 类对象作为类成员</strong></p> <p>c++类中的成员可以是另外一个类的对象，我们称该对象为对象成员</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="cp">#include</span><span class="cpf">&lt;string&gt;</span><span class="cp">
</span><span class="c1">//类对象作为类成员</span>
<span class="c1">//手机类</span>
<span class="k">class</span> <span class="nc">Phone</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="n">Phone</span><span class="p">(</span><span class="n">string</span> <span class="n">pName</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">m_PName</span> <span class="o">=</span> <span class="n">pName</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="c1">//手机品牌的名称</span>
	<span class="n">string</span> <span class="n">m_PName</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">class</span> <span class="nc">Person</span>
<span class="p">{</span>
<span class="nl">public:</span>	
	<span class="c1">//Phone m_Phone = pName;</span>
	<span class="n">Person</span><span class="p">(</span><span class="n">string</span> <span class="n">name</span><span class="p">,</span> <span class="n">string</span> <span class="n">pName</span><span class="p">)</span><span class="o">:</span> <span class="n">m_Name</span><span class="p">(</span><span class="n">name</span><span class="p">),</span><span class="n">m_Phone</span><span class="p">(</span><span class="n">pName</span><span class="p">){}</span>
	<span class="c1">//姓名</span>
	<span class="n">string</span> <span class="n">m_Name</span><span class="p">;</span>
	<span class="c1">//手机</span>
	<span class="n">Phone</span> <span class="n">m_Phone</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">//当其他类对象作为本类成员，构造时候先构造类对象，析构的顺序与构造相反</span>
<span class="kt">void</span> <span class="n">test01</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">Person</span> <span class="n">p</span><span class="p">(</span><span class="s">"张三"</span><span class="p">,</span><span class="s">"IPhone MAX"</span><span class="p">);</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="p">.</span><span class="n">m_Name</span> <span class="o">&lt;&lt;</span> <span class="s">"拿着："</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="p">.</span><span class="n">m_Phone</span><span class="p">.</span><span class="n">m_PName</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">test01</span><span class="p">();</span>
	<span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>4.2.8 静态成员</strong> 静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员 静态成员分为：</p> <ul> <li>静态成员变量 <ul> <li>所有对象共享同一份数据</li> <li>在编译阶段分配内存</li> <li>类内声明，类外初始化</li> </ul> </li> <li>静态成员函数 <ul> <li>所有对象共享同一个函数</li> <li>静态成员函数只能访问静态成员变量 <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="c1">//静态成员函数</span>
<span class="c1">//所有对象共享同一个函数</span>
<span class="c1">//静态成员函数只能访问静态成员变量</span>
<span class="k">class</span> <span class="nc">Person</span>
<span class="p">{</span>
<span class="nl">public:</span>
 <span class="k">static</span> <span class="kt">void</span> <span class="n">func</span><span class="p">()</span>
 <span class="p">{</span>
 <span class="n">m_A</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span> <span class="c1">//静态成员函数可以访问    静态成员变量</span>
 <span class="c1">//m_B = 200; //静态恒原函数， 不可以访问   非静态成员变量 无法区分到底是哪一个对象的变量</span>
 <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"static 的调用"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
 <span class="p">}</span>
 <span class="k">static</span> <span class="kt">int</span> <span class="n">m_A</span><span class="p">;</span><span class="c1">//静态成员变量</span>
 <span class="kt">int</span> <span class="n">m_B</span><span class="p">;</span><span class="c1">//非静态成员变量</span>
 <span class="c1">//静态成员函数也是有访问权限的</span>
<span class="nl">private:</span>
 <span class="k">static</span> <span class="kt">void</span> <span class="n">func2</span><span class="p">()</span>
 <span class="p">{</span>
 <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"static void func2的调用"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
 <span class="p">}</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="n">Person</span><span class="o">::</span><span class="n">m_A</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="c1">//有两种访问方式</span>
<span class="kt">void</span> <span class="n">test01</span><span class="p">()</span>
<span class="p">{</span>
 <span class="c1">//1.通过对象访问</span>
 <span class="n">Person</span> <span class="n">p</span><span class="p">;</span>
 <span class="n">p</span><span class="p">.</span><span class="n">func</span><span class="p">();</span>
 <span class="c1">//2.通过类名访问</span>
 <span class="n">Person</span><span class="o">::</span><span class="n">func</span><span class="p">();</span>
 <span class="c1">//Person::func2(); //类外访问不到私有静态成员</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
 <span class="n">test01</span><span class="p">();</span>
 <span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div> </div> <h2 id="43-c对象模型和this指针">4.3 C++对象模型和this指针</h2> <p><strong>4.3.1 成员变量和成员函数分开存储</strong> 类内的成员变量和成员函数分开存储 只有非静态成员变量才属于类的对象上</p> </li> </ul> </li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="c1">//成员变量   和   成员函数   是分开存储的</span>
<span class="k">class</span> <span class="nc">Person</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="kt">int</span> <span class="n">m_A</span><span class="p">;</span>					<span class="c1">//非静态成员变量    属于类对象上</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">m_B</span><span class="p">;</span>			<span class="c1">//静态成员变量   不属于类对象上</span>
	<span class="kt">void</span> <span class="n">func</span><span class="p">()</span> <span class="p">{}</span>				<span class="c1">//非静态成员函数   不属于类对象上</span>
	<span class="k">static</span> <span class="kt">void</span> <span class="n">func2</span><span class="p">(){}</span>		<span class="c1">//静态成员函数    不属于类对象上</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="n">Person</span><span class="o">::</span><span class="n">m_B</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="kt">void</span> <span class="n">test01</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">Person</span> <span class="n">p</span><span class="p">;</span>
	<span class="c1">//空对象占用内存空间为: 1</span>
	<span class="c1">//C++编译器会给每一个空对象也分配一个字节的空间，是为了区分空对象占内存的位置</span>
	<span class="c1">//每个空对象也应该有一个独一无二的内存地址</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"size of p ="</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">test02</span><span class="p">()</span> 
<span class="p">{</span>
	<span class="n">Person</span> <span class="n">p</span><span class="p">;</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"size of p ="</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">test01</span><span class="p">();</span>
	<span class="n">test02</span><span class="p">();</span>
	<span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>4.3.2 this 指针概念</strong> this指针指向被调用的成员函数所属的对象</p> <p>this指针是隐含每一个非静态成员函数内的一种指针 this指针不需要定义，直接使用即可</p> <p>this指针的用途：</p> <ul> <li>当形参和成员变量同名时，可用this指针来区分</li> <li>当类的非静态成员函数中返回对象本身，可使用return *this</li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">Person</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="n">Person</span><span class="p">(</span><span class="kt">int</span> <span class="n">age</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="c1">//this指针指向被调用的成员函数所属的对象   当前this-&gt;p1</span>
		<span class="k">this</span><span class="o">-&gt;</span><span class="n">age</span> <span class="o">=</span> <span class="n">age</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="c1">//如果返回值Person PersonAddAge(Person &amp;p) 每次都是新的对象</span>
	<span class="c1">//如果返回值Person &amp; PersonAddAge(Person &amp;p) 每次都是同一个对象</span>
	<span class="n">Person</span> <span class="o">&amp;</span> <span class="n">PersonAddAge</span><span class="p">(</span><span class="n">Person</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">)</span><span class="c1">//返回本体必须用引用的方式</span>
	<span class="p">{</span>
		<span class="k">this</span><span class="o">-&gt;</span><span class="n">age</span> <span class="o">+=</span> <span class="n">p</span><span class="p">.</span><span class="n">age</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="c1">//int age;</span>
	<span class="kt">int</span> <span class="n">age</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">//1.解决名称冲突</span>
<span class="kt">void</span> <span class="n">test01</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">Person</span> <span class="n">p1</span><span class="p">(</span><span class="mi">18</span><span class="p">);</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"p1的年龄为："</span> <span class="o">&lt;&lt;</span> <span class="n">p1</span><span class="p">.</span><span class="n">age</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//2.返回对象本身用*this</span>
<span class="kt">void</span> <span class="n">test02</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">Person</span> <span class="n">p1</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="n">Person</span> <span class="n">p2</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="c1">//链式编程思想</span>
	<span class="n">p2</span><span class="p">.</span><span class="n">PersonAddAge</span><span class="p">(</span><span class="n">p1</span><span class="p">).</span><span class="n">PersonAddAge</span><span class="p">(</span><span class="n">p1</span><span class="p">).</span><span class="n">PersonAddAge</span><span class="p">(</span><span class="n">p1</span><span class="p">);</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"p2的年龄是："</span> <span class="o">&lt;&lt;</span> <span class="n">p2</span><span class="p">.</span><span class="n">age</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">test01</span><span class="p">();</span>
	<span class="n">test02</span><span class="p">();</span>
	<span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>4.3.3 空指针访问成员函数</strong> C++中空指针也可以调用成员函数的，但是也要注意有没有用到this指针 如果用到this指针，需要加以判断保证代码的健壮性</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>


<span class="c1">//空指针调用成员函数</span>
<span class="k">class</span> <span class="nc">Person</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="kt">void</span> <span class="n">showClassName</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"this is Person class"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="kt">void</span> <span class="n">showPersonAge</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="c1">//报错原因是因为传入的指针是NULL</span>
		<span class="k">if</span> <span class="p">(</span><span class="k">this</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"age="</span> <span class="o">&lt;&lt;</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">m_Age</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="kt">int</span> <span class="n">m_Age</span><span class="p">;</span>
<span class="p">};</span>
<span class="kt">void</span> <span class="n">test01</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">Person</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">showClassName</span><span class="p">();</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">showPersonAge</span><span class="p">();</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">test01</span><span class="p">();</span>
	<span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>4.3.4 const 修饰成员函数</strong></p> <p>常函数：</p> <ul> <li>成员函数后加const后我们称为这个函数为<strong>常函数</strong></li> <li>常函数内不可以修改成员属性</li> <li>成员属性声明时加关键字mutable后，在常函数中依然可以修改</li> </ul> <p>常对象：</p> <ul> <li>声明对象前加const称该对象为常对象</li> <li>常对象只能调用常函数</li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="c1">//常函数</span>
<span class="k">class</span> <span class="nc">Person</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="c1">//this指针的本质 是指针常量  指针的指向是不可以修改的</span>
	<span class="c1">//const Person * const this;</span>
	<span class="c1">//在成员函数后加const，修饰的是this指向，让指针指向的值也不可以修改</span>
	<span class="kt">void</span> <span class="n">showPerson</span><span class="p">()</span> <span class="k">const</span>
	<span class="p">{</span>
		<span class="k">this</span><span class="o">-&gt;</span><span class="n">m_B</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
		<span class="c1">//this-&gt;m_A = 100;</span>
		<span class="c1">//this = NULL;//this指针不可以修改指针的指向的</span>
	<span class="p">}</span>
	<span class="kt">void</span> <span class="n">func</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">m_A</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="kt">int</span> <span class="n">m_A</span><span class="p">;</span>
	<span class="k">mutable</span> <span class="kt">int</span> <span class="n">m_B</span><span class="p">;</span><span class="c1">//特殊变量，即使在常函数中，也可以修改这个值,加关键字mutable</span>
<span class="p">};</span>
<span class="kt">void</span> <span class="n">test01</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">Person</span> <span class="n">p</span><span class="p">;</span>
	<span class="n">p</span><span class="p">.</span><span class="n">showPerson</span><span class="p">();</span>
<span class="p">}</span>
<span class="c1">//常对象</span>
<span class="kt">void</span> <span class="n">test02</span><span class="p">()</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="n">Person</span> <span class="n">p</span><span class="p">;</span> <span class="c1">//在对象前加const，变为常对象</span>
	<span class="c1">//p.m_A = 100;//不可修改</span>
	<span class="n">p</span><span class="p">.</span><span class="n">m_B</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span><span class="c1">//m_B是特殊变量，即使在常函数中，也可以修改这个值，加关键字mutable</span>
	<span class="c1">//常对象只能调用常函数</span>
	<span class="n">p</span><span class="p">.</span><span class="n">showPerson</span><span class="p">();</span>
	<span class="c1">//p.func();//常对象不可以调用普通成员函数，因为普通成员函数可以修改属性</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">test01</span><span class="p">();</span>
	<span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="44-友元">4.4 友元</h2> <p>客厅（Public）与卧室（Private）</p> <p>客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去，但是你也允许好朋友进去</p> <p>友元的目的就是让一个函数或者类访问另一个类中私有成员</p> <p>友元的关键字为 friend</p> <p>友元的三种实现</p> <ul> <li>全局函数做友元</li> <li>类做友元</li> <li>成员函数做友元</li> </ul> <p><strong>4.4.1 全局函数做友元</strong></p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="cp">#include</span><span class="cpf">&lt;string&gt;</span><span class="cp">
</span><span class="c1">//建筑物</span>
<span class="k">class</span> <span class="nc">Building</span>
<span class="p">{</span>
	<span class="c1">//goodGay全局函数是	Building好朋友，可以访问Building中私有成员</span>
	<span class="k">friend</span> <span class="kt">void</span> <span class="n">goodGay</span><span class="p">(</span><span class="n">Building</span><span class="o">*</span> <span class="n">building</span><span class="p">);</span>
<span class="nl">public:</span>
	<span class="n">Building</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">m_SittingRoom</span> <span class="o">=</span> <span class="s">"客厅"</span><span class="p">;</span>
		<span class="n">m_BedRoom</span> <span class="o">=</span> <span class="s">"卧室"</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">public:</span>
	<span class="n">string</span> <span class="n">m_SittingRoom</span><span class="p">;</span><span class="c1">//客厅</span>
<span class="nl">private:</span>
	<span class="n">string</span> <span class="n">m_BedRoom</span><span class="p">;</span><span class="c1">//卧室</span>
<span class="p">};</span>

<span class="c1">//全局函数</span>
<span class="kt">void</span> <span class="n">goodGay</span><span class="p">(</span><span class="n">Building</span><span class="o">*</span> <span class="n">building</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"好基友的全局函数  正在访问："</span> <span class="o">&lt;&lt;</span> <span class="n">building</span><span class="o">-&gt;</span><span class="n">m_SittingRoom</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"好基友的全局函数  正在访问："</span> <span class="o">&lt;&lt;</span> <span class="n">building</span><span class="o">-&gt;</span><span class="n">m_BedRoom</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">test01</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">Building</span> <span class="n">building</span><span class="p">;</span>
	
	<span class="n">goodGay</span><span class="p">(</span><span class="o">&amp;</span><span class="n">building</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">test01</span><span class="p">();</span>
	<span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>4.4.2 类做友元</strong></p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="cp">#include</span><span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="c1">//类做友元</span>
<span class="k">class</span> <span class="nc">Building</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">GoodGay</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="n">GoodGay</span><span class="p">();</span>
	<span class="kt">void</span> <span class="n">visit</span><span class="p">();</span>			<span class="c1">//参观函数	访问Building中的属性</span>
	<span class="n">Building</span><span class="o">*</span> <span class="n">building</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">class</span> <span class="nc">Building</span>
<span class="p">{</span>
	<span class="c1">//GoodGay是本类的好朋友可以访问本类中私有成员</span>
	<span class="k">friend</span> <span class="k">class</span> <span class="nc">GoodGay</span><span class="p">;</span>
<span class="nl">public:</span>
	<span class="n">Building</span><span class="p">();</span>
<span class="nl">public:</span>
	<span class="n">string</span> <span class="n">m_SittingRoom</span><span class="p">;</span><span class="c1">//客厅</span>
<span class="nl">private:</span>
	<span class="n">string</span> <span class="n">m_BedRoom</span><span class="p">;</span><span class="c1">//卧室</span>
<span class="p">};</span>
<span class="c1">//类外写成员函数</span>
<span class="n">Building</span><span class="o">::</span><span class="n">Building</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">m_SittingRoom</span> <span class="o">=</span> <span class="s">"客厅"</span><span class="p">;</span>
	<span class="n">m_BedRoom</span> <span class="o">=</span> <span class="s">"卧室"</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">GoodGay</span><span class="o">::</span><span class="n">GoodGay</span><span class="p">()</span>
<span class="p">{</span>
	<span class="c1">//创建一个建筑物的对象</span>
	<span class="n">building</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Building</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">GoodGay</span><span class="o">::</span><span class="n">visit</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"好基友类正在访问："</span> <span class="o">&lt;&lt;</span> <span class="n">building</span><span class="o">-&gt;</span><span class="n">m_SittingRoom</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"好基友类正在访问："</span> <span class="o">&lt;&lt;</span> <span class="n">building</span><span class="o">-&gt;</span><span class="n">m_BedRoom</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">test01</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">GoodGay</span> <span class="n">gg</span><span class="p">;</span>
	<span class="n">gg</span><span class="p">.</span><span class="n">visit</span><span class="p">();</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">test01</span><span class="p">();</span>
	<span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>4.4.3 成员函数做友元</strong></p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="cp">#include</span><span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">Building</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">GoodGay</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="n">GoodGay</span><span class="p">();</span>
	<span class="kt">void</span> <span class="n">visit</span><span class="p">();</span>			<span class="c1">//让visit函数可以访问Building中私有成员</span>
	<span class="kt">void</span> <span class="n">visit2</span><span class="p">();</span>		<span class="c1">//让visit2函数不可以访问Building中私有成员</span>
	<span class="n">Building</span><span class="o">*</span> <span class="n">building</span><span class="p">;</span>

<span class="p">};</span>
<span class="k">class</span> <span class="nc">Building</span>
<span class="p">{</span>
	<span class="c1">//告诉编译器		GoodGay类下的visit成员函数作为本类的好朋友，可以访问私有成员</span>
	<span class="k">friend</span> <span class="kt">void</span> <span class="n">GoodGay</span><span class="o">::</span><span class="n">visit</span><span class="p">();</span>
<span class="nl">public:</span>
	<span class="n">Building</span><span class="p">();</span>
<span class="nl">public:</span>
	<span class="n">string</span> <span class="n">m_SittingRoom</span><span class="p">;</span><span class="c1">//客厅</span>
<span class="nl">private:</span>
	<span class="n">string</span> <span class="n">m_BedRoom</span><span class="p">;</span><span class="c1">//卧室</span>
<span class="p">};</span>
<span class="c1">//类外写成员函数</span>
<span class="n">Building</span><span class="o">::</span><span class="n">Building</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">m_SittingRoom</span> <span class="o">=</span> <span class="s">"客厅"</span><span class="p">;</span>
	<span class="n">m_BedRoom</span> <span class="o">=</span> <span class="s">"卧室"</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">GoodGay</span><span class="o">::</span><span class="n">GoodGay</span><span class="p">()</span>
<span class="p">{</span>
	<span class="c1">//创建一个建筑物的对象</span>
	<span class="n">building</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Building</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">GoodGay</span><span class="o">::</span><span class="n">visit</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"好基友类正在访问："</span> <span class="o">&lt;&lt;</span> <span class="n">building</span><span class="o">-&gt;</span><span class="n">m_SittingRoom</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"好基友类正在访问："</span> <span class="o">&lt;&lt;</span> <span class="n">building</span><span class="o">-&gt;</span><span class="n">m_BedRoom</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">GoodGay</span><span class="o">::</span><span class="n">visit2</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"好基友类正在访问："</span> <span class="o">&lt;&lt;</span> <span class="n">building</span><span class="o">-&gt;</span><span class="n">m_SittingRoom</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="c1">//cout &lt;&lt; "好基友类正在访问：" &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;不能访问</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">test01</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">GoodGay</span> <span class="n">gg</span><span class="p">;</span>
	<span class="n">gg</span><span class="p">.</span><span class="n">visit</span><span class="p">();</span>
	<span class="n">gg</span><span class="p">.</span><span class="n">visit2</span><span class="p">();</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">test01</span><span class="p">();</span>
	<span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="45-运算符重载">4.5 运算符重载</h2> <p>运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型 <strong>4.5.1 加号运算符重载</strong></p> <p>作用:实现两个自定义数据类型相加的运算</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="cp">#include</span><span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="c1">//加号运算符重载</span>
<span class="k">class</span> <span class="nc">Person</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="c1">//1.成员函数重载+号</span>
	<span class="cm">/*Person operator+(Person&amp; p)
	{
		Person temp;
		temp.m_A = this-&gt;m_A + p.m_A;
		temp.m_B = this-&gt;m_B + p.m_B;
		return temp;
	}*/</span>
	<span class="kt">int</span> <span class="n">m_A</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">m_B</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">//2.全局函数重载+号</span>
<span class="n">Person</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="n">Person</span> <span class="o">&amp;</span><span class="n">p1</span> <span class="p">,</span> <span class="n">Person</span> <span class="o">&amp;</span><span class="n">p2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">Person</span> <span class="n">temp</span><span class="p">;</span>
	<span class="n">temp</span><span class="p">.</span><span class="n">m_A</span> <span class="o">=</span> <span class="n">p1</span><span class="p">.</span><span class="n">m_A</span> <span class="o">+</span> <span class="n">p2</span><span class="p">.</span><span class="n">m_A</span><span class="p">;</span>
	<span class="n">temp</span><span class="p">.</span><span class="n">m_B</span> <span class="o">=</span> <span class="n">p1</span><span class="p">.</span><span class="n">m_B</span> <span class="o">+</span> <span class="n">p2</span><span class="p">.</span><span class="n">m_B</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//函数重载的版本</span>
<span class="n">Person</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="n">Person</span><span class="o">&amp;</span> <span class="n">p1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">Person</span> <span class="n">temp</span><span class="p">;</span>
	<span class="n">temp</span><span class="p">.</span><span class="n">m_A</span> <span class="o">=</span> <span class="n">p1</span><span class="p">.</span><span class="n">m_A</span> <span class="o">+</span> <span class="n">num</span><span class="p">;</span>
	<span class="n">temp</span><span class="p">.</span><span class="n">m_B</span> <span class="o">=</span> <span class="n">p1</span><span class="p">.</span><span class="n">m_B</span> <span class="o">+</span> <span class="n">num</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">test01</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">Person</span> <span class="n">p1</span><span class="p">;</span>
	<span class="n">p1</span><span class="p">.</span><span class="n">m_A</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
	<span class="n">p1</span><span class="p">.</span><span class="n">m_B</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
	<span class="n">Person</span> <span class="n">p2</span><span class="p">;</span>
	<span class="n">p2</span><span class="p">.</span><span class="n">m_A</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
	<span class="n">p2</span><span class="p">.</span><span class="n">m_B</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

	<span class="c1">//成员函数本质调用</span>
	<span class="c1">//Person p3 = p1.operator+(p2);</span>

	<span class="c1">//全局函数的本质调用</span>
	<span class="c1">//Person p3 = operator+(p1, p2);</span>

	<span class="n">Person</span> <span class="n">p3</span> <span class="o">=</span> <span class="n">p1</span> <span class="o">+</span> <span class="n">p2</span><span class="p">;</span>
	<span class="c1">//运算符重载也可以发生函数重载</span>
	<span class="n">Person</span> <span class="n">p4</span> <span class="o">=</span> <span class="n">p1</span> <span class="o">+</span> <span class="mi">100</span><span class="p">;</span><span class="c1">//Person + int</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"p3.m_A="</span> <span class="o">&lt;&lt;</span> <span class="n">p3</span><span class="p">.</span><span class="n">m_A</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"p3.m_B="</span> <span class="o">&lt;&lt;</span> <span class="n">p3</span><span class="p">.</span><span class="n">m_B</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"p4.m_A="</span> <span class="o">&lt;&lt;</span> <span class="n">p4</span><span class="p">.</span><span class="n">m_A</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"p4.m_B="</span> <span class="o">&lt;&lt;</span> <span class="n">p4</span><span class="p">.</span><span class="n">m_B</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">test01</span><span class="p">();</span>
	<span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>4.5.2 左移运算符重载</strong></p> <p>作用：可以输出自定义数据类型</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="cp">#include</span><span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="c1">//左移运算符重载</span>
<span class="k">class</span> <span class="nc">Person</span>
<span class="p">{</span>
	<span class="k">friend</span> <span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">cout</span><span class="p">,</span> <span class="n">Person</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">);</span>
<span class="nl">public:</span>
	<span class="n">Person</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">m_A</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
		<span class="n">m_B</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">private:</span>
	<span class="c1">//利用成员函数重载	左移运算符  p.operator&lt;&lt;(cout) 简化版本  p&lt;&lt;cout</span>
	<span class="c1">//通常不会利用成员函数重载&lt;&lt;运算符，因为无法实现cout在左侧</span>
	<span class="cm">/*void operator&lt;&lt;(cout)
	{
	}*/</span>
	<span class="kt">int</span> <span class="n">m_A</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">m_B</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">//只能利用全局函数重载左移运算符</span>
<span class="n">ostream</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">cout</span><span class="p">,</span><span class="n">Person</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">)</span> <span class="c1">//本质   operator&lt;&lt;(cout, p ) 简化 cout &lt;&lt; p</span>
<span class="p">{</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"m_A = "</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="p">.</span><span class="n">m_A</span> <span class="o">&lt;&lt;</span> <span class="s">"m_B= "</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="p">.</span><span class="n">m_B</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">cout</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">test01</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">Person</span> <span class="n">p</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">p</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">test01</span><span class="p">();</span>
	<span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>4.5.3 递增运算符重载</strong></p> <p>++号 作用：通过重载递增运算符，实现自己的整形数据</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="cp">#include</span><span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="c1">//递增运算符重载</span>
<span class="k">class</span> <span class="nc">MyInteger</span>
<span class="p">{</span>
	<span class="k">friend</span> <span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">cout</span><span class="p">,</span> <span class="n">MyInteger</span> <span class="n">myint</span><span class="p">);</span>
<span class="nl">public:</span>
	<span class="n">MyInteger</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">m_Num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="c1">//重置前置运算符		返回引用为了一直对一个数据进行递增操作</span>
	<span class="n">MyInteger</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">++</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="c1">//先进行++运算</span>
		<span class="n">m_Num</span><span class="o">++</span><span class="p">;</span>
		<span class="c1">//再将自身返回</span>
		<span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="c1">//重置后置运算符</span>
	<span class="c1">//void operator++(int)		int代表占位参数，可以用于区分前置和后置递增</span>
	<span class="n">MyInteger</span> <span class="k">operator</span><span class="o">++</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="c1">//后置递增一定返回值		前置递增一定返回引用</span>
	<span class="p">{</span>
		<span class="c1">//先		记录当时结果</span>
		<span class="n">MyInteger</span> <span class="n">temp</span> <span class="o">=</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
		<span class="c1">//后		递增</span>
		<span class="n">m_Num</span><span class="o">++</span><span class="p">;</span>
		<span class="c1">//最后将记录结果做返回</span>
		<span class="k">return</span> <span class="n">temp</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">private:</span>
	<span class="kt">int</span> <span class="n">m_Num</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">//重载左移运算符</span>
<span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">cout</span><span class="p">,</span> <span class="n">MyInteger</span> <span class="n">myint</span><span class="p">)</span> <span class="c1">//本质   operator&lt;&lt;(cout, p ) 简化 cout &lt;&lt; p</span>
<span class="p">{</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">myint</span><span class="p">.</span><span class="n">m_Num</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">cout</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">test01</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">MyInteger</span> <span class="n">myint</span><span class="p">;</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">++</span><span class="p">(</span><span class="o">++</span><span class="n">myint</span><span class="p">)</span><span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span><span class="c1">//0</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">myint</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">test02</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">MyInteger</span> <span class="n">myint</span><span class="p">;</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">myint</span><span class="o">++</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">myint</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">test01</span><span class="p">();</span>
	<span class="n">test02</span><span class="p">();</span>
	<span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>4.5.4 递减运算符重载</strong></p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="cp">#include</span><span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="c1">//递增运算符重载</span>
<span class="k">class</span> <span class="nc">MyInteger</span>
<span class="p">{</span>
	<span class="k">friend</span> <span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">cout</span><span class="p">,</span> <span class="n">MyInteger</span> <span class="n">myint</span><span class="p">);</span>
<span class="nl">public:</span>
	<span class="n">MyInteger</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">m_Num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="c1">//重置前置运算符		返回引用为了一直对一个数据进行递增操作</span>
	<span class="n">MyInteger</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">--</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="c1">//先进行--运算</span>
		<span class="n">m_Num</span><span class="o">--</span><span class="p">;</span>
		<span class="c1">//再将自身返回</span>
		<span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="c1">//重置后置运算符</span>
	<span class="c1">//void operator--(int)		int代表占位参数，可以用于区分前置和后置递减</span>
	<span class="n">MyInteger</span> <span class="k">operator</span><span class="o">--</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="c1">//后置递减一定返回值		前置递减一定返回引用</span>
	<span class="p">{</span>
		<span class="c1">//先		记录当时结果</span>
		<span class="n">MyInteger</span> <span class="n">temp</span> <span class="o">=</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
		<span class="c1">//后		递减</span>
		<span class="n">m_Num</span><span class="o">--</span><span class="p">;</span>
		<span class="c1">//最后将记录结果做返回</span>
		<span class="k">return</span> <span class="n">temp</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">private:</span>
	<span class="kt">int</span> <span class="n">m_Num</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">//重载左移运算符</span>
<span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">cout</span><span class="p">,</span> <span class="n">MyInteger</span> <span class="n">myint</span><span class="p">)</span> <span class="c1">//本质   operator&lt;&lt;(cout, p ) 简化 cout &lt;&lt; p</span>
<span class="p">{</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">myint</span><span class="p">.</span><span class="n">m_Num</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">cout</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">test01</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">MyInteger</span> <span class="n">myint</span><span class="p">;</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">--</span><span class="p">(</span><span class="o">--</span><span class="n">myint</span><span class="p">)</span><span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span><span class="c1">//0</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">myint</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">test02</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">MyInteger</span> <span class="n">myint</span><span class="p">;</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">myint</span><span class="o">--</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">myint</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">test01</span><span class="p">();</span>
	<span class="n">test02</span><span class="p">();</span>
	<span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>4.5.5 赋值运算符重载</strong> c++编译器至少给一个类添加4个函数</p> <ol> <li>默认构造函数（无参，函数体为空）</li> <li>默认析构函数（无参，函数体为空）</li> <li>默认拷贝构造函数，对属性进行值拷贝</li> <li>赋值运算符 operator=，对属性进行值拷贝</li> </ol> <p>如果类中有属性指向堆区，做赋值操作是也会出现深浅拷贝问题</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="cp">#include</span><span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="c1">//递增运算符重载</span>
<span class="k">class</span> <span class="nc">Person</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="n">Person</span><span class="p">(</span><span class="kt">int</span> <span class="n">age</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">m_Age</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="n">age</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="o">~</span><span class="n">Person</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">m_Age</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">delete</span> <span class="n">m_Age</span><span class="p">;</span>
			<span class="n">m_Age</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">//重载		赋值运算符</span>
	<span class="n">Person</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Person</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="c1">//编译器提供的浅拷贝</span>
		<span class="c1">//m_Age = p.m_Age;</span>
		<span class="c1">//应该先判断是否有属性在堆区，如果有先释放干净，然后深拷贝</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">m_Age</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">delete</span> <span class="n">m_Age</span><span class="p">;</span>
			<span class="n">m_Age</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">m_Age</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">.</span><span class="n">m_Age</span><span class="p">);</span>
		<span class="c1">//返回对象本身</span>
		<span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="kt">int</span><span class="o">*</span> <span class="n">m_Age</span><span class="p">;</span>
<span class="p">};</span>
<span class="kt">void</span> <span class="n">test01</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">Person</span> <span class="n">p1</span><span class="p">(</span><span class="mi">18</span><span class="p">);</span>
	<span class="n">Person</span> <span class="n">p2</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
	<span class="n">Person</span> <span class="n">p3</span><span class="p">(</span><span class="mi">30</span><span class="p">);</span>
	<span class="n">p3</span> <span class="o">=</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">p1</span><span class="p">;</span><span class="c1">//赋值操作</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"p1的年龄为："</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">p1</span><span class="p">.</span><span class="n">m_Age</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"p2的年龄为："</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">p2</span><span class="p">.</span><span class="n">m_Age</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"p3的年龄为："</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">p3</span><span class="p">.</span><span class="n">m_Age</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">test01</span><span class="p">();</span>
	<span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>4.5.6 关系运算符重载</strong></p> <p>作用：重载关系运算符，可以让两个自定义类型对象进行对比操作</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="cp">#include</span><span class="cpf">&lt;string&gt;</span><span class="cp">
</span><span class="c1">//关系运算符重载</span>
<span class="k">class</span> <span class="nc">Person</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="n">Person</span><span class="p">(</span><span class="n">string</span> <span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">age</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">m_Name</span> <span class="o">=</span> <span class="n">name</span><span class="p">;</span>
		<span class="n">m_Age</span> <span class="o">=</span> <span class="n">age</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="c1">//重载 == 号</span>
	<span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="n">Person</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">m_Name</span> <span class="o">==</span> <span class="n">p</span><span class="p">.</span><span class="n">m_Name</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">m_Age</span> <span class="o">==</span> <span class="n">p</span><span class="p">.</span><span class="n">m_Age</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="c1">//重载 != 号</span>
	<span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="n">Person</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">m_Name</span> <span class="o">==</span> <span class="n">p</span><span class="p">.</span><span class="n">m_Name</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">m_Age</span> <span class="o">==</span> <span class="n">p</span><span class="p">.</span><span class="n">m_Age</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">string</span> <span class="n">m_Name</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">m_Age</span><span class="p">;</span>
<span class="p">};</span>
<span class="kt">void</span> <span class="n">test01</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">Person</span> <span class="n">p1</span><span class="p">(</span><span class="s">"Tom"</span><span class="p">,</span> <span class="mi">18</span><span class="p">);</span>
	<span class="n">Person</span> <span class="n">p2</span><span class="p">(</span><span class="s">"Tom"</span><span class="p">,</span> <span class="mi">18</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p1</span> <span class="o">==</span> <span class="n">p2</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"p1和p2是相等的！"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span>
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"p1和p2是不相等的！"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p1</span> <span class="o">!=</span> <span class="n">p2</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"p1和p2是不相等的！"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span>
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"p1和p2是相等的！"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">test01</span><span class="p">();</span>
	<span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>4.5.7 函数调用运算符重载</strong></p> <ul> <li>函数调用运算符（）也可以重载</li> <li>由于重载后使用的方式非常像函数的调用，因此称为仿函数</li> <li>仿函数没有固定的写法，非常灵活</li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="cp">#include</span><span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="c1">//函数调用运算符重载</span>
<span class="c1">//打印输出类</span>
<span class="k">class</span> <span class="nc">MyPrint</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="c1">//重载函数调用运算符</span>
	<span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="n">string</span> <span class="n">test</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">test</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="n">MyPrint02</span><span class="p">(</span><span class="n">string</span> <span class="n">test</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">test</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">test01</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">MyPrint</span> <span class="n">myPrint</span><span class="p">;</span>
	<span class="n">myPrint</span><span class="p">(</span><span class="s">"Hellp World!"</span><span class="p">);</span><span class="c1">//由于使用起来非常类似于函数调用，因此称之为仿函数</span>
	<span class="n">MyPrint02</span><span class="p">(</span><span class="s">"Hellp World!"</span><span class="p">);</span>
	
<span class="p">}</span>
<span class="c1">//仿函数非常灵活，没有固定的写法</span>
<span class="c1">//加法类</span>
<span class="k">class</span> <span class="nc">MyAdd</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="kt">int</span> <span class="k">operator</span><span class="p">()(</span><span class="kt">int</span> <span class="n">num1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num2</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">num1</span> <span class="o">+</span> <span class="n">num2</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">};</span>
<span class="kt">void</span> <span class="n">test02</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">MyAdd</span> <span class="n">myadd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">myadd</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"ret="</span> <span class="o">&lt;&lt;</span> <span class="n">ret</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

	<span class="c1">//匿名函数对象 MyAdd() 没有名字</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">MyAdd</span><span class="p">()(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">test01</span><span class="p">();</span>
	<span class="n">test02</span><span class="p">();</span>
	<span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="46-继承">4.6 继承</h2> <p><strong>继承是面向对象三大特性之一</strong> 有些类与类之间存在特殊的关系，例图如下： <img src="https://blog.slienceme.cn/images/posts/20201214104302494.png" alt="Alt Text" /> 利用继承，减少重复代码</p> <p><strong>4.6.1 继承的基本方式</strong></p> <p><strong>普通实现</strong></p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="cp">#include</span><span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="c1">//普通实现页面</span>

<span class="c1">//Java页面</span>
<span class="k">class</span> <span class="nc">Java</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="c1">//重载函数调用运算符</span>
	<span class="kt">void</span> <span class="n">header</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"首页、公开课、登录、注册...(公共头部)"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="kt">void</span> <span class="n">footer</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"帮助中心、交流合作、站内地图...(公共底部)"</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="kt">void</span> <span class="n">left</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Java、Python、C++、...(公共分类列表)"</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="kt">void</span> <span class="n">content</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Java学科视频"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">};</span>
<span class="c1">//Python页面</span>
<span class="k">class</span> <span class="nc">Python</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="c1">//重载函数调用运算符</span>
	<span class="kt">void</span> <span class="n">header</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"首页、公开课、登录、注册...(公共头部)"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="kt">void</span> <span class="n">footer</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"帮助中心、交流合作、站内地图...(公共底部)"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="kt">void</span> <span class="n">left</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Java、Python、C++、...(公共分类列表)"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="kt">void</span> <span class="n">content</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Python学科视频"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">};</span>
<span class="c1">//C++页面</span>
<span class="k">class</span> <span class="nc">CPP</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="c1">//重载函数调用运算符</span>
	<span class="kt">void</span> <span class="n">header</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"首页、公开课、登录、注册...(公共头部)"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="kt">void</span> <span class="n">footer</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"帮助中心、交流合作、站内地图...(公共底部)"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="kt">void</span> <span class="n">left</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Java、Python、C++、...(公共分类列表)"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="kt">void</span> <span class="n">content</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"C++学科视频"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="n">test01</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Java下载视频页面:   "</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="n">Java</span> <span class="n">ja</span><span class="p">;</span>
	<span class="n">ja</span><span class="p">.</span><span class="n">header</span><span class="p">();</span>
	<span class="n">ja</span><span class="p">.</span><span class="n">footer</span><span class="p">();</span>
	<span class="n">ja</span><span class="p">.</span><span class="n">left</span><span class="p">();</span>
	<span class="n">ja</span><span class="p">.</span><span class="n">content</span><span class="p">();</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"-----------------------------------"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Python下载视频页面:   "</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="n">Python</span> <span class="n">py</span><span class="p">;</span>
	<span class="n">py</span><span class="p">.</span><span class="n">header</span><span class="p">();</span>
	<span class="n">py</span><span class="p">.</span><span class="n">footer</span><span class="p">();</span>
	<span class="n">py</span><span class="p">.</span><span class="n">left</span><span class="p">();</span>
	<span class="n">py</span><span class="p">.</span><span class="n">content</span><span class="p">();</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"-----------------------------------"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"C++下载视频页面:   "</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="n">CPP</span> <span class="n">cpp</span><span class="p">;</span>
	<span class="n">cpp</span><span class="p">.</span><span class="n">header</span><span class="p">();</span>
	<span class="n">cpp</span><span class="p">.</span><span class="n">footer</span><span class="p">();</span>
	<span class="n">cpp</span><span class="p">.</span><span class="n">left</span><span class="p">();</span>
	<span class="n">cpp</span><span class="p">.</span><span class="n">content</span><span class="p">();</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"-----------------------------------"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">test01</span><span class="p">();</span>

	<span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>继承实现</strong></p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="cp">#include</span><span class="cpf">&lt;string&gt;</span><span class="cp">
</span><span class="c1">//继承实现页面</span>
<span class="c1">//公共页面类</span>
<span class="k">class</span> <span class="nc">BasePage</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="kt">void</span> <span class="n">header</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"首页、公开课、登录、注册...(公共头部)"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="kt">void</span> <span class="n">footer</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"帮助中心、交流合作、站内地图...(公共底部)"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="kt">void</span> <span class="n">left</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Java、Python、C++、...(公共分类列表)"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">};</span>
<span class="c1">//继承的好处：减少重复的代码</span>
<span class="c1">//语法： class 子类： 继承方式	父类</span>
<span class="c1">//子类		也称为		派生类</span>
<span class="c1">//父类		也成为		基类</span>

<span class="c1">//Java页面</span>
<span class="k">class</span> <span class="nc">Java</span> <span class="o">:</span> <span class="k">public</span> <span class="n">BasePage</span>
<span class="p">{</span>
<span class="nl">public:</span>
		<span class="kt">void</span> <span class="n">content</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Java学科视频"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="c1">//Python页面</span>
<span class="k">class</span> <span class="nc">Python</span> <span class="o">:</span> <span class="k">public</span> <span class="n">BasePage</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="kt">void</span> <span class="n">content</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Python学科视频"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="c1">//CPP页面</span>
<span class="k">class</span> <span class="nc">CPP</span> <span class="o">:</span> <span class="k">public</span> <span class="n">BasePage</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="kt">void</span> <span class="n">content</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"CPP学科视频"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="n">test01</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Java下载视频页面:   "</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="n">Java</span> <span class="n">ja</span><span class="p">;</span>
	<span class="n">ja</span><span class="p">.</span><span class="n">header</span><span class="p">();</span>
	<span class="n">ja</span><span class="p">.</span><span class="n">footer</span><span class="p">();</span>
	<span class="n">ja</span><span class="p">.</span><span class="n">left</span><span class="p">();</span>
	<span class="n">ja</span><span class="p">.</span><span class="n">content</span><span class="p">();</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"-----------------------------------"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Python下载视频页面:   "</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="n">Python</span> <span class="n">py</span><span class="p">;</span>
	<span class="n">py</span><span class="p">.</span><span class="n">header</span><span class="p">();</span>
	<span class="n">py</span><span class="p">.</span><span class="n">footer</span><span class="p">();</span>
	<span class="n">py</span><span class="p">.</span><span class="n">left</span><span class="p">();</span>
	<span class="n">py</span><span class="p">.</span><span class="n">content</span><span class="p">();</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"-----------------------------------"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"C++下载视频页面:   "</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="n">CPP</span> <span class="n">cpp</span><span class="p">;</span>
	<span class="n">cpp</span><span class="p">.</span><span class="n">header</span><span class="p">();</span>
	<span class="n">cpp</span><span class="p">.</span><span class="n">footer</span><span class="p">();</span>
	<span class="n">cpp</span><span class="p">.</span><span class="n">left</span><span class="p">();</span>
	<span class="n">cpp</span><span class="p">.</span><span class="n">content</span><span class="p">();</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"-----------------------------------"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	
<span class="p">}</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">test01</span><span class="p">();</span>

	<span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>总结:</strong> 继承的好处:可以减少重复的代码 class A: public B; A 类称为子类 或 派生类 B 类称为父类 或 基类</p> <p><strong>派生类中的成员，包含两大部分</strong> 一类是从基类继承过来的，一类是自己增加的成员。 从基类继承过来的表现其共性，而新增的成员体现了其个性</p> <p><strong>4.6.2 继承方式</strong> <img src="https://blog.slienceme.cn/images/posts/20201214115839411.png" alt="Alt Text" /> <strong>继承方式一共有三种：</strong></p> <ul> <li>公共继承</li> <li>保护继承</li> <li>私有继承 <img src="https://blog.slienceme.cn/images/posts/20201214120033913.png" alt="Alt Text" /></li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="cp">#include</span><span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">Base1</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="kt">int</span> <span class="n">m_A</span><span class="p">;</span>
<span class="nl">protected:</span>
	<span class="kt">int</span> <span class="n">m_B</span><span class="p">;</span>
<span class="nl">private:</span>
	<span class="kt">int</span> <span class="n">m_C</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">//公共继承</span>
<span class="k">class</span> <span class="nc">Son</span> <span class="o">:</span><span class="k">public</span> <span class="n">Base1</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="kt">void</span> <span class="n">func</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">m_A</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span><span class="c1">//父类中的公共权限	到子类中依然是公共权限</span>
		<span class="n">m_B</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span><span class="c1">//父类中的保护权限		到子类中依然是保护权限</span>
		<span class="c1">//m_C = 10;//父类中的私有权限		到子类中访问不到</span>
	<span class="p">}</span>
<span class="p">};</span>
<span class="kt">void</span> <span class="n">test01</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">Son</span> <span class="n">s1</span><span class="p">;</span>
	<span class="n">s1</span><span class="p">.</span><span class="n">m_A</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
	<span class="c1">//s1.m_B = 100; //到Son1中 m_B是保护权限	类外访问不到</span>
<span class="p">}</span>

<span class="c1">//保护继承</span>
<span class="k">class</span> <span class="nc">Son2</span> <span class="o">:</span><span class="k">protected</span> <span class="n">Base1</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="kt">void</span> <span class="n">func</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">m_A</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span><span class="c1">//父类中的公共成员	到子类中变为保护成员</span>
		<span class="n">m_B</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span><span class="c1">//父类中的保护权限		到子类中变为保护成员</span>
		<span class="c1">//m_C = 10;//父类中的私有权限		到子类中访问不到</span>
	<span class="p">}</span>
<span class="p">};</span>
<span class="kt">void</span> <span class="n">test02</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">Son2</span> <span class="n">s1</span><span class="p">;</span>
	<span class="c1">//s1.m_A = 1000;//在Son2中  m_A变为保护权限，因此类外访问不到</span>
	<span class="c1">//s1.m_B = 1000;//在Son2中  m_B为保护权限，不可以访问</span>
<span class="p">}</span>

<span class="c1">//私有继承</span>
<span class="k">class</span> <span class="nc">Son3</span> <span class="o">:</span><span class="k">private</span> <span class="n">Base1</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="kt">void</span> <span class="n">func</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">m_A</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span><span class="c1">//父类中的公共成员		到子类中变为		私有成员</span>
		<span class="n">m_B</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span><span class="c1">//父类中的保护权限		到子类中变为		私有成员</span>
		<span class="c1">//m_C = 10;//父类中的私有权限		到子类中访问不到</span>
	<span class="p">}</span>
<span class="p">};</span>
<span class="kt">void</span> <span class="n">test03</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">Son3</span> <span class="n">s1</span><span class="p">;</span>
	<span class="c1">//s1.m_A = 1000;//在Son2中  m_A变为私有成员，因此类外访问不到</span>
	<span class="c1">//s1.m_B = 1000;//在Son2中  m_B为私有成员，不可以访问</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">GrandSon3</span> <span class="o">:</span><span class="k">public</span> <span class="n">Son3</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="kt">void</span> <span class="n">func</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="c1">//m_A = 1000;//到了Son3中		m_A变为私有，即使是儿子也访问不到</span>
		<span class="c1">//m_B = 1000;//到了Son3中		m_A变为私有，即使是儿子也访问不到</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">test01</span><span class="p">();</span>

	<span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>4.6.3 继承中的对象模型</strong></p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="cp">#include</span><span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">Base</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="kt">int</span> <span class="n">m_A</span><span class="p">;</span>
<span class="nl">protected:</span>
	<span class="kt">int</span> <span class="n">m_B</span><span class="p">;</span>
<span class="nl">private:</span>
	<span class="kt">int</span> <span class="n">m_C</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">class</span> <span class="nc">Son</span> <span class="o">:</span><span class="k">public</span> <span class="n">Base</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="kt">int</span> <span class="n">m_D</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">//利用开发人员命令提示工具查看对象模型</span>
<span class="c1">//跳转盘符		F:</span>
<span class="c1">//跳转文件路径	cd  具体路径下</span>
<span class="c1">//查看命名</span>
<span class="c1">//c1 /d1 reportSingleClassLayout类名 文件名</span>
<span class="kt">void</span> <span class="n">test01</span><span class="p">()</span>
<span class="p">{</span>
	<span class="c1">//		16</span>
	<span class="c1">//父类中所有非静态成员属性都会被子类继承下去</span>
	<span class="c1">//父类中私有成员属性	是被编译器给隐藏了，因此是访问不到，但是确实被继承下去了</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"size of Son"</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Son</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">test01</span><span class="p">();</span>

	<span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>结论：父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到</p> <p><strong>4.6.4 继承中构造和析构顺序</strong></p> <p>子类继承父类后，当创建子类对象，也会调用父类的构造函数</p> <p>问题：父类和子类的构造和析构顺序</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="cp">#include</span><span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="c1">//继承中的构造和析构函数顺序</span>
<span class="k">class</span> <span class="nc">Base</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="n">Base</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Base构造函数！"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">~</span><span class="n">Base</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Base析构函数！"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">};</span>
<span class="k">class</span> <span class="nc">Son</span> <span class="o">:</span><span class="k">public</span> <span class="n">Base</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="n">Son</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Son构造函数！"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">~</span><span class="n">Son</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Son析构函数！"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
	
<span class="p">};</span>
<span class="kt">void</span> <span class="n">test01</span><span class="p">()</span>
<span class="p">{</span>
	<span class="c1">//Base b;</span>
	<span class="c1">//继承中的构造与析构顺序如下：</span>
	<span class="c1">//先构造父类，再构造子类，析构的顺序与构造的顺序相反</span>
	<span class="n">Son</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">test01</span><span class="p">();</span>

	<span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>总结：</strong> 继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</p> <p><strong>4.6.5 继承同名成员处理方式</strong></p> <ul> <li>访问子类同名成员 直接访问即可</li> <li>访问父类同名成员 需要加作用域 ```cpp #include<iostream> using namespace std; #include<string></string></iostream></li> </ul> <p>//继承中的构造和析构函数顺序 class Base { public: Base() { m_A = 100; } void func() { cout « “Base - func()调用” « endl; } void func(int a) { cout « “Son - func(int a)调用” « endl; } int m_A; }; class Son :public Base { public: Son() { m_A = 200; } void func() { cout « “Son - func()调用” « endl; } int m_A; }; void test01() { Son s; cout « “Son 下 m_A= “ « s.m_A « endl; //如果通过子类对象 访问到父类中同名成员，需要加作用域 cout « “Base 下 m_A= “ « s.Base::m_A « endl; } void test02() { Son s; s.func();//直接调用 调用是子类中的同名成员</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//如何调用到父类中的同名成员？
s.Base::func();
//如果子类中出现和父类同名的成员函数，子类的同名成员会隐藏掉父类中所有同名成员函数
//如果想访问到父类中被隐藏的同名成员函数，需要加作用域
//s.func(100);错误
s.Base::func(100); } int main() {
//test01();
test02();

system("pause"); } ``` **4.6.6 继承同名静态成员处理方式**
</code></pre></div></div> <p>静态成员和非静态成员出现同名，处理方式一致</p> <ul> <li>访问子类同名成员 直接访问即可</li> <li>访问父类同名成员 需要加作用域</li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="cp">#include</span><span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="c1">//继承中的构造和析构函数顺序</span>
<span class="k">class</span> <span class="nc">Base</span>
<span class="p">{</span>
<span class="nl">public:</span>
	
	<span class="k">static</span> <span class="kt">int</span> <span class="n">m_A</span><span class="p">;</span>

	<span class="k">static</span> <span class="kt">void</span> <span class="n">func</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Base - static void func()"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">static</span> <span class="kt">void</span> <span class="n">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Son - static void func()"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="n">Base</span><span class="o">::</span><span class="n">m_A</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Son</span> <span class="o">:</span><span class="k">public</span> <span class="n">Base</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">m_A</span><span class="p">;</span>
	
	<span class="k">static</span> <span class="kt">void</span> <span class="n">func</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Son - static void func()"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
	
<span class="p">};</span>
<span class="kt">int</span> <span class="n">Son</span><span class="o">::</span><span class="n">m_A</span> <span class="o">=</span> <span class="mi">200</span><span class="p">;</span>
<span class="c1">//同名静态成员属性</span>
<span class="kt">void</span> <span class="n">test01</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">Son</span> <span class="n">s</span><span class="p">;</span>
	<span class="c1">//1.通过对象访问</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"通过对象访问:"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Son 下m_A="</span> <span class="o">&lt;&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">m_A</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Base 下m_A="</span> <span class="o">&lt;&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">Base</span><span class="o">::</span><span class="n">m_A</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="c1">//2.通过类名访问</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"通过类名访问:"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Son 下m_A="</span> <span class="o">&lt;&lt;</span> <span class="n">Son</span><span class="o">::</span><span class="n">m_A</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="c1">//第一个::代表通过访问类名方式访问		第二个::代表访问父类作用域下</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Base 下m_A="</span> <span class="o">&lt;&lt;</span> <span class="n">Son</span><span class="o">::</span><span class="n">Base</span><span class="o">::</span><span class="n">m_A</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">test02</span><span class="p">()</span>
<span class="p">{</span>
	<span class="c1">//1.通过对象访问</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"通过对象访问:"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="n">Son</span> <span class="n">s</span><span class="p">;</span>
	<span class="n">s</span><span class="p">.</span><span class="n">func</span><span class="p">();</span>
	<span class="n">s</span><span class="p">.</span><span class="n">Base</span><span class="o">::</span><span class="n">func</span><span class="p">();</span>

	<span class="c1">//2.通过类名访问</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"通过类名访问:"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="n">Son</span><span class="o">::</span><span class="n">func</span><span class="p">();</span>
	<span class="n">Son</span><span class="o">::</span><span class="n">Base</span><span class="o">::</span><span class="n">func</span><span class="p">();</span>

	<span class="n">Son</span><span class="o">::</span><span class="n">Base</span><span class="o">::</span><span class="n">func</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">//test01();</span>
	<span class="n">test02</span><span class="p">();</span>
	<span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>总结：</strong> 同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象 和 通过类名）</p> <p><strong>4.6.7 多继承语法</strong></p> <p>C++允许一个类继承多个类 <img src="https://blog.slienceme.cn/images/posts/2020121414215130.png" alt="Alt Text" /> 多继承可能会引发父类中有同名成员出现，需要加作用域区分</p> <p><strong>C++实际开发不建议用多继承</strong></p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="cp">#include</span><span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="c1">//多继承语法</span>
<span class="k">class</span> <span class="nc">Base1</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="n">Base1</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">m_A</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="kt">int</span> <span class="n">m_A</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">class</span> <span class="nc">Base2</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="n">Base2</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">m_A</span> <span class="o">=</span> <span class="mi">200</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="kt">int</span> <span class="n">m_A</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">//子类		需要继承Base1和Base2</span>
<span class="c1">//语法：class 子类：继承方式 父类1，继承方式 父类2</span>
<span class="k">class</span> <span class="nc">Son</span> <span class="o">:</span><span class="k">public</span> <span class="n">Base1</span><span class="p">,</span> <span class="k">public</span> <span class="n">Base2</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="n">Son</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">m_C</span> <span class="o">=</span> <span class="mi">300</span><span class="p">;</span>
		<span class="n">m_D</span> <span class="o">=</span> <span class="mi">400</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="kt">int</span> <span class="n">m_C</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">m_D</span><span class="p">;</span>
<span class="p">};</span>
<span class="kt">void</span> <span class="n">test01</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">Son</span> <span class="n">s</span><span class="p">;</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"size of  Son ="</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="c1">//当父类中出现同名成员，需要加作用域区分</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Base1 下m_A="</span> <span class="o">&lt;&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">Base1</span><span class="o">::</span><span class="n">m_A</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Base2 下m_A="</span> <span class="o">&lt;&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">Base2</span><span class="o">::</span><span class="n">m_A</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">test01</span><span class="p">();</span>
	<span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>4.6.8 菱形继承</strong> <strong>菱形继承概念：</strong></p> <ul> <li>两个派生类继承同一个基类</li> <li>又有某个类同时继承着两个派生类</li> <li>这种继承被称为菱形继承，或者钻石继承</li> </ul> <p><img src="https://blog.slienceme.cn/images/posts/20201214143934475.png" alt="Alt Text" /> <img src="https://blog.slienceme.cn/images/posts/20201214143720483.png" alt="Alt Text" /></p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="cp">#include</span><span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="c1">//动物类</span>
<span class="k">class</span> <span class="nc">Animal</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="kt">int</span> <span class="n">m_Age</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">//利用虚继承	解决菱形继承的问题</span>
<span class="c1">//在继承前	加关键字virtual		变成虚继承</span>
<span class="c1">//Animal类称为		虚基类</span>
<span class="c1">//羊类</span>
<span class="k">class</span> <span class="nc">Sheep</span> <span class="o">:</span><span class="k">virtual</span> <span class="k">public</span> <span class="n">Animal</span><span class="p">{};</span>

<span class="c1">//驼类</span>
<span class="k">class</span> <span class="nc">Tuo</span> <span class="o">:</span><span class="k">virtual</span> <span class="k">public</span> <span class="n">Animal</span><span class="p">{};</span>

<span class="c1">//羊驼类</span>
<span class="k">class</span> <span class="nc">SheepTuo</span> <span class="o">:</span><span class="k">public</span> <span class="n">Sheep</span><span class="p">,</span> <span class="k">public</span> <span class="n">Tuo</span><span class="p">{};</span>

<span class="kt">void</span> <span class="n">test01</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">SheepTuo</span> <span class="n">st</span><span class="p">;</span>
	<span class="n">st</span><span class="p">.</span><span class="n">Sheep</span><span class="o">::</span><span class="n">m_Age</span> <span class="o">=</span> <span class="mi">18</span><span class="p">;</span>
	<span class="n">st</span><span class="p">.</span><span class="n">Tuo</span><span class="o">::</span><span class="n">m_Age</span> <span class="o">=</span> <span class="mi">28</span><span class="p">;</span>
	<span class="c1">//当出现菱形继承，有两个父类拥有相同的数据需要加作用域区分</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"st.Sheep::m_Age ="</span> <span class="o">&lt;&lt;</span> <span class="n">st</span><span class="p">.</span><span class="n">Sheep</span><span class="o">::</span><span class="n">m_Age</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"st.Tuo::m_Age = "</span> <span class="o">&lt;&lt;</span> <span class="n">st</span><span class="p">.</span><span class="n">Tuo</span><span class="o">::</span><span class="n">m_Age</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"st.m_Age = "</span> <span class="o">&lt;&lt;</span> <span class="n">st</span><span class="p">.</span><span class="n">m_Age</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

	<span class="c1">//这份数据我们知道	只有一份就可以，菱形继承导致数据有两份，资源浪费</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">test01</span><span class="p">();</span>
	<span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="47-多态">4.7 多态</h2> <p><strong>4.7.1 多态的基本概念</strong></p> <p><strong>多态是C++面向对象三大特性之一</strong></p> <p>多态分为两类</p> <ul> <li>静态多态：函数重载 和 运算符重载属于静态多态，符合函数名</li> <li>动态多台：派生类和虚函数实现运行时多态</li> </ul> <p>静态多态和动态多态区别</p> <ul> <li>静态多态的函数地址早绑定 - 编译阶段确定函数地址</li> <li>动态多态的函数地址晚绑定 - 运行阶段确定函数地址</li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="cp">#include</span><span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="c1">//多态</span>
<span class="c1">//动物类</span>
<span class="k">class</span> <span class="nc">Animal</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="c1">//虚函数</span>
	<span class="k">virtual</span> <span class="kt">void</span> <span class="n">speak</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"动物在说话"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="c1">//猫类</span>
<span class="k">class</span> <span class="nc">Cat</span> <span class="o">:</span><span class="k">public</span> <span class="n">Animal</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="c1">//重写		函数返回值类型		函数名		参数列表		完全相同</span>
	 <span class="kt">void</span> <span class="n">speak</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"小猫在说话"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">};</span>
<span class="k">class</span> <span class="nc">Dog</span> <span class="o">:</span><span class="k">public</span> <span class="n">Animal</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="kt">void</span> <span class="n">speak</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"小狗在说话"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">};</span>
<span class="c1">//执行说话的函数</span>
<span class="c1">//地址早绑定		在编译阶段确定函数地址</span>
<span class="c1">//如果想要执行让猫说话，那么这个函数地址就不能提前绑定，需要在运行阶段进行绑定，地址晚绑定</span>

<span class="c1">//动态多态满足条件</span>
<span class="c1">//1、有继承关系</span>
<span class="c1">//2、子类重写父类的虚函数</span>

<span class="c1">//动态多态使用</span>
<span class="c1">//父类的指针或者引用	执行子类对象</span>


<span class="kt">void</span> <span class="n">doSpeak</span><span class="p">(</span><span class="n">Animal</span> <span class="o">&amp;</span><span class="n">animal</span><span class="p">)</span> <span class="c1">//Animal &amp; animal =cat;</span>
<span class="p">{</span>
	<span class="n">animal</span><span class="p">.</span><span class="n">speak</span><span class="p">();</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">test01</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">Cat</span> <span class="n">cat</span><span class="p">;</span>
	<span class="n">doSpeak</span><span class="p">(</span><span class="n">cat</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">test01</span><span class="p">();</span>
	<span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>总结：</strong> 多态满足条件</p> <ul> <li>有继承关系</li> <li>子类重写父类中的虚函数</li> </ul> <p>多态使用条件</p> <ul> <li>父类指针或引用指向子类对象</li> </ul> <p>重写：函数返回值类型 函数名 参数列表 完全一致称为重写 <img src="https://blog.slienceme.cn/images/posts/20201214155637890.png" alt="Alt Text" /> 重写前： <img src="https://blog.slienceme.cn/images/posts/20201214155906298.png" alt="Alt Text" /> 重写后： <img src="https://blog.slienceme.cn/images/posts/20201214155922429.png" alt="Alt Text" /> <img src="https://blog.slienceme.cn/images/posts/20201214160023523.png" alt="Alt Text" /></p> <p><strong>4.7.2 多态案例一-计算机类</strong></p> <p>案例描述： 分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算机类</p> <p>多态的优点：</p> <ul> <li>代码组织结构清晰</li> <li>可读性强</li> <li>利于前期和后期的扩展以及维护</li> </ul> <p>普通实现：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="cp">#include</span><span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="c1">//普通写法</span>
<span class="k">class</span> <span class="nc">Calculator</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="kt">int</span> <span class="n">getResult</span><span class="p">(</span><span class="n">string</span> <span class="n">oper</span><span class="p">)</span> 
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">oper</span> <span class="o">==</span> <span class="s">"+"</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">return</span> <span class="n">m_Num1</span> <span class="o">+</span> <span class="n">m_Num2</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">oper</span> <span class="o">==</span> <span class="s">"-"</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">return</span> <span class="n">m_Num1</span> <span class="o">-</span> <span class="n">m_Num2</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">oper</span> <span class="o">==</span> <span class="s">"*"</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">return</span> <span class="n">m_Num1</span> <span class="o">*</span> <span class="n">m_Num2</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">oper</span> <span class="o">==</span> <span class="s">"/"</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">return</span> <span class="n">m_Num1</span> <span class="o">/</span> <span class="n">m_Num2</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="c1">//如果想要扩展新的功能，需要修改源码</span>
		<span class="c1">//在真的开发中	提倡		开闭原则</span>
		<span class="c1">//开闭原则：对扩展进行开放，对修改进行关闭</span>
	<span class="p">}</span>
	<span class="kt">int</span> <span class="n">m_Num1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">m_Num2</span><span class="p">;</span>
<span class="p">};</span>
<span class="kt">void</span> <span class="n">test01</span><span class="p">()</span>
<span class="p">{</span>
	<span class="c1">//创建一个计算器的对象</span>
	<span class="n">Calculator</span> <span class="n">c</span><span class="p">;</span>
	<span class="n">c</span><span class="p">.</span><span class="n">m_Num1</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
	<span class="n">c</span><span class="p">.</span><span class="n">m_Num2</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">c</span><span class="p">.</span><span class="n">m_Num1</span> <span class="o">&lt;&lt;</span> <span class="s">"+"</span> <span class="o">&lt;&lt;</span> <span class="n">c</span><span class="p">.</span><span class="n">m_Num2</span> <span class="o">&lt;&lt;</span> <span class="s">"="</span> <span class="o">&lt;&lt;</span> <span class="n">c</span><span class="p">.</span><span class="n">getResult</span><span class="p">(</span><span class="s">"+"</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">c</span><span class="p">.</span><span class="n">m_Num1</span> <span class="o">&lt;&lt;</span> <span class="s">"-"</span> <span class="o">&lt;&lt;</span> <span class="n">c</span><span class="p">.</span><span class="n">m_Num2</span> <span class="o">&lt;&lt;</span> <span class="s">"="</span> <span class="o">&lt;&lt;</span> <span class="n">c</span><span class="p">.</span><span class="n">getResult</span><span class="p">(</span><span class="s">"-"</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">c</span><span class="p">.</span><span class="n">m_Num1</span> <span class="o">&lt;&lt;</span> <span class="s">"*"</span> <span class="o">&lt;&lt;</span> <span class="n">c</span><span class="p">.</span><span class="n">m_Num2</span> <span class="o">&lt;&lt;</span> <span class="s">"="</span> <span class="o">&lt;&lt;</span> <span class="n">c</span><span class="p">.</span><span class="n">getResult</span><span class="p">(</span><span class="s">"*"</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">c</span><span class="p">.</span><span class="n">m_Num1</span> <span class="o">&lt;&lt;</span> <span class="s">"/"</span> <span class="o">&lt;&lt;</span> <span class="n">c</span><span class="p">.</span><span class="n">m_Num2</span> <span class="o">&lt;&lt;</span> <span class="s">"="</span> <span class="o">&lt;&lt;</span> <span class="n">c</span><span class="p">.</span><span class="n">getResult</span><span class="p">(</span><span class="s">"/"</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">test01</span><span class="p">();</span>
	<span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>多态性实现</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="cp">#include</span><span class="cpf">&lt;string&gt;</span><span class="cp">
</span>

<span class="c1">//利用多态实现计算机</span>

<span class="c1">//多态好处</span>
<span class="c1">//1.组织结构清晰</span>
<span class="c1">//2.可读性强</span>
<span class="c1">//3.对于前期和后期的扩展以及维护性高</span>

<span class="c1">//实现计算器抽象类</span>
<span class="k">class</span> <span class="nc">AbstractCalculator</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="k">virtual</span> <span class="kt">int</span> <span class="n">getResult</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="kt">int</span> <span class="n">m_Num1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">m_Num2</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">//加法计算器类</span>
<span class="k">class</span> <span class="nc">AddCalculator</span> <span class="o">:</span><span class="k">public</span> <span class="n">AbstractCalculator</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="kt">int</span> <span class="n">getResult</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">m_Num1</span> <span class="o">+</span> <span class="n">m_Num2</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">};</span>
<span class="c1">//减法计算器类</span>
<span class="k">class</span> <span class="nc">SubCalculator</span> <span class="o">:</span><span class="k">public</span> <span class="n">AbstractCalculator</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="kt">int</span> <span class="n">getResult</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">m_Num1</span> <span class="o">-</span> <span class="n">m_Num2</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">};</span>
<span class="c1">//乘法计算器类</span>
<span class="k">class</span> <span class="nc">MulCalculator</span> <span class="o">:</span><span class="k">public</span> <span class="n">AbstractCalculator</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="kt">int</span> <span class="n">getResult</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">m_Num1</span> <span class="o">*</span> <span class="n">m_Num2</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">};</span>
<span class="kt">void</span> <span class="n">test01</span><span class="p">()</span>
<span class="p">{</span>
	<span class="c1">//多态的使用条件</span>
	<span class="c1">//父类指针或者引用指向子类对象</span>
	
	<span class="c1">//加法运算</span>
	<span class="n">AbstractCalculator</span><span class="o">*</span> <span class="n">abc</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AddCalculator</span><span class="p">;</span>
	<span class="n">abc</span><span class="o">-&gt;</span><span class="n">m_Num1</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
	<span class="n">abc</span><span class="o">-&gt;</span><span class="n">m_Num2</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">abc</span><span class="o">-&gt;</span><span class="n">m_Num1</span> <span class="o">&lt;&lt;</span> <span class="s">"+"</span> <span class="o">&lt;&lt;</span> <span class="n">abc</span><span class="o">-&gt;</span><span class="n">m_Num2</span> <span class="o">&lt;&lt;</span> <span class="s">"="</span> <span class="o">&lt;&lt;</span> <span class="n">abc</span><span class="o">-&gt;</span><span class="n">getResult</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="c1">//用完后记得销毁</span>
	<span class="k">delete</span> <span class="n">abc</span><span class="p">;</span>

	<span class="c1">//减法运算</span>
	<span class="n">abc</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SubCalculator</span><span class="p">;</span>
	<span class="n">abc</span><span class="o">-&gt;</span><span class="n">m_Num1</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
	<span class="n">abc</span><span class="o">-&gt;</span><span class="n">m_Num2</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">abc</span><span class="o">-&gt;</span><span class="n">m_Num1</span> <span class="o">&lt;&lt;</span> <span class="s">"-"</span> <span class="o">&lt;&lt;</span> <span class="n">abc</span><span class="o">-&gt;</span><span class="n">m_Num2</span> <span class="o">&lt;&lt;</span> <span class="s">"="</span> <span class="o">&lt;&lt;</span> <span class="n">abc</span><span class="o">-&gt;</span><span class="n">getResult</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="k">delete</span> <span class="n">abc</span><span class="p">;</span>

	<span class="c1">//乘法运算</span>
	<span class="n">abc</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MulCalculator</span><span class="p">;</span>
	<span class="n">abc</span><span class="o">-&gt;</span><span class="n">m_Num1</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
	<span class="n">abc</span><span class="o">-&gt;</span><span class="n">m_Num2</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">abc</span><span class="o">-&gt;</span><span class="n">m_Num1</span> <span class="o">&lt;&lt;</span> <span class="s">"*"</span> <span class="o">&lt;&lt;</span> <span class="n">abc</span><span class="o">-&gt;</span><span class="n">m_Num2</span> <span class="o">&lt;&lt;</span> <span class="s">"="</span> <span class="o">&lt;&lt;</span> <span class="n">abc</span><span class="o">-&gt;</span><span class="n">getResult</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="k">delete</span> <span class="n">abc</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">test01</span><span class="p">();</span>
	<span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>总结：</strong> c++开发提倡利用多态设计程序架构，因为多态优点很多</p> <p><strong>4.7.3 纯虚函数和抽象类</strong></p> <p>在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容</p> <p>因此可以将虚函数改为<strong>纯虚函数</strong> <img src="https://blog.slienceme.cn/images/posts/20201214163236314.png" alt="Alt Text" /> 当类中有了纯虚函数，这个类也称为<strong>抽象类</strong></p> <p><strong>抽象类</strong>特点：</p> <ul> <li>无法实例化对象</li> <li>子类必须重写抽象类中的纯虚函数，否则也属于抽象类</li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="cp">#include</span><span class="cpf">&lt;string&gt;</span><span class="cp">
</span><span class="k">class</span> <span class="nc">Base</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="c1">//纯虚函数</span>
	<span class="c1">//只要有一个纯虚函数，这个类称为抽象类</span>
	<span class="c1">//抽象类特点：</span>
	<span class="c1">//1.无法实例化对象</span>
	<span class="c1">//2.抽象类的 子类必须重写父类中的纯虚函数,否则也属于抽象类</span>
	<span class="k">virtual</span> <span class="kt">void</span> <span class="n">func</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">class</span> <span class="nc">Son</span> <span class="o">:</span><span class="k">public</span> <span class="n">Base</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="k">virtual</span> <span class="kt">void</span> <span class="n">func</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"func函数调用"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">};</span>
<span class="p">};</span>
<span class="kt">void</span> <span class="n">test01</span><span class="p">()</span>
<span class="p">{</span>
	<span class="c1">//Base b; //抽象类是无法实例化对象</span>
	<span class="c1">//new Base;//抽象类是无法实例化对象</span>
	<span class="n">Son</span> <span class="n">s</span><span class="p">;</span><span class="c1">//抽象类的 子类必须重写父类中的纯虚函数,否则也属于抽象类,无法实例化对象</span>
	<span class="n">Base</span><span class="o">*</span> <span class="n">base</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Son</span><span class="p">;</span>
	<span class="n">base</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">();</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">test01</span><span class="p">();</span>
	<span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>4.7.4 多态案例二-制作饮品</strong> <img src="https://blog.slienceme.cn/images/posts/20201214164613224.png" alt="Alt Text" /></p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="cp">#include</span><span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">AbstractDrinking</span>
<span class="p">{</span>
<span class="nl">public:</span>

	<span class="c1">//煮水</span>
	<span class="k">virtual</span> <span class="kt">void</span> <span class="n">Boil</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="c1">//冲泡</span>
	<span class="k">virtual</span> <span class="kt">void</span> <span class="n">Brew</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="c1">//倒入杯中</span>
	<span class="k">virtual</span> <span class="kt">void</span> <span class="n">PourInCup</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="c1">//加入辅料</span>
	<span class="k">virtual</span> <span class="kt">void</span> <span class="n">PutSomething</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="c1">//制作饮品</span>
	<span class="kt">void</span> <span class="n">makeDrink</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">Boil</span><span class="p">();</span>
		<span class="n">Brew</span><span class="p">();</span>
		<span class="n">PourInCup</span><span class="p">();</span>
		<span class="n">PutSomething</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="c1">//制作coffee</span>
<span class="k">class</span> <span class="nc">Coffee</span> <span class="o">:</span> <span class="k">public</span> <span class="n">AbstractDrinking</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="c1">//煮水</span>
	<span class="k">virtual</span> <span class="kt">void</span> <span class="n">Boil</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"煮农夫山泉"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="c1">//冲泡</span>
	<span class="k">virtual</span> <span class="kt">void</span> <span class="n">Brew</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"冲泡咖啡"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="c1">//倒入杯中</span>
	<span class="k">virtual</span> <span class="kt">void</span> <span class="n">PourInCup</span><span class="p">()</span> 
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"倒入杯中"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="c1">//加入辅料</span>
	<span class="k">virtual</span> <span class="kt">void</span> <span class="n">PutSomething</span><span class="p">()</span> 
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"加入糖和牛奶"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="c1">//制作茶叶</span>
<span class="k">class</span> <span class="nc">Tea</span> <span class="o">:</span> <span class="k">public</span> <span class="n">AbstractDrinking</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="c1">//煮水</span>
	<span class="k">virtual</span> <span class="kt">void</span> <span class="n">Boil</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"煮矿泉水"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="c1">//冲泡</span>
	<span class="k">virtual</span> <span class="kt">void</span> <span class="n">Brew</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"冲泡茶叶"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="c1">//倒入杯中</span>
	<span class="k">virtual</span> <span class="kt">void</span> <span class="n">PourInCup</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"倒入杯中"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="c1">//加入辅料</span>
	<span class="k">virtual</span> <span class="kt">void</span> <span class="n">PutSomething</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"加入枸杞"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="n">doWork</span><span class="p">(</span><span class="n">AbstractDrinking</span> <span class="o">*</span> <span class="n">abs</span><span class="p">)</span>   <span class="c1">// AbstractDrinking  * abs  = new  Coffee</span>
<span class="p">{</span>
	<span class="n">abs</span><span class="o">-&gt;</span><span class="n">makeDrink</span><span class="p">();</span>
	<span class="k">delete</span> <span class="n">abs</span><span class="p">;</span>  <span class="c1">//释放</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">test01</span><span class="p">()</span>
<span class="p">{</span>
	<span class="c1">//制作咖啡</span>
	<span class="n">doWork</span><span class="p">(</span><span class="k">new</span> <span class="n">Coffee</span><span class="p">);</span>

	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"--------------------"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="c1">//制作茶叶</span>
	<span class="n">doWork</span><span class="p">(</span><span class="k">new</span> <span class="n">Tea</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">test01</span><span class="p">();</span>
	<span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>4.7.5 虚析构和纯虚析构</strong> 多态使用时，如果子类中有属性开辟到堆区，那么父类指针无法调用到子类的析构代码</p> <p>解决方式：将父类中的析构函数改为<strong>虚析构</strong>或者<strong>纯虚析构</strong></p> <p>虚析构和纯虚析构共性：</p> <ul> <li>可以解决父类指针释放子类对象</li> <li>都需要有具体的函数实现</li> </ul> <p>虚析构和纯虚析构区别：</p> <ul> <li>如果是纯虚析构，该类属于抽象类，无法实例化对象 <img src="https://blog.slienceme.cn/images/posts/20201214170640187.png" alt="Alt Text" /></li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="cp">#include</span><span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">Animal</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="n">Animal</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Animal 构造函数调用"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="c1">//利用虚析构可以解决	父类指针释放子类对象时不干净的问题</span>
	<span class="cm">/*virtual ~Animal()
	{
		cout &lt;&lt; "Animal 析构函数调用" &lt;&lt; endl;
	}*/</span>

	<span class="c1">//纯虚析构  需要声明  也需要  具体实现</span>
	<span class="c1">//有了纯虚析构后，这个类也属于抽象类，无法实例化对象</span>
	<span class="k">virtual</span> <span class="o">~</span><span class="n">Animal</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="c1">//纯虚函数</span>
	<span class="k">virtual</span> <span class="kt">void</span> <span class="n">speak</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">Animal</span><span class="o">::</span> <span class="o">~</span><span class="n">Animal</span><span class="p">()</span> 
<span class="p">{</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Animal 纯虚析构函数调用"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Cat</span> <span class="o">:</span><span class="k">public</span> <span class="n">Animal</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="n">Cat</span><span class="p">(</span><span class="n">string</span> <span class="n">name</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Cat构造函数调用"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
		<span class="n">m_Name</span> <span class="o">=</span> <span class="k">new</span> <span class="n">string</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="o">~</span><span class="n">Cat</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">m_Name</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Cat析构函数调用"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
			<span class="k">delete</span> <span class="n">m_Name</span><span class="p">;</span>
			<span class="n">m_Name</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">virtual</span> <span class="kt">void</span> <span class="n">speak</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">m_Name</span> <span class="o">&lt;&lt;</span> <span class="s">"小猫在说话"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">string</span><span class="o">*</span> <span class="n">m_Name</span><span class="p">;</span>
<span class="p">};</span>


<span class="kt">void</span> <span class="n">test01</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">Animal</span><span class="o">*</span> <span class="n">animal</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Cat</span><span class="p">(</span><span class="s">"Tom"</span><span class="p">);</span>
	<span class="n">animal</span><span class="o">-&gt;</span><span class="n">speak</span><span class="p">();</span>
	<span class="c1">//父类的指针在析构的时候，不会调用子类中析构函数，导致子类如果有堆区属性，出现内存泄漏</span>
	<span class="k">delete</span> <span class="n">animal</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">test01</span><span class="p">();</span>
	<span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>4.7.6 多态案例三-电脑组装</strong></p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="cp">#include</span><span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="c1">//抽象CPU类</span>
<span class="k">class</span> <span class="nc">CPU</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="c1">//抽象计算函数</span>
	<span class="k">virtual</span> <span class="kt">void</span> <span class="n">calculate</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">//抽象显卡类</span>
<span class="k">class</span> <span class="nc">VideoCard</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="c1">//抽象显示函数</span>
	<span class="k">virtual</span> <span class="kt">void</span> <span class="n">display</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">//抽象内存条类</span>
<span class="k">class</span> <span class="nc">Memory</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="c1">//抽象存储函数</span>
	<span class="k">virtual</span> <span class="kt">void</span> <span class="n">storage</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">//电脑类</span>
<span class="k">class</span> <span class="nc">Computer</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="n">Computer</span><span class="p">(</span><span class="n">CPU</span><span class="o">*</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">VideoCard</span><span class="o">*</span> <span class="n">vc</span><span class="p">,</span> <span class="n">Memory</span><span class="o">*</span> <span class="n">mem</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">m_cpu</span> <span class="o">=</span> <span class="n">cpu</span><span class="p">;</span>
		<span class="n">m_vc</span> <span class="o">=</span> <span class="n">vc</span><span class="p">;</span>
		<span class="n">m_mem</span> <span class="o">=</span> <span class="n">mem</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="c1">//提供工作的函数</span>
	<span class="kt">void</span> <span class="n">work</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="c1">//让零件调用	接口</span>
		<span class="n">m_cpu</span><span class="o">-&gt;</span><span class="n">calculate</span><span class="p">();</span>
		<span class="n">m_vc</span><span class="o">-&gt;</span><span class="n">display</span><span class="p">();</span>
		<span class="n">m_mem</span><span class="o">-&gt;</span><span class="n">storage</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="c1">//提供析构函数	释放3个电脑零件</span>
	<span class="o">~</span><span class="n">Computer</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">m_cpu</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">delete</span> <span class="n">m_cpu</span><span class="p">;</span>
			<span class="n">m_cpu</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">m_vc</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">delete</span> <span class="n">m_vc</span><span class="p">;</span>
			<span class="n">m_vc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">m_mem</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">delete</span> <span class="n">m_mem</span><span class="p">;</span>
			<span class="n">m_mem</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">private:</span>
	<span class="n">CPU</span><span class="o">*</span><span class="n">m_cpu</span><span class="p">;</span>					<span class="c1">//CPU的零件指针</span>
	<span class="n">VideoCard</span><span class="o">*</span> <span class="n">m_vc</span><span class="p">;</span>			<span class="c1">//显卡的零件指针</span>
	<span class="n">Memory</span><span class="o">*</span> <span class="n">m_mem</span><span class="p">;</span>			<span class="c1">//内存条的零件指针</span>
<span class="p">};</span>

<span class="c1">//具体厂商</span>
<span class="c1">//Inter厂商</span>
<span class="k">class</span> <span class="nc">InterCPU</span> <span class="o">:</span><span class="k">public</span> <span class="n">CPU</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="k">virtual</span> <span class="kt">void</span> <span class="n">calculate</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Inter的CPU开始计算了！"</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">};</span>
<span class="k">class</span> <span class="nc">InterVideoCard</span> <span class="o">:</span><span class="k">public</span> <span class="n">VideoCard</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="k">virtual</span> <span class="kt">void</span> <span class="n">display</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Inter的显卡开始显示了！"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">};</span>
<span class="k">class</span> <span class="nc">InterMemory</span> <span class="o">:</span><span class="k">public</span> <span class="n">Memory</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="k">virtual</span> <span class="kt">void</span> <span class="n">storage</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Inter的内存条开始存储了！"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="c1">//Lenovo厂商</span>
<span class="k">class</span> <span class="nc">LenovoCPU</span> <span class="o">:</span><span class="k">public</span> <span class="n">CPU</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="k">virtual</span> <span class="kt">void</span> <span class="n">calculate</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Lenovo的CPU开始计算了！"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">};</span>
<span class="k">class</span> <span class="nc">LenovoVideoCard</span> <span class="o">:</span><span class="k">public</span> <span class="n">VideoCard</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="k">virtual</span> <span class="kt">void</span> <span class="n">display</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Lenovo的显卡开始显示了！"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">};</span>
<span class="k">class</span> <span class="nc">LenovoMemory</span> <span class="o">:</span><span class="k">public</span> <span class="n">Memory</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="k">virtual</span> <span class="kt">void</span> <span class="n">storage</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Lenovo的内存条开始存储了！"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">};</span>


<span class="kt">void</span> <span class="n">test01</span><span class="p">()</span>
<span class="p">{</span>
	<span class="c1">//第一台电脑零件</span>
	<span class="n">CPU</span><span class="o">*</span> <span class="n">interCpu</span> <span class="o">=</span> <span class="k">new</span> <span class="n">InterCPU</span><span class="p">;</span>
	<span class="n">VideoCard</span><span class="o">*</span> <span class="n">interCard</span> <span class="o">=</span> <span class="k">new</span> <span class="n">InterVideoCard</span><span class="p">;</span>
	<span class="n">Memory</span><span class="o">*</span> <span class="n">intelMem</span> <span class="o">=</span> <span class="k">new</span> <span class="n">InterMemory</span><span class="p">;</span>

	<span class="c1">//创建第一台电脑</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"第一台电脑开始工作"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="n">Computer</span><span class="o">*</span> <span class="n">computer1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Computer</span><span class="p">(</span><span class="n">interCpu</span><span class="p">,</span> <span class="n">interCard</span><span class="p">,</span> <span class="n">intelMem</span><span class="p">);</span>
	<span class="n">computer1</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">();</span>
	<span class="k">delete</span> <span class="n">computer1</span><span class="p">;</span>


	<span class="c1">//创建第二台电脑</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"---------------------------------------------"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"第二台电脑开始工作"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="n">Computer</span><span class="o">*</span> <span class="n">computer2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Computer</span><span class="p">(</span><span class="k">new</span> <span class="n">LenovoCPU</span><span class="p">,</span> <span class="k">new</span> <span class="n">LenovoVideoCard</span><span class="p">,</span> <span class="k">new</span> <span class="n">LenovoMemory</span><span class="p">);</span>
	<span class="n">computer2</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">();</span>
	<span class="k">delete</span> <span class="n">computer2</span><span class="p">;</span>

	<span class="c1">//创建第三台电脑</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"---------------------------------------------"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"第三台电脑开始工作"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="n">Computer</span><span class="o">*</span> <span class="n">computer3</span><span class="o">=</span> <span class="k">new</span> <span class="n">Computer</span><span class="p">(</span><span class="k">new</span> <span class="n">LenovoCPU</span><span class="p">,</span> <span class="k">new</span> <span class="n">InterVideoCard</span><span class="p">,</span> <span class="k">new</span> <span class="n">LenovoMemory</span><span class="p">);</span>
	<span class="n">computer3</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">();</span>
	<span class="k">delete</span> <span class="n">computer3</span><span class="p">;</span>

<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">test01</span><span class="p">();</span>
	<span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <h1 id="5文件操作">5.文件操作</h1> <p><strong>c++中对文件操作需要包含头文件&lt;fstream’&gt;</strong></p> <p><strong>文件类型分为两种：</strong> <strong>1.文本文件</strong>：文件以文本的ASCII码形式存储在计算机中 <strong>2.二进制文件</strong>：文件以文本的二进制存储在计算机中，用户一般不能直接读懂他们</p> <p><strong>操作文件的三大类：</strong></p> <ol> <li>ofstream: 写操作</li> <li>ifstream: 读操作</li> <li>fstream: 读写操作</li> </ol> <h2 id="51文本文件">5.1文本文件</h2> <p><strong>5.1.1写文件</strong> 写文件步骤如下：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. 包含头文件
	#include&lt;fstream&gt;
2. 创建流对象
	ofstream ofs;
3. 打开文件
	ofs.open("文件路径",打开方式)；
4.写数据
	ofs&lt;&lt;"写入的数据";
4. 关闭文件
	ofs.close();
</code></pre></div></div> <p><strong>文件打开方式：</strong> <img src="https://blog.slienceme.cn/images/posts/20201212213912543.png" alt="Alt Text" /> <strong>注意：</strong>文件打开方式可以配合使用，利用|操作符 例如：用二进制方式写文件 ios::binary || ios:out</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="cp">#include</span><span class="cpf">&lt;fstream&gt;</span><span class="cp">
</span><span class="kt">void</span> <span class="nf">test1</span><span class="p">()</span>
<span class="p">{</span>
	<span class="c1">//1.包含头文件 fstream</span>
	<span class="c1">//2.穿件流对象</span>
	<span class="n">ofstream</span> <span class="n">ofs</span><span class="p">;</span>
	<span class="c1">//3.指定打开方式</span>
	<span class="n">ofs</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="s">"test.txt"</span><span class="p">,</span> <span class="n">ios</span><span class="o">::</span><span class="n">out</span><span class="p">);</span>
	<span class="c1">//4.写内容</span>
	<span class="n">ofs</span> <span class="o">&lt;&lt;</span> <span class="s">"姓名：张三"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="c1">//5.关闭文件</span>
	<span class="n">ofs</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">test1</span><span class="p">();</span>
	<span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>总结：</strong></p> <ul> <li>文件操作必须包含头文件 fstream</li> <li>读文件可以利用 ofstream, 或者 fstream类</li> <li>打开文件时候需要指定操作文件的路径，以及打开方式</li> <li>利用«可以向文件中写数据</li> <li>操作完毕 ，需要关闭文件</li> <li><strong>5.1.2 读文件</strong></li> </ul> <p>读文件步骤如下：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. 包含头文件
	#include&lt;fstream&gt;
2. 创建流对象
	ofstream ifs;
3. 打开文件并判断文件是否打开成功
	ifs.open("文件路径",打开方式)；
4.读数据
	四种方式读取
4. 关闭文件
	ifs.close();
</code></pre></div></div> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="cp">#include</span><span class="cpf">&lt;fstream&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="c1">//文本文件	读文件</span>
<span class="kt">void</span> <span class="nf">test01</span><span class="p">()</span>
<span class="p">{</span>
	<span class="c1">//1、 包含头文件</span>

	<span class="c1">//2、创建流对象</span>
	<span class="n">ifstream</span> <span class="n">ifs</span><span class="p">;</span>

	<span class="c1">//3、打开文件	并且判断是否打开成功</span>
	<span class="n">ifs</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="s">"test.txt"</span><span class="p">,</span> <span class="n">ios</span><span class="o">::</span><span class="n">in</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">ifs</span><span class="p">.</span><span class="n">is_open</span><span class="p">())</span>
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"文件打开失败"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="c1">//4.读数据</span>
	<span class="c1">//第一种</span>
	<span class="cm">/*char buf[1024] = { 0 };
	while (ifs &gt;&gt; buf)
	{
		cout &lt;&lt; buf &lt;&lt; endl;
	}*/</span>

	<span class="c1">//第二种</span>
	<span class="cm">/*char buf[1024] = { 0 };
	while (ifs.getline(buf, sizeof(buf)))
	{
		cout &lt;&lt; buf &lt;&lt; endl;
	}*/</span>
	 
	<span class="c1">//第三种</span>
	<span class="cm">/*string buf;
	while (getline(ifs, buf))
	{
		cout &lt;&lt; buf &lt;&lt; endl;
	}*/</span>

	<span class="c1">//第四种</span>
	<span class="kt">char</span> <span class="n">c</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span>		<span class="p">(</span><span class="n">c</span> <span class="o">=</span> <span class="n">ifs</span><span class="p">.</span><span class="n">get</span><span class="p">())</span>		<span class="o">!=</span> <span class="n">EOF</span>		<span class="p">)</span>  <span class="c1">// EOF end of file</span>
	<span class="p">{</span>	
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">c</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="c1">//5.关闭文件</span>
	<span class="n">ifs</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>
<span class="p">}</span> 

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">test01</span><span class="p">();</span>
	<span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>总结：</strong></p> <ul> <li>读文件可以利用ifstream,或者fstream类</li> <li>利用is_open函数可以判断文件是否打开成功</li> <li>close关闭文件</li> </ul> <h2 id="52-二进制文件">5.2 二进制文件</h2> <p>以二进制方式对文件进行读写操作 打开方式要指定为 ios::binary</p> <p><strong>5.2.1 写文件</strong></p> <p>二进制方式写文件主要利用流对象调用成员函数write <img src="https://blog.slienceme.cn/images/posts/20201214185752558.png" alt="Alt Text" /> 参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="cp">#include</span><span class="cpf">&lt;fstream&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="c1">//二进制文件		写文件</span>
<span class="k">class</span> <span class="nc">Person</span>
<span class="p">{</span>
<span class="nl">public:</span>

	<span class="kt">char</span> <span class="n">m_Name</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span><span class="c1">//姓名</span>
	<span class="kt">int</span> <span class="n">m_Age</span><span class="p">;</span><span class="c1">//年龄</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="n">test01</span><span class="p">()</span>
<span class="p">{</span>
	<span class="c1">//1. 包含头文件</span>
		
	<span class="c1">//2. 创建流对象</span>
	<span class="n">ofstream</span> <span class="n">ofs</span><span class="p">(</span><span class="s">"person.txt"</span><span class="p">,</span> <span class="n">ios</span><span class="o">::</span><span class="n">out</span> <span class="o">|</span> <span class="n">ios</span><span class="o">::</span><span class="n">binary</span><span class="p">);</span>
	<span class="c1">//3. 打开文件</span>
	<span class="cm">/*ofs.open("person.txt", ios::out | ios::binary);*/</span>
	<span class="c1">//4.写文件</span>
	<span class="n">Person</span> <span class="n">p</span> <span class="o">=</span> <span class="p">{</span> <span class="s">"张三"</span><span class="p">,</span> <span class="mi">18</span> <span class="p">};</span>
	<span class="n">ofs</span><span class="p">.</span><span class="n">write</span><span class="p">((</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Person</span><span class="p">));</span>
	<span class="c1">//5. 关闭文件</span>
	<span class="n">ofs</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">test01</span><span class="p">();</span>
	<span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>总结：</strong></p> <ul> <li>文件输出流对象 可以通过write函数，以二进制方式写数据</li> </ul> <p><strong>5.2.2 读文件</strong></p> <p>二进制方式读文件主要利用流对象调用成员函数read <img src="https://blog.slienceme.cn/images/posts/20201214191224907.png" alt="Alt Text" /> 参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数</p> <div style="margin-top:2em;padding:0 1.5em;border:1px solid #d3d3d3;background-color:#deebf7"> <h3>文档信息</h3> <ul> <li>本文作者：<a href="https://blog.slienceme.cn" target="_blank">slience_me</a></li> <li>本文链接：<a href="https://blog.slienceme.cn/2020/11/30/C++%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/" target="_blank">https://blog.slienceme.cn/2020/11/30/C++%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</a></li> <li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank">创意共享3.0许可证</a>）</li> </ul> </div> </article> <div class="share"> <div class="share-component" data-disabled='qq,facebook'></div> </div> <div class="comment"> <script src="https://giscus.app/client.js" data-repo="slience-me/blog-comments" data-repo-id="R_kgDOKr27jA" data-category="Announcements" data-category-id="DIC_kwDOKr27jM4CnWMe" data-mapping="title" data-strict="1" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="light" data-lang="zh-CN" data-loading="lazy" crossorigin="anonymous" async> </script> </div> </div> <div class="column one-fourth"> <h3>Search</h3> <div id="site_search"> <input style="width:96%" type="text" id="search_box" placeholder="Search"> </div> <ul id="search_results" style="font-size:14px;list-style-type:none;padding-top:10px;padding-left:10px;"></ul> <script src="https://blog.slienceme.cn/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: 'https://blog.slienceme.cn/assets/search_data.json?v=1740598833', searchResultTemplate: '<li><a href="{url}" title="{title}">{title}</a></li>', noResultsText: 'No results found', limit: 10, fuzzy: false, exclude: ['Welcome'] }) </script> <h3 class="post-directory-title mobile-hidden">Table of Contents</h3> <div id="post-directory-module" class="mobile-hidden"> <section class="post-directory"> <dl></dl> </section> </div> <script src="https://blog.slienceme.cn/assets/js/jquery.toc.js"></script> </div> </div> </section> <footer class="container"> <div class="site-footer" role="contentinfo"> <div class="copyright left mobile-block"> Copyright@ 2019-2025 slience_me 版权所有&emsp; <img src="/images/logo/logo.png" class="w-full" style="width: 12px;"> <a href="https://beian.mps.gov.cn/#/query/webSearch?code=13102202000626" rel="noreferrer" target="_blank">冀公网安备13102202000626</a>&emsp; <a href="https://beian.miit.gov.cn/#/Integrated/index" target="_blank" rel="noreferrer">津ICP备2024026565号-1</a> <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a> </div> <ul class="site-footer-links right mobile-hidden"> <li> <a href="javascript:window.scrollTo(0,0)" >TOP</a> </li> </ul> <br/> <script defer src="https://vercount.one/js"></script> <div class="mobile-hidden" style="margin-top:8px"> <span id="busuanzi_container_site_pv" style="display:none"> 本站访问量<span id="busuanzi_value_site_pv"></span>次 </span> <span id="busuanzi_container_site_uv" style="display:none"> / 本站访客数<span id="busuanzi_value_site_uv"></span>人 </span> <span id="busuanzi_container_page_pv" style="display:none"> / 本页访问量<span id="busuanzi_value_page_pv"></span>次 / 统计始于2024-12-01 </span> </div> </div> </footer> <div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a> </div> <script src="https://blog.slienceme.cn/assets/vendor/share.js/dist/js/share.min.js"></script> <script src="https://blog.slienceme.cn/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function($) { $('.geopattern').each(function(){ $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script> </body> </html>
